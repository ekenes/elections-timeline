import{gl as Z,gm as v,am as f,ab as j,gn as R,ao as p,go as _,d_ as y,F as U,ee as k,aT as O,gp as N,ag as P,aZ as D,bu as S,aJ as L,aK as q,cG as E,gq as I,al as J,dL as g,_ as K}from"./index-c2b82012.js";import{t as F}from"./json-48e3ea08.js";const u=[0,0];function w(i,t){if(!t)return null;if("x"in t){const n={x:0,y:0};return[n.x,n.y]=i(t.x,t.y,u),t.z!=null&&(n.z=t.z),t.m!=null&&(n.m=t.m),n}if("xmin"in t){const n={xmin:0,ymin:0,xmax:0,ymax:0};return[n.xmin,n.ymin]=i(t.xmin,t.ymin,u),[n.xmax,n.ymax]=i(t.xmax,t.ymax,u),t.hasZ&&(n.zmin=t.zmin,n.zmax=t.zmax,n.hasZ=!0),t.hasM&&(n.mmin=t.mmin,n.mmax=t.mmax,n.hasM=!0),n}return"rings"in t?{rings:x(t.rings,i),hasM:t.hasM,hasZ:t.hasZ}:"paths"in t?{paths:x(t.paths,i),hasM:t.hasM,hasZ:t.hasZ}:"points"in t?{points:b(t.points,i),hasM:t.hasM,hasZ:t.hasZ}:null}function x(i,t){const n=[];for(const e of i)n.push(b(e,t));return n}function b(i,t){const n=[];for(const e of i){const a=t(e[0],e[1],[0,0]);n.push(a),e.length>2&&a.push(e[2]),e.length>3&&a.push(e[3])}return n}async function B(i,t){if(!i||!t)return;const n=Array.isArray(i)?i.map(e=>e.geometry!=null?e.geometry.spatialReference:null).filter(U):[i];await k(n.map(e=>({source:e,dest:t})))}const z=w.bind(null,Z),M=w.bind(null,v);function A(i,t,n,e){if(!i)return null;if(n||(n=t,t=i.spatialReference),!y(t)||!y(n)||f(t,n))return i;if(R(t,n)){const a=p(n)?z(i):M(i);return a.spatialReference=n,a}return _(F,[i],t,n,null,e)[0]}class G{constructor(){this._jobs=[],this._timer=null,this._process=this._process.bind(this)}async push(t,n,e,a){if(!(t!=null&&t.length)||!n||!e||f(n,e))return t;const r={geometries:t,inSpatialReference:n,outSpatialReference:e,geographicTransformation:a,resolve:j()};return this._jobs.push(r),this._timer??(this._timer=setTimeout(this._process,10)),r.resolve.promise}_process(){this._timer=null;const t=this._jobs.shift();if(!t)return;const{geometries:n,inSpatialReference:e,outSpatialReference:a,resolve:r,geographicTransformation:o}=t;R(e,a)?p(a)?r(n.map(z)):r(n.map(M)):r(_(F,n,e,a,o,null)),this._jobs.length>0&&(this._timer=setTimeout(this._process,10))}}const V=new G;function ii(i,t,n,e){return V.push(i,t,n,e)}const C=new O({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),d=Object.freeze({});async function ti(i,t,n){const e=i.bin,{onField:a,expression:r,splitBy:o,splitByField:s,splitByAlias:c,stackBy:m,stackByField:l,stackByAlias:h}=e;return a&&(e.onField=a.trim()),r&&(e.expression=r.trim()),o&&(e.splitBy=o.trim()),s&&(e.splitByField=s.trim()),c&&(e.splitByAlias=c.trim()),m&&(e.stackBy=m.trim()),l&&(e.stackByField=l.trim()),h&&(e.stackByAlias=h.trim()),"normalizationField"in e.parameters&&e.parameters.normalizationField&&(e.parameters.normalizationField=e.parameters.normalizationField.trim()),H(i,t,n)}async function H(i,t,n){const{outFields:e,orderByFields:a,groupByFieldsForStatistics:r,outStatistics:o}=i;if(e)for(let s=0;s<e.length;s++)e[s]=e[s].trim();if(a)for(let s=0;s<a.length;s++)a[s]=a[s].trim();if(r)for(let s=0;s<r.length;s++)r[s]=r[s].trim();if(o)for(let s=0;s<o.length;s++)o[s].onStatisticField&&(o[s].onStatisticField=o[s].onStatisticField.trim());return i.geometry&&!i.outSR&&(i.outSR=i.geometry.spatialReference),Q(i,t,n)}async function Q(i,t,n){var r;if(!i)return null;let{where:e}=i;if(i.where=e=e==null?void 0:e.trim(),(!e||/^1 *= *1$/.test(e)||t&&t===e)&&(i.where=null),!i.geometry)return i;let a=await X(i);if(i.distance=0,i.units=null,i.spatialRel==="esriSpatialRelEnvelopeIntersects"){const{spatialReference:o}=i.geometry;a=N(a),a.spatialReference=o}if(a){await B(a.spatialReference,n),a=W(a,n);const o=(await P(D(a)))[0];if(o==null)throw d;const s="quantizationParameters"in i&&((r=i.quantizationParameters)==null?void 0:r.tolerance)||"maxAllowableOffset"in i&&i.maxAllowableOffset||0,c=s&&T(a,n)?{densificationStep:8*s}:void 0,m=o.toJSON(),l=A(m,m.spatialReference,n,c);if(!l)throw d;l.spatialReference=n,i.geometry=l}return i}function T(i,t){if(!i)return!1;const n=i.spatialReference;return(S(i)||L(i)||q(i))&&!f(n,t)&&!E(n,t)}function W(i,t){const n=i.spatialReference;return T(i,t)&&S(i)?{spatialReference:n,rings:[[[i.xmin,i.ymin],[i.xmin,i.ymax],[i.xmax,i.ymax],[i.xmax,i.ymin],[i.xmin,i.ymin]]]}:i}async function X(i){const{distance:t,units:n}=i,e=i.geometry;if(t==null||"vertexAttributes"in e)return e;const a=e.spatialReference,r=n?C.fromJSON(n):I(a),o=a&&(J(a)||p(a))?e:await B(a,g).then(()=>A(e,g)),s=await K(()=>import("./geodesicBufferOperator-e42dae4a.js"),["assets/geodesicBufferOperator-e42dae4a.js","assets/index-c2b82012.js","assets/index-c76e6b87.css","assets/geodeticCurveType-23f89349.js","assets/SimpleGeometryCursor-e3941f41.js"]);return await s.load(),s.execute(o,t,{unit:r})??void 0}function ni(i,t){return i==null?null:typeof i=="string"?t?new Date(`1970-01-01T${i}Z`).getTime():new Date(i).getTime():i instanceof Date?i.getTime():i}export{ni as B,Q as F,ti as R,H as S,ii as b,C as d,d as g,A as j,B as x};
