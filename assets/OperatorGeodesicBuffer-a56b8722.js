import{s as Et,t as Rt}from"./SimpleGeometryCursor-e3941f41.js";import{x as J,A as zt,b as M,M as Xt,c as ct,_ as It,e as Bt,a as N,n as T,w as Yt,o as Ot,l as Ft,O as ut,f as Wt,g as gt,G as U,h as nt,i as Gt,m as Jt,j as pt,y as j,k as H,p as Ut,L as jt,r as Ht,z as B,s as Q,t as Pt,u as xt,v as $,B as Lt,C as Vt,D as W,E as bt,H as yt,N as ot,I as mt,J as Zt,K as at,P as E,Q as Y,S as y,T as k,U as x,V as D,W as Kt,X as A,Y as Qt,Z as $t,$ as te,a0 as it,a1 as tt,a2 as et,a3 as wt,a4 as ee,a5 as O,a6 as se}from"./OperatorProject-1ae2812c.js";import{fL as S,fM as R}from"./index-c2b82012.js";import{i as ne}from"./GeometryCleaner-DVgW95-D-f2147f71.js";function ie(g,t,s,e,m,r){e<Number.MAX_VALUE&&e>-Number.MAX_VALUE||ct("Geodesic_bufferer.buffer - bad distance"),It(g);const o=ne(g),i=o.getGeometryType();if(Bt(i)){const n=o.getPointCount(),u=8e6;if(Math.abs(e)>u&&(n>50||i!==N.enumMultiPoint&&s===4&&n>2)){let a=o;const l=e>0?1:-1,h=7e6;let _=e,c=1;do c++,_=(Math.abs(_)-h)*l;while(Math.abs(_)>u);_=e;for(let d=0;d<c-1;d++)a=ht(a,t,s,h*l,m,c,r),_=(Math.abs(_)-h)*l;return a=ht(a,t,s,_,m,c,r),a}}return ht(o,t,s,e,m,1,r)}class re{constructor(t){this.m_sr=null,this.m_gcs=null,this.m_transform=null,this.m_a=0,this.m_eSquared=0,this.m_rpu=0,this.m_radTolerance=0,this.m_q90=0,this.m_gcs90=0,this.m_gcs180=0,this.m_gcs360=0,this.m_gcs60=0,this.m_ellipticToGeodesicMaxRatio=0,this.m_curveType=0,this.m_bShapePreserving=!1,this.m_distance=0,this.m_absDistance=0,this.m_convergenceOffset=0,this.m_cornerStep=0,this.m_segmentStep=0,this.m_progressTracker=t}bufferPolygon(t){const s=new T,e=new St(this,t,s);return this.processGnomonicBufferPiecesCursor(!0,e)}bufferPolyline(t){const s=new St(this,t,null);return this.processGnomonicBufferPiecesCursor(!0,s)}bufferMultiPoint(t){const s=new ae(this,t);return this.processGnomonicBufferPiecesCursor(!1,s)}bufferPoint(t){const s=t.getXY();s.scale(this.m_rpu);let e=new T;if(this.bufferPoint2D(s,!1,e)){const m=B(null,e,!0);e=Q(e,m,!0,!0,-1,this.m_progressTracker,0,!1)}return e=new H().foldInto360RangeGeodetic(e,this.m_gcs,2),e}processGnomonicBufferPiecesCursor(t,s){const e=s;let m=e.getGnomonic();const r=Pt(xt()),o=new se;r.queryPrecisionDescriptor(o),o.setTolerance(0,.001),Pt(xt(),void 0,o);let i=new $,n=new J().executeMany(i,r,this.m_progressTracker,2);const u=Lt(6,!1),a=Vt(M,6);this.initializeGrid(u,a);const l=[null,null,null,null,null,null],h=[null,null,null,null,null,null],_=[null,null,null,null,null,null];let c,d,f;for(;(c=e.next())!==null;){if(d=e.getGnomonic(),d!==m){if(m!==null){let P=n.next();if(i=null,n=null,P!=null){const p=B(r,P,!0),C=U(p);P=m.unproject(P,C,this.m_progressTracker),this.putInGridCursors(t,P,r,!0,u,a,l,h,_)}}d!==null&&(i=new $,n=new J().executeMany(i,r,this.m_progressTracker,2)),m=d}if(e.isRunningInGnomonic()){if(d.project(c),e.needsSimplify()){const P=B(null,c,!0);c=Q(c,P,!0,!0,-1,this.m_progressTracker,0,!1)}i.tick(st(c)),n.tock()}else this.putInGridCursors(t,c,r,!0,u,a,l,h,_)}let b=!1;for(let P=0;P<6;P++)if(_[P]!=null){b=!0;break}if(b){let P=!1;const p=[null,null,null,null,null,null];if(t){const w=e.m_densified;if(e.m_densified=null,w!==null){const v=new W;v.scale(1/this.m_rpu,1/this.m_rpu),w.applyTransformation(v),this.m_distance>0?this.putInGridCursors(t,w,r,!1,u,a,l,h,_):(this.processInGrid(t,w,!1,u,a,l,p),P=!0)}}const C=new $,I=new J().executeMany(C,this.m_gcs,this.m_progressTracker,2);if(n!==null){let w=n.next();i=null,n=null;const v=B(r,w,!0),G=U(v);w=m.unproject(w,G,this.m_progressTracker),this.putInGridCursors(t,w,r,!0,u,a,l,h,_)}for(let w=0;w<6;w++)if(_[w]!=null){let v=_[w].next();_[w]=null,h[w]=null,P&&p[w]!==null&&(v=new bt().execute(p[w],v,r,this.m_progressTracker));const G=B(r,v,!0),q=U(G);v=l[w].unproject(v,q,this.m_progressTracker),v=new yt().execute(v,this.m_gcs,!0,this.m_progressTracker),C.tick(st(v)),I.tock()}f=I.next()}else{let P,p=!1;if(t){let v=e.m_densified;if(e.m_densified=null,v!==null){const G=new W;G.scale(1/this.m_rpu,1/this.m_rpu),v.applyTransformation(G),d.project(v);const q=B(null,v,!0);v=Q(v,q,!1,!0,-1,this.m_progressTracker,0,!1),this.m_distance>0?(i.tick(st(v)),n.tock()):(P=v,p=!0)}}let C=n.next();i=null,n=null,p&&(C=new bt().execute(P,C,r,this.m_progressTracker));const I=B(r,C,!0),w=U(I);f=m.unproject(C,w,this.m_progressTracker),f=new yt().execute(f,this.m_gcs,!0,this.m_progressTracker)}return f=new H().foldInto360RangeGeodetic(f,this.m_gcs,2),f}putInGridCursors(t,s,e,m,r,o,i,n,u){const a=[null,null,null,null,null,null];this.processInGrid(t,s,m,r,o,i,a);for(let l=0;l<6;l++)a[l]!==null&&(n[l]===null&&(n[l]=new $,u[l]=new J().executeMany(n[l],e,this.m_progressTracker,2)),n[l].tick(st(a[l])),u[l].tock())}processInGrid(t,s,e,m,r,o,i){const u=this.insertGeodeticPointsAlongGrid(s,r,.01);for(let a=0;a<6;a++){if(m[a])continue;const l=r[a].clone();l.inflateCoords(.01,.01);const h=ot(s,l),_=nt(null,h,!1).total();let c=mt(u,l,_,Number.NaN,this.m_progressTracker);if(c!==null&&!c.isEmpty()){if(c===u&&(c=c.clone()),o[a]===null){const f=new y;a<3?f.setCoords(0,1):f.setCoords(0,-1);const b=new y;b.setAdd(r[a].getCenter(),f),o[a]=V(this.m_gcs,b)}o[a].project(c);const d=B(null,c,!0);c=Q(c,d,e,!0,-1,this.m_progressTracker,0,!1),i[a]=c}}}insertGeodeticPointsAlongGrid(t,s,e){const m=M.construct(s[3].xmin,s[3].ymin,s[2].xmax,s[2].ymax),r=Zt(this.m_gcs,m,t,!0,this.m_progressTracker),o=new at,i=o.addGeometry(r);return E(o,i,this.m_gcs,0,2,!0,s[0].xmax+e),E(o,i,this.m_gcs,0,2,!0,s[1].xmax+e),E(o,i,this.m_gcs,0,2,!1,s[1].ymin+e),e!==0&&(E(o,i,this.m_gcs,0,2,!0,s[0].xmax-e),E(o,i,this.m_gcs,0,2,!0,s[1].xmax-e),E(o,i,this.m_gcs,0,2,!1,s[1].ymin-e)),o.getGeometry(i)}initializeGrid(t,s){for(let e=0;e<6;e++)t[e]=!1;s[0].setCoords({xmin:-this.m_gcs180,ymin:0,xmax:-this.m_gcs60,ymax:this.m_gcs90}),s[1].setCoords({xmin:-this.m_gcs60,ymin:0,xmax:this.m_gcs60,ymax:this.m_gcs90}),s[2].setCoords({xmin:this.m_gcs60,ymin:0,xmax:this.m_gcs180,ymax:this.m_gcs90}),s[3].setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:-this.m_gcs60,ymax:0}),s[4].setCoords({xmin:-this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs60,ymax:0}),s[5].setCoords({xmin:this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:0})}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(t,s,e,m,r,o){const i=t[0],n=t.at(-1),u=i.y<n.y?i.y:n.y,a=i.y>n.y?i.y:n.y,l=ut.q(this.m_a,this.m_eSquared,u),h=ut.q(this.m_a,this.m_eSquared,a);if(this.m_q90-(l+s+this.m_absDistance)>.001&&this.m_q90+(h-s-this.m_absDistance)>.001)return!1;const _=e-O,c=m+O,d=_-Math.PI,f=_+Math.PI,b=c+Math.PI,P=[Number.NaN],p=[Number.NaN],C=[Number.NaN],I=[Number.NaN];let w=!1;if(Ct(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,i,_,d,n,c,P,p),Ct(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,n,b,c,i,d,C,I),(c<P[0]&&P[0]<b||c<p[0]&&p[0]<b)&&(w=!0),w||(d<C[0]&&C[0]<_||d<I[0]&&I[0]<_)&&(w=!0),!w&&r)return!1;const v=[];for(let z=t.length-1;z>=0;z--)v.push(t[z]);o.setEmpty(),o.addPathPoint2D(null,0,!0);let G=0;G=lt(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,t,_,c,r,G,o),G=L(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,n,c,b,this.m_cornerStep,r,G,o,P[0],p[0]),G=lt(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,v,b,f,r,G,o),G=L(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,i,d,_,this.m_cornerStep,r,G,o,C[0],I[0]);let q=!1;return r||(q=this.checkAndPrepForPole(o)),w||q}bufferPoint2D(t,s,e){e.setEmpty(),e.addPathPoint2D(null,0,!0);const m=0;L(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,t,-this.m_cornerStep,2*Math.PI,this.m_cornerStep,s,m,e);let r=!1;return s||(r=this.checkAndPrepForPole(e)),r}checkAndPrepForPole(t){const s=this.checkAndPrepForPoleTouch(t),e=this.checkAndPrepForPoleWrap(t);return s||e}checkAndPrepForPoleTouch(t){const s=new M;return t.queryEnvelope(s),!(!Y(s.ymax,this.m_gcs90)&&!Y(s.ymin,-this.m_gcs90))&&(this.prepPoleTouch(t),!0)}checkAndPrepForPoleWrap(t){const s=t.getXY(0),e=t.getXY(t.getPointCount()-1);return Math.abs(s.x-e.x)>this.m_gcs180?(this.prepSinglePoleWrap(t),!0):this.checkAndPrepForDoublePoleWrap(t)}checkAndPrepForDoublePoleWrap(t){return t.calculateArea2D()<0&&(this.prepDoublePoleWrap(t),!0)}prepPoleTouch(t){const s=new T;s.insertPath2D(-1,null,0,0,!0);const e=t.getPathStart(0),m=t.getPathEnd(0),r=m-e;let o=-1;for(o=e;o<m;o++){const a=t.getXY(o),l=Y(a.y,this.m_gcs90),h=Y(a.y,-this.m_gcs90);if(!l&&!h)break}let i=o,n=!1,u=Number.NaN;do{const a=t.getXY(i),l=Y(a.y,this.m_gcs90),h=Y(a.y,-this.m_gcs90),_=e+(i+1-e)%r;if(l||h){let c=y.construct(u,a.y);s.insertPoint2D(0,-1,c);const d=t.getXY(_),f=Y(d.y,this.m_gcs90),b=Y(d.y,-this.m_gcs90);f||b||(c=y.construct(d.x,a.y),n?s.setXY(s.getPointCount()-1,c):s.insertPoint2D(0,-1,c)),n=!0}else s.insertPoint2D(0,-1,a),u=a.x,n=!1;i=_}while(i!==o);t.setEmpty(),t.add(s,!1)}prepSinglePoleWrap(t){const s=new T,e=new T,m=new W,r=t.getXY(t.getPathStart(0)),o=t.getXY(t.getPathEnd(0)-1),i=this.m_gcs360,n=this.m_gcs180,u=new M;u.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const a=new M;t.queryEnvelope(a);const l=Math.ceil(a.width()/i);let h,_;r.x>o.x?(h=-i,_=this.m_gcs90):(h=i,_=-this.m_gcs90),m.setShiftCoords(h,0),s.addPath(t,0,!0),e.add(s,!1);const c=new Gt;for(let X=0;X<l;X++)e.applyTransformation(m),e.getPointByVal(0,c),s.lineToPoint(c),s.addSegmentsFromPath(e,0,0,e.getSegmentCount()-1,!1);const d=s.getXY(0),f=s.getXY(s.getPointCount()-1);d.y=_,f.y=_,s.lineTo(f);const b=new y;for(b.setCoordsPoint2D(f),b.x-=.5*h;Math.abs(b.x-d.x)>n;)s.lineTo(b),b.x-=.5*h;s.lineTo(d);const P=u.getCenterX(),p=new M;s.queryEnvelope(p);let C=0;const I=p.getCenter().x;I-P>n?C=-Math.ceil((I-P-n)/i):P-I>n&&(C=Math.ceil((P-I-n)/i)),C!==0&&(m.setShiftCoords(C*i,0),s.applyTransformation(m));const w=new at,v=w.addGeometry(s);E(w,v,this.m_gcs,0,2,!0,u.xmin),E(w,v,this.m_gcs,0,2,!0,u.xmax);const G=w.getGeometry(v),q=ot(G,u);q.inflateCoords(0,1);const z=nt(null,q,!0).total(),F=mt(G,u,z,Number.NaN,this.m_progressTracker);t.setEmpty(),t.add(F,!1)}prepDoublePoleWrap(t){const s=this.m_gcs360,e=this.m_gcs180,m=new M;m.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const r=m.getCenter().x,o=new M;t.queryPathEnvelope(0,o);let i,n=0,u=o.getCenter().x;if(u-r>e?n=-Math.ceil((u-r-e)/s):r-u>e&&(n=Math.ceil((r-u-e)/s)),n!==0){const _=new W;_.setShiftCoords(n*s,0),t.getImpl().applyTransformationToPath(_,0),t.queryPathEnvelope(0,o),u=o.getCenter().x}const a=new M;m.containsExclusiveEnvelope(o)?(i=!1,a.setCoords({env2D:m})):(i=!0,a.setCoords({env2D:m}),a.xmin-=s,a.xmax+=s);let l=t.createInstance();l.addPathPoint2D(null,0,!0);const h=new y;if(h.setCoords(a.xmin,a.ymin),l.insertPoint2D(0,-1,h),h.setCoords(a.xmin,a.ymax),l.insertPoint2D(0,-1,h),h.setCoords(.5*(a.xmin+a.xmax),a.ymax),l.insertPoint2D(0,-1,h),h.setCoords(a.xmax,a.ymax),l.insertPoint2D(0,-1,h),h.setCoords(a.xmax,a.ymin),l.insertPoint2D(0,-1,h),h.setCoords(.5*(a.xmin+a.xmax),a.ymin),l.insertPoint2D(0,-1,h),i){l.addPath(t,0,!0);const _=new W;u<r?_.setShiftCoords(s,0):_.setShiftCoords(-s,0),t.getImpl().applyTransformationToPath(_,0),l.addPath(t,0,!0);const c=new at,d=c.addGeometry(l);E(c,d,this.m_gcs,0,2,!0,m.xmin),E(c,d,this.m_gcs,0,2,!0,m.xmax),l=c.getGeometry(d);const f=ot(l,m);f.inflateCoords(0,1);const b=nt(null,f,!0).total();l=mt(l,m,b,Number.NaN,this.m_progressTracker)}else l.addPath(t,0,!0);t.setEmpty(),t.add(l,!1)}setMinCornerStep(){const t={stack:[],error:void 0,hasError:!1};try{let s=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);s=Math.min(s,.125*this.m_a*Math.PI);const e=new y;e.setCoords(0,10*this.m_rpu);const m=0;let r=45*this.m_rpu;const o=S(t,new k(new x,new x),!1),i=S(t,new k(new x,new x),!1),n=S(t,new k(new x,new x),!1),u=S(t,new k(new x,new x),!1),a=new y,l=new y,h=new y,_=new y;for(D.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,m,o.at(0),o.at(1)),a.setCoords(o.at(0).val,o.at(1).val),D.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,r,i.at(0),i.at(1)),l.setCoords(i.at(0).val,i.at(1).val);;){const f={stack:[],error:void 0,hasError:!1};try{const b=.5*(m+r);D.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,b,n.at(0),n.at(1)),h.setCoords(n.at(0).val,n.at(1).val);const P=S(f,new x,!1),p=S(f,new x,!1);D.geodeticDistance(this.m_a,this.m_eSquared,a.x,a.y,l.x,l.y,P,p,null,2),D.geodeticCoordinate(this.m_a,this.m_eSquared,a.x,a.y,.5*P.val,p.val,u.at(0),u.at(1),2),_.setCoords(u.at(0).val,u.at(1).val);const C=S(f,new x,!1);if(D.geodeticDistance(this.m_a,this.m_eSquared,h.x,h.y,_.x,_.y,C,null,null,2),C.val<=this.m_convergenceOffset)break;r*=.9,D.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,r,i.at(0),i.at(1)),l.setCoords(i.at(0).val,i.at(1).val)}catch(b){f.error=b,f.hasError=!0}finally{R(f)}}const c=r-m,d=2*Math.PI/Math.ceil(2*Math.PI/c);this.m_cornerStep=d}catch(s){t.error=s,t.hasError=!0}finally{R(t)}}setMinSegmentStep(){const t={stack:[],error:void 0,hasError:!1};try{let s=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);s=Math.min(s,.125*this.m_a*Math.PI);const e=new y,m=new y;e.setCoords(0,10*this.m_rpu),m.setCoords(10*this.m_rpu,10*this.m_rpu);const r=S(t,new x,!1),o=S(t,new x,!1),i=S(t,new x,!1);D.geodeticDistance(this.m_a,this.m_eSquared,e.x,e.y,m.x,m.y,i,r,o,this.m_curveType);const n=S(t,new k(new x,new x),!1),u=S(t,new k(new x,new x),!1),a=new y,l=S(t,new x,!1),h=S(t,new k(new x,new x),!1),_=S(t,new k(new x,new x),!1),c=S(t,new k(new x,new x),!1),d=S(t,new k(new x,new x),!1),f=new y,b=new y,P=new y,p=new y,C=0;let I=1;const w=r.val,v=o.val,G=w-.5*Math.PI,q=v+.5*Math.PI,z=i.val;for(D.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,G,h.at(0),h.at(1)),f.setCoords(h.at(0).val,h.at(1).val),D.geodesicCoordinate(this.m_a,this.m_eSquared,m.x,m.y,s,q,_.at(0),_.at(1)),b.setCoords(_.at(0).val,_.at(1).val);;){const X={stack:[],error:void 0,hasError:!1};try{const rt=.5*(C+I);D.geodeticCoordinate(this.m_a,this.m_eSquared,e.x,e.y,rt*z,w,n.at(0),n.at(1),this.m_curveType),a.setCoords(n.at(0).val,n.at(1).val),D.geodeticDistance(this.m_a,this.m_eSquared,e.x,e.y,a.x,a.y,null,null,l,this.m_curveType);const At=l.val+.5*Math.PI;D.geodesicCoordinate(this.m_a,this.m_eSquared,a.x,a.y,s,At,c.at(0),c.at(1)),P.setCoords(c.at(0).val,c.at(1).val);const _t=S(X,new x,!1),ft=S(X,new x,!1);D.geodeticDistance(this.m_a,this.m_eSquared,f.x,f.y,b.x,b.y,_t,ft,null,2),D.geodeticCoordinate(this.m_a,this.m_eSquared,f.x,f.y,.5*_t.val,ft.val,d.at(0),d.at(1),2),p.setCoords(d.at(0).val,d.at(1).val);const dt=S(X,new x,!1);if(D.geodeticDistance(this.m_a,this.m_eSquared,P.x,P.y,p.x,p.y,dt,null,null,2),dt.val<=this.m_convergenceOffset)break;{const Z={stack:[],error:void 0,hasError:!1};try{I*=.9,D.geodeticCoordinate(this.m_a,this.m_eSquared,e.x,e.y,I*z,w,u.at(0),u.at(1),this.m_curveType),m.setCoords(u.at(0).val,u.at(1).val);const K=S(Z,new x,!1);D.geodeticDistance(this.m_a,this.m_eSquared,e.x,e.y,m.x,m.y,null,null,K,this.m_curveType);const qt=K.val+.5*Math.PI;D.geodesicCoordinate(this.m_a,this.m_eSquared,m.x,m.y,s,qt,_.at(0),_.at(1)),b.setCoords(_.at(0).val,_.at(1).val)}catch(K){Z.error=K,Z.hasError=!0}finally{R(Z)}}}catch(rt){X.error=rt,X.hasError=!0}finally{R(X)}}let F=I*z;F>1e5&&(F=1e5),this.m_segmentStep=F}catch(s){t.error=s,t.hasError=!0}finally{R(t)}}setConvergenceOffset(){let t;t=this.m_absDistance>5e4?100:this.m_absDistance>1e4?10:1,this.m_absDistance/t<500&&(t=this.m_absDistance/500),t<.01&&(t=.01),this.m_convergenceOffset=t}}function ht(g,t,s,e,m,r,o){if(g.isEmpty())return new T({vd:g.getDescription()});let i=g;if(Yt(i)){const f=10*t.getTolerance(0);i=new Ot().execute(i,0,f,0,o,12e3)}const n=new re(o);n.m_sr=t,n.m_gcs=t.getGCS(),n.m_transform=Ft(t,n.m_gcs,null);const u=Kt();n.m_gcs.querySpheroidData(u);const a=new M;i.queryEnvelope(a),n.m_a=u.majorSemiAxis,n.m_eSquared=u.e2,n.m_rpu=n.m_gcs.getUnit().getUnitToBaseFactor(),n.m_gcs90=.5*Math.PI/n.m_rpu,n.m_gcs180=Math.PI/n.m_rpu,n.m_gcs360=2*Math.PI/n.m_rpu,n.m_gcs60=n.m_gcs360/6,n.m_q90=ut.q90(n.m_a,n.m_eSquared),n.m_ellipticToGeodesicMaxRatio=.5*n.m_a*Math.PI/n.m_q90;const l=n.m_gcs.getTolerance(0);n.m_radTolerance=l*n.m_rpu,s===4?(n.m_curveType=2,n.m_bShapePreserving=!0):(n.m_curveType=s,n.m_bShapePreserving=!1),n.m_distance=e,n.m_absDistance=Math.abs(e),Number.isNaN(m)||m<=0?n.setConvergenceOffset():n.m_convergenceOffset=Math.max(m,.001),n.m_convergenceOffset/=r;let h,_=i.getGeometryType();if(Wt(_)){const f=new gt({vd:i.getDescription()});f.addSegment(i,!0),h=f,_=N.enumPolyline}else if(_===N.enumEnvelope){const f=i,b=new M;f.queryEnvelope(b);const P=U(nt(n.m_sr,a,!0));if(b.minDimension()<=P)if(b.maxDimension()===0){const p=new Gt({vd:i.getDescription()});f.getCenter(p),h=p,_=N.enumPoint}else{const p=new gt({vd:i.getDescription()});p.addEnvelope(f,!1),h=p,_=N.enumPolyline}else{const p=new T({vd:i.getDescription()});p.addEnvelope(f,!1),h=p,_=N.enumPolygon}}else h=i;if(n.setMinCornerStep(),Jt(_)||n.setMinSegmentStep(),n.m_absDistance<=.5*n.m_convergenceOffset)return _!==N.enumPolygon?new T({vd:h.getDescription()}):n.m_bShapePreserving?h:pt(h,n.m_sr,n.m_curveType,n.m_segmentStep,-1,o);if(n.m_distance<0&&_!==N.enumPolygon)return new T({vd:h.getDescription()});if(n.m_bShapePreserving&&j(_)){const f=pt(h,t,4,Number.NaN,n.m_convergenceOffset,o);h=new H().execute(f,n.m_transform,o)}else h=new H().execute(h,n.m_transform,o);if(h=Ut(h,n.m_gcs),h.isEmpty())return new T({vd:h.getDescription()});!n.m_bShapePreserving&&j(_)&&(h=jt(n.m_rpu,h)),h=oe(h,n.m_gcs);let c=new T;switch(_){case N.enumPolygon:c=n.bufferPolygon(h);break;case N.enumPolyline:c=n.bufferPolyline(h);break;case N.enumMultiPoint:c=n.bufferMultiPoint(h);break;case N.enumPoint:c=n.bufferPoint(h);break;default:Ht("")}const d=new H().execute(c,n.m_transform.getInverse(),o);return d.mergeVertexDescription(h.getDescription()),d}function lt(g,t,s,e,m,r,o,i,n,u,a){const l={stack:[],error:void 0,hasError:!1};try{const h=new y;h.setNAN(),n||a.getPointCount()>0&&(h.setCoordsPoint2D(a.getXY(a.getPointCount()-1)),h.scale(s));const _=S(l,new x,!1),c=S(l,new k(new x,new x),!1),d=new y,f=new y,b=r.at(-1),P=1/s;for(let p=0;p<r.length;p++){const C=r[p];let I;p===0?I=o:p===r.length-1?I=i:(D.geodeticDistance(g,t,b.x,b.y,C.x,C.y,null,null,_,m),I=_.val-.5*Math.PI),D.geodesicCoordinate(g,t,C.x,C.y,e,I,c.at(0),c.at(1)),n?f.setCoords(c.at(0).val,c.at(1).val):(d.setCoords(c.at(0).val,c.at(1).val),u=Mt(C.x,d.x,h.x,u),f.setCoords(u+d.x,d.y),h.setCoordsPoint2D(f)),f.scale(P),a.insertPoint2D(0,-1,f)}return u}catch(h){l.error=h,l.hasError=!0}finally{R(l)}}function L(g,t,s,e,m,r,o,i,n,u,a,l=Number.NaN,h=Number.NaN){const _={stack:[],error:void 0,hasError:!1};try{if(o-r<i)return u;const c=S(_,new k(new x,new x),!1),d=new y,f=new y,b=new y;f.setNAN(),n||a.getPointCount()>0&&(f.setCoordsPoint2D(a.getXY(a.getPointCount()-1)),f.scale(s));let P=Math.ceil(r/i),p=P++*i;p===r&&(p=P++*i);let C=r;const I=1/s;for(;p<o+i&&(C<l&&l<p?(p=l,P--):C<h&&h<p&&(p=h,P--),!(p>=o));)D.geodesicCoordinate(g,t,m.x,m.y,e,p,c.at(0),c.at(1)),n?b.setCoords(c.at(0).val,c.at(1).val):(d.setCoords(c.at(0).val,c.at(1).val),u=Mt(m.x,d.x,f.x,u),b.setCoords(u+d.x,d.y),f.setCoordsPoint2D(b)),b.scale(I),a.insertPoint2D(0,-1,b),C=p,p=P++*i;return u}catch(c){_.error=c,_.hasError=!0}finally{R(_)}}function Ct(g,t,s,e,m,r,o,i,n,u,a){const l={stack:[],error:void 0,hasError:!1};try{const h=new y,_=new y,c=S(l,new k(new x,new x),!1);D.geodesicCoordinate(g,t,m.x,m.y,e,r,c.at(0),c.at(1)),h.setCoords(c.at(0).val,c.at(1).val),D.geodesicCoordinate(g,t,m.x,m.y,e,o,c.at(0),c.at(1)),_.setCoords(c.at(0).val,c.at(1).val);const d=S(l,new x,!1);for(D.geodeticDistance(g,t,i.x,i.y,h.x,h.y,null,d,null,0),u[0]=d.val,D.geodeticDistance(g,t,i.x,i.y,_.x,_.y,null,d,null,0),a[0]=d.val;u[0]<=a[0];)u[0]+=A;for(;u[0]>a[0];)u[0]-=A;for(;u[0]>=n;)u[0]-=A,a[0]-=A;for(;u[0]<n;)u[0]+=A,a[0]+=A}catch(h){l.error=h,l.hasError=!0}finally{R(l)}}function Mt(g,t,s,e){if(Number.isNaN(s)){for(;e+t-g>Math.PI;)e-=A;for(;g-(e+t)>Math.PI;)e+=A;return e}return e+t-s>Math.PI?e-=A:s-(e+t)>Math.PI&&(e+=A),e}function oe(g,t){const s=g.getGeometryType();let e;if(e=j(s)?g.getPathCount():s===N.enumMultiPoint?g.getPointCount():1,e===1)return g;const m=[],r=[];for(let i=0;i<e;i++){m.push(i);const n=new y;if(j(s)){const a=new M;g.queryPathEnvelope(i,a),n.assign(a.getCenter())}else n.assign(g.getXY(i));const u=t.toGeohash(n);r.push(u)}m.sort((i,n)=>r[i]<r[n]?-1:r[i]>r[n]?1:0);const o=g.createInstance();for(let i=0;i<e;i++){const n=m[i];j(s)?o.addPath(g,n,!0):o.addPoints(g,n,n+1)}return o}function Tt(g,t,s,e,m,r){const o={stack:[],error:void 0,hasError:!1};try{if(e>=r)return!1;const i=s[0],n=s.at(-1),u=S(o,new x,!1),a=S(o,new x,!1),l=S(o,new x,!1);D.greatEllipticDistance(g,t,m.x,m.y,i.x,i.y,u,null,null),D.greatEllipticDistance(g,t,m.x,m.y,n.x,n.y,a,null,null),D.greatEllipticDistance(g,t,i.x,i.y,n.x,n.y,l,null,null);let h=Math.min(u.val,a.val)+l.val,_=h+e;if(_<r)return!0;const c=S(o,new x,!1);h=Math.max(u.val,a.val);for(let d=1;d<s.length-1;d++){const f=s[d];D.greatEllipticDistance(g,t,m.x,m.y,f.x,f.y,c,null,null),c.val>h&&(h=c.val)}return _=h+e,_<r}catch(i){o.error=i,o.hasError=!0}finally{R(o)}}function vt(g,t,s,e,m,r,o,i){let n;if(e.length%2==0){const l=e.length>>1,h=e[l],_=e[l-1];n=y.lerp(h,_,.5)}else n=e[e.length-1>>1].clone();const u=n.clone(),a=it(g,t,u,75/180*Math.PI);return!!Tt(g,t,e,m,u,a)&&(r!==null&&(r.setCoordsPoint2D(n),r.scale(1/s)),o!==null&&o.setCoordsPoint2D(u),i!==null&&(i[0]=a),!0)}function Nt(g,t,s,e,m,r){const o={stack:[],error:void 0,hasError:!1};try{if(e>=r)return!1;const i=S(o,new x,!1);return D.greatEllipticDistance(g,t,m.x,m.y,s.x,s.y,i,null,null),i.val+e<r}catch(i){o.error=i,o.hasError=!0}finally{R(o)}}function me(g,t,s,e,m,r,o,i){const n=it(g,t,e,.4166666666666667*Math.PI);return!!Nt(g,t,e,m,e,n)&&(r!==null&&(r.setCoordsPoint2D(e),r.scale(1/s)),o!==null&&o.setCoordsPoint2D(e),i!==null&&(i[0]=n),!0)}function V(g,t){return new Qt(g,t)}function st(g){return $t(g,0)||te(g,0),g}class kt{constructor(t){this.m_bRunningInGnomonic=!1,this.m_bNeedsSimplify=!1,this.m_gnomonic=null,this.m_gnomonicCenterRad=new y,this.m_minGnomonicRadius=Number.NaN,this.m_progressTracker=t}isRunningInGnomonic(){return this.m_bRunningInGnomonic}needsSimplify(){return this.m_bNeedsSimplify}getGnomonic(){return this.m_gnomonic}}class St extends kt{constructor(t,s,e){super(t.m_progressTracker),this.m_segIter=null,this.m_bNextSegmentCannotJoin=!1,this.m_currentDensifiedDelta=[0],this.m_currentBufferedDelta=0,this.m_lastAzimuth=0,this.m_startAzimuth=[0],this.m_endAzimuth=[0],this.m_numWinds=0,this.m_debugCounter=0,this.m_bufferHelper=new T,this.m_densifiedPoints=[],this.m_bufferer=t,this.m_multiPath=s,this.m_densified=e,this.m_bNeedsSimplify=!0;const m=new M;this.m_multiPath.queryEnvelope(m);const r=m.getCenter(),o=r.clone();o.scale(this.m_bufferer.m_rpu),this.m_gnomonic=V(this.m_bufferer.m_gcs,r),this.m_gnomonicCenterRad=o.clone(),this.m_minGnomonicRadius=it(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,o,75/180*Math.PI)}next(){let t;if(this.m_bNextSegmentCannotJoin)return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),t=this.m_bufferHelper.clone(),t;if(this.m_segIter===null){if(this.m_segIter=this.m_multiPath.getImpl().querySegmentIterator(),!this.m_segIter.nextPath())return null;this.m_densified!==null&&this.m_densified.addPathPoint2D(null,0,!0)}if(!this.m_segIter.hasNextSegment()){if(!this.m_segIter.nextPath())return null;this.m_densified!=null&&this.m_densified.addPathPoint2D(null,0,!0)}let s=null;this.m_currentBufferedDelta=0,this.m_currentDensifiedDelta=[0],this.m_numWinds=0,this.m_lastAzimuth=Number.NaN,this.m_bNextSegmentCannotJoin=!1,this.m_densifiedPoints.length=0;const e=16;let m=0;const r=new y,o=new y;for(;this.m_segIter.hasNextSegment()&&this.m_numWinds<e;){const i=this.m_segIter.nextSegment();if(r.setCoordsPoint2D(i.getStartXY()),o.setCoordsPoint2D(i.getEndXY()),r.scale(this.m_bufferer.m_rpu),o.scale(this.m_bufferer.m_rpu),tt(r,o))r.x=o.x;else if(et(r,o))o.x=r.x;else{let u=-1,a=-1;const l=this.m_segIter.getPathIndex(),h=this.m_multiPath.getPathStart(l),_=this.m_multiPath.getPathEnd(l);if(u=this.m_segIter.getStartPointIndex()-1,a=this.m_segIter.getEndPointIndex()+1,u<h&&(u=this.m_multiPath.isClosedPath(l)?_-1:-1),a>_-1&&(a=this.m_multiPath.isClosedPath(l)?h:-1),u!==-1){const c=this.m_multiPath.getXY(u);c.scale(this.m_bufferer.m_rpu),et(c,r)&&(r.x=c.x)}if(a!==-1){const c=this.m_multiPath.getXY(a);c.scale(this.m_bufferer.m_rpu),tt(o,c)&&(o.x=c.x)}}this.m_densifiedPoints.length=0;const n=wt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,r,o,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta);if(m===0)this.m_bRunningInGnomonic=this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(this.m_densifiedPoints));else if(this.m_bRunningInGnomonic){if(!this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}}else if(vt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_densifiedPoints,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,null,null,null)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}if(n===0||ee(r,o)?(this.m_bufferHelper.setEmpty(),this.m_bufferer.bufferPoint2D(r,this.m_bRunningInGnomonic,this.m_bufferHelper),this.m_bNextSegmentCannotJoin=!0):(this.m_bufferHelper.setEmpty(),this.m_bNextSegmentCannotJoin=this.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(n,this.m_bufferHelper)),this.m_bNextSegmentCannotJoin){this.m_segIter.previousSegment(),this.m_segIter.hasPreviousSegment()?(this.m_segIter.previousSegment(),this.m_segIter.nextSegment()):this.m_segIter.resetToFirstSegment(),this.m_densified!=null&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0);break}this.m_densified!=null&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0),s===null&&(s=new T,s.addPathPoint2D(null,0,!0)),this.addJoinAndBufferLeftSide(s),m++}if(this.m_currentDensifiedDelta=[0],m>0){const i=this.m_segIter.getStartPointIndex(),n=this.m_segIter.getPathIndex();for(;m>0;){if(this.m_segIter.previousSegment(),r.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),o.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getEndPointIndex())),r.scale(this.m_bufferer.m_rpu),o.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic)if(tt(r,o))r.x=o.x;else if(et(r,o))o.x=r.x;else{let u=-1,a=-1;const l=this.m_segIter.getPathIndex(),h=this.m_multiPath.getPathStart(l),_=this.m_multiPath.getPathEnd(l);if(u=this.m_segIter.getStartPointIndex()-1,a=this.m_segIter.getEndPointIndex()+1,u<h&&(u=this.m_multiPath.isClosedPath(l)?_-1:-1),a>_-1&&(a=this.m_multiPath.isClosedPath(l)?h:-1),u!==-1){const c=this.m_multiPath.getXY(u);c.scale(this.m_bufferer.m_rpu),et(c,r)&&(r.x=c.x)}if(a!==-1){const c=this.m_multiPath.getXY(a);c.scale(this.m_bufferer.m_rpu),tt(o,c)&&(o.x=c.x)}}this.m_densifiedPoints.length=0,wt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,o,r,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta),this.addJoinAndBufferLeftSide(s),m--}return r.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),r.scale(this.m_bufferer.m_rpu),this.m_currentBufferedDelta=L(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,r,this.m_lastAzimuth+.5*Math.PI,this.m_lastAzimuth+1.5*Math.PI,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,s),this.m_segIter.resetToVertex(i,n),this.m_segIter.nextSegment(),s}return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),t=this.m_bufferHelper.clone(),t}isSegmentBufferInCurrentGnomonic(t){return this.m_gnomonic!==null&&Tt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(t){const s=new y,e=new y,m=[0];return vt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,s,e,m)?(this.m_gnomonicCenterRad.setCoordsPoint2D(e),this.m_minGnomonicRadius=m[0],this.m_gnomonic=V(this.m_bufferer.m_gcs,s),!0):(this.m_gnomonic=null,!1)}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(t,s){return this.m_bufferer.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(this.m_densifiedPoints,t,this.m_startAzimuth[0],this.m_endAzimuth[0],this.m_bRunningInGnomonic,s)}addJoinAndBufferLeftSide(t){const s=this.m_densifiedPoints[0];let e=Number.NaN,m=this.m_startAzimuth[0]-O;const r=this.m_endAzimuth[0]+O;let o=!1;if(!Number.isNaN(this.m_lastAzimuth)){this.m_lastAzimuth>=this.m_startAzimuth[0]?(e=this.m_lastAzimuth+O,m=e+Math.PI-(this.m_lastAzimuth-this.m_startAzimuth[0])):(e=this.m_lastAzimuth+O,m=e+Math.PI-(A-(this.m_startAzimuth[0]-this.m_lastAzimuth))),o=!(this.m_lastAzimuth>=this.m_startAzimuth[0]&&this.m_lastAzimuth-this.m_startAzimuth[0]<=Math.PI)&&!(this.m_lastAzimuth<this.m_startAzimuth[0]&&this.m_startAzimuth[0]-this.m_lastAzimuth>=Math.PI);let i=!1;if(Math.abs(m-e)<=.5*this.m_bufferer.m_cornerStep&&(o||(i=!0)),i){if(t.removePointFromPath(0,t.getPointCount()-1),!this.m_bRunningInGnomonic){const n=new y;n.setCoordsPoint2D(t.getXY(t.getPointCount()-1)),n.scale(this.m_bufferer.m_rpu),n.x-this.m_currentBufferedDelta<-Math.PI?this.m_currentBufferedDelta-=A:n.x-this.m_currentBufferedDelta>Math.PI&&(this.m_currentBufferedDelta+=A)}m=.5*(m+e)}else if(o){const n=new y;n.setCoordsPoint2D(s),n.scale(1/this.m_bufferer.m_rpu),t.insertPoint2D(0,-1,n)}else L(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_densifiedPoints[0],e,m,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,t)}this.m_startAzimuth[0]!==this.m_lastAzimuth&&this.m_numWinds++,lt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_bufferer.m_curveType,this.m_densifiedPoints,m,r,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,t),this.m_lastAzimuth=this.m_endAzimuth[0]}}class ae extends kt{constructor(t,s){super(t.m_progressTracker),this.m_pointIndex=-1,this.m_bufferer=t,this.m_multiPoint=s,this.m_bNeedsSimplify=!1;const e=new M;this.m_multiPoint.queryEnvelope(e);const m=e.getCenter(),r=m.clone();r.scale(this.m_bufferer.m_rpu),this.m_gnomonic=V(this.m_bufferer.m_gcs,m),this.m_gnomonicCenterRad=r.clone(),this.m_minGnomonicRadius=it(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,r,75/180*Math.PI)}next(){if(this.m_bNeedsSimplify=!1,++this.m_pointIndex===this.m_multiPoint.getPointCount())return null;const t=this.m_multiPoint.getXY(this.m_pointIndex);t.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic=this.isPointBufferInCurrentGnomonic(t),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(t));const s=new T,e=this.m_bufferer.bufferPoint2D(t,this.m_bRunningInGnomonic,s);return this.m_bNeedsSimplify=e,s}isPointBufferInCurrentGnomonic(t){return this.m_gnomonic!==null&&Nt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(t){const s=new y,e=new y,m=[0];return me(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,s,e,m)?(this.m_gnomonicCenterRad.setCoordsPoint2D(e),this.m_minGnomonicRadius=m[0],this.m_gnomonic=V(this.m_bufferer.m_gcs,s),!0):(this.m_gnomonic=null,!1)}}class _e{getOperatorType(){return 10110}supportsCurves(){return!0}accelerateGeometry(t,s,e){return!1}canAccelerateGeometry(t){return!1}executeMany(t,s,e,m,r,o,i,n){if(i){const u=new Dt(t,s,e,m,r,!1,o,n);return new J().executeMany(u,s,n)}return new Dt(t,s,e,m,r,!1,o,n)}execute(t,s,e,m,r,o,i){const n=new Et([t]),u=[m],a=this.executeMany(n,s,e,u,r,!1,o,i).next();return a||zt("geodesic buffer null output"),a}}class Dt extends Rt{constructor(t,s,e,m,r,o,i,n){super(),this.m_currentUnionEnvelope2D=new M,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=n,o&&Xt(""),s||ct(""),s.getCoordinateSystemType()===0&&ct(""),this.m_inputGeoms=t,this.m_spatialReference=s,this.m_curveType=e,this.m_distances=m,this.m_convergenceOffset=r,this.m_bOutlineOnly=o,this.m_bUnion=i}next(){let t;for(;t=this.m_inputGeoms.next();)return It(t),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.geodesicBuffer(t,this.m_distances[this.m_dindex]);return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}geodesicBuffer(t,s){return ie(t,this.m_spatialReference,this.m_curveType,s,this.m_convergenceOffset,this.m_progressTracker)}}export{_e as OperatorGeodesicBuffer};
