import{hl as c,_ as s,hm as _,hn as l}from"./index-c2b82012.js";import{s as f}from"./SimpleGeometryCursor-e3941f41.js";let n;function m(){return!!n&&c()}async function d(){if(!m()){const[t,r]=await Promise.all([s(()=>import("./OperatorGeodesicBuffer-a56b8722.js"),["assets/OperatorGeodesicBuffer-a56b8722.js","assets/SimpleGeometryCursor-e3941f41.js","assets/OperatorProject-1ae2812c.js","assets/index-c2b82012.js","assets/index-c76e6b87.css","assets/GeometryCleaner-DVgW95-D-f2147f71.js"]),s(()=>import("./OperatorProject-1ae2812c.js").then(e=>e.bC),["assets/OperatorProject-1ae2812c.js","assets/SimpleGeometryCursor-e3941f41.js","assets/index-c2b82012.js","assets/index-c76e6b87.css"]).then(e=>e.a8).then(({injectPe:e})=>e),_()]);n=new t.OperatorGeodesicBuffer,r(l)}}function v(t,r,e,o,i){return n.execute(t,r,e,o,i,!1,null)}function P(t,r,e,o,i,u){const a=n.executeMany(new f(t),r,e,o,i,!1,u,null);return Array.from(a)}function x(){return n.supportsCurves()}const E={geodesic:0,loxodrome:1,"great-elliptic":2,"normal-section":3,"shape-preserving":4};export{x as a,v as c,E as e,P as i,m as s,d as u};
