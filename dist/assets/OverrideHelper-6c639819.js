import{$ as M,s as C,gr as I,gs as y,gt as g,a8 as b,gu as x,gv as O,gw as h,gx as k,gy as S,gz as N,gA as P}from"./index-02eff6e6.js";import{B as w,H as $,D as T,C as G}from"./quantizationUtils-75dcba1a.js";function E(c,e,r,s,a){if(c==null)return null;const t=c.references("geometry")&&a?A(e,s,a):e,o=c.repurposeFeature(t);try{return c.evaluate({...r,$feature:o},c.services)}catch(i){return M.getLogger("esri.views.2d.support.arcadeOnDemand").warn("Feature arcade evaluation failed:",i),null}}const u=new Map;function A(c,e,r){const{transform:s,hasZ:a,hasM:t}=r;u.has(e)||u.set(e,L(e));const o=u.get(e)(c.geometry,s,a,t);return{...c,geometry:o}}function L(c){const e={};switch(c){case"esriGeometryPoint":return(r,s,a,t)=>G(s,e,r,a,t);case"esriGeometryPolygon":return(r,s,a,t)=>T(s,e,r,a,t);case"esriGeometryPolyline":return(r,s,a,t)=>$(s,e,r,a,t);case"esriGeometryMultipoint":return(r,s,a,t)=>w(s,e,r,a,t);default:return M.getLogger("esri.views.2d.support.arcadeOnDemand").error(new C("mapview-arcade",`Unable to handle geometryType: ${c}`)),r=>r}}const D=c=>{if(!c)return[0,0,0,0];const{r:e,g:r,b:s,a}=c;return[e,r,s,255*a]};class n{static findApplicableOverrides(e,r,s){if(e&&r){if(e.primitiveName){let a=!1;for(const t of s)if(t.primitiveName===e.primitiveName){a=!0;break}if(!a)for(const t of r)t.primitiveName===e.primitiveName&&s.push(t)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const a of e.effects)n.findApplicableOverrides(a,r,s);if(e.symbolLayers)for(const a of e.symbolLayers)n.findApplicableOverrides(a,r,s);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(e.effects)for(const a of e.effects)n.findApplicableOverrides(a,r,s);if(e.markerPlacement&&n.findApplicableOverrides(e.markerPlacement,r,s),e.type==="CIMVectorMarker"){if(e.markerGraphics)for(const a of e.markerGraphics)n.findApplicableOverrides(a,r,s),n.findApplicableOverrides(a.symbol,r,s)}else e.type==="CIMCharacterMarker"?n.findApplicableOverrides(e.symbol,r,s):e.type==="CIMHatchFill"?n.findApplicableOverrides(e.lineSymbol,r,s):e.type==="CIMPictureMarker"&&n.findApplicableOverrides(e.animatedSymbolProperties,r,s)}}}static findEffectOverrides(e,r){if(!e)return null;if(e.type==="CIMGeometricEffectDashes"&&I(e),!r||!e.primitiveName)return{type:"cim-effect-param",effect:e,overrides:[]};const s=y(e),a=e.primitiveName,t=[];for(const o of r)o.primitiveName===a&&t.push(y(o));return{type:"cim-effect-param",effect:s,overrides:g(t)}}static async resolveSymbolOverrides(e,r,s,a,t,o,i){if(!(e!=null&&e.symbol))return null;let{symbol:p,primitiveOverrides:l}=e;const v=!!l;if(!v&&!a)return p;p=b(p),l=b(l);let d=!0;if(r||(r={attributes:{}},d=!1),v){if(d||(l=l.filter(f=>{var m;return!((m=f.valueExpressionInfo)!=null&&m.expression.includes("$feature"))})),i||(l=l.filter(f=>{var m;return!((m=f.valueExpressionInfo)!=null&&m.expression.includes("$view"))})),l.length>0){const f={spatialReference:s,fields:x(r.attributes),geometryType:t};await n.createRenderExpressions(l,f),n.evaluateOverrides(l,r,t??"esriGeometryPoint",o,i)}n.applyOverrides(p,l)}return a&&n.applyDictionaryTextOverrides(p,r,a,null),p}static async createRenderExpressions(e,r){const s=[];for(const a of e){const t=a.valueExpressionInfo;if(!t||n._expressionToRenderExpression.has(t.expression))continue;const o=O(t.expression,r.spatialReference,r.fields);s.push(o),o.then(i=>n._expressionToRenderExpression.set(t.expression,i))}s.length>0&&await Promise.all(s)}static evaluateOverrides(e,r,s,a,t){const o={$view:{scale:t==null?void 0:t.scale}};for(const i of e){i.value&&typeof i.value=="object"&&h(i.value)&&(i.propertyName==="Color"||i.propertyName==="StrokeColor")&&(i.value=D(i.value));const p=i.valueExpressionInfo;if(!p)continue;const l=n._expressionToRenderExpression.get(p.expression);l&&(i.value=E(l,r,o,s,a))}}static applyDictionaryTextOverrides(e,r,s,a,t="Normal"){if(e!=null&&e.type)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const o=e.symbolLayers;if(!o)return;for(const i of o)i&&i.type==="CIMVectorMarker"&&n.applyDictionaryTextOverrides(i,r,s,a,e.type==="CIMTextSymbol"?e.textCase:t)}break;case"CIMVectorMarker":{const o=e.markerGraphics;if(!o)return;for(const i of o)i&&n.applyDictionaryTextOverrides(i,r,s,a)}break;case"CIMMarkerGraphic":{const o=e.textString;if(o&&o.includes("[")){const i=k(o,s);e.textString=S(r,i,a,t)}}}}static applyOverrides(e,r,s,a){if(e.primitiveName){for(const t of r)if(t.primitiveName===e.primitiveName){const o=N(t.propertyName);if(a&&a.push({cim:e,nocapPropertyName:o,value:e[o]}),s){let i=!1;for(const p of s)p.primitiveName===e.primitiveName&&(i=!0);i||s.push(t)}t.value!=null&&(e[o]=t.value)}}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const t of e.effects)n.applyOverrides(t,r,s,a);if(e.symbolLayers)for(const t of e.symbolLayers)n.applyOverrides(t,r,s,a);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(e.effects)for(const t of e.effects)n.applyOverrides(t,r,s,a);if(e.type==="CIMVectorMarker"&&e.markerGraphics)for(const t of e.markerGraphics)n.applyOverrides(t,r,s,a),n.applyOverrides(t.symbol,r,s,a)}}static restoreOverrides(e){for(const r of e)r.cim[r.nocapPropertyName]=r.value}static buildOverrideKey(e){let r="";for(const s of e)s.value!==void 0&&(r+=`${s.primitiveName}${s.propertyName}${JSON.stringify(s.value)}`);return r}static toValue(e,r){if(e==="DashTemplate")return r.split(" ").map(s=>Number(s));if(e==="Color"){const s=new P(r).toRgba();return s[3]*=255,s}return r}}n._expressionToRenderExpression=new Map;export{n as OverrideHelper};
