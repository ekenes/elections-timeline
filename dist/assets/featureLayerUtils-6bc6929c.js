import{g as Y,Z as _,p as f,k,l as P,a as b,u as v,f as u,h as z,s as p,i as I}from"./index-7df220b7.js";import{i as $}from"./originUtils-cfe4feaf.js";import{I as B,y as E,w as N,b as G,u as j,v as V,l as x,d as Z,m as S}from"./utils-fe39127a.js";import{r as q}from"./fetchService-2b769461.js";import{o as L}from"./jsonContext-28b69568.js";import"./multiOriginJSONSupportUtils-c978f4c3.js";import"./saveAPIKeyUtils-9cce0528.js";import"./requestPresets-5f49bbe6.js";const d="Feature Service",h="feature-layer-utils",C=`${h}-save`,H=`${h}-save-as`,m=`${h}-saveall`,y=`${h}-saveall-as`;function w(a){return{isValid:z(a)&&(a.type!=="feature"||!a.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function g(a){const e=[],r=[];for(const{layer:l,layerJSON:o}of a)l.isTable?r.push(o):e.push(o);return{layers:e,tables:r}}function O(a){return g([a])}async function J(a,e){return/\/\d+\/?$/.test(a.url)?O(e[0]):M(e,a)}async function M(a,e){if(!e)return g(a);const{layer:{url:r,customParameters:l,apiKey:o}}=a[0];let t=await e.fetchData("json");(t==null?void 0:t.layers)!=null&&t.tables!=null||(t=await Q(t,{url:r??"",customParameters:l,apiKey:o},a.map(s=>s.layer.layerId)));for(const s of a)R(s.layer,s.layerJSON,t);return t}async function Q(a,e,r){a||(a={}),a.layers||(a.layers=[]),a.tables||(a.tables=[]);const{url:l,customParameters:o,apiKey:t}=e,{serviceJSON:s,layersJSON:n}=await q(l,{customParameters:o,apiKey:t}),i=T(a.layers,s.layers,r),c=T(a.tables,s.tables,r);a.layers=i.itemResources,a.tables=c.itemResources;const F=[...i.added,...c.added],K=n?[...n.layers,...n.tables]:[];return await W(a,F,l,K),a}function T(a,e,r){const l=Y(a,e,(t,s)=>t.id===s.id);a=a.filter(t=>!l.removed.some(s=>s.id===t.id));const o=l.added.map(({id:t})=>({id:t}));return o.forEach(({id:t})=>{a.push({id:t})}),{itemResources:a,added:o.filter(({id:t})=>!r.includes(t))}}async function W(a,e,r,l){const o=e.map(({id:t})=>new _({url:r,layerId:t,sourceJSON:l.find(({id:s})=>s===t)}));await Promise.allSettled(o.map(t=>t.load())),o.forEach(t=>{const{layerId:s,loaded:n,defaultPopupTemplate:i}=t;!n||i==null||R(t,{id:s,popupInfo:i.toJSON()},a)})}function R(a,e,r){a.isTable?A(r.tables,e):A(r.layers,e)}function A(a,e){const r=a.findIndex(({id:l})=>l===e.id);r===-1?a.push(e):a[r]=e}function D(a,e){if(!a.length)throw new p(`${e}:missing-parameters`,"'layers' array should contain at least one feature layer")}function X(a,e){const r=a.map(l=>l.portalItem.id);if(new Set(r).size>1)throw new p(`${e}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function U(a,e){const r=a.map(l=>l.layerId);if(new Set(r).size!==r.length)throw new p(`${e}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function aa(a){D(a,m),await Promise.all(a.map(e=>e.load()));for(const e of a)x(e,m,w),Z({layer:e,itemType:d,errorNamePrefix:m});X(a,m),U(a,m)}async function ea(a,e){const{url:r,layerId:l,title:o,fullExtent:t,isTable:s}=a,n=f(r);e.url=(n==null?void 0:n.serverType)==="FeatureServer"?r:`${r}/${l}`,e.title||(e.title=o),e.extent=null,s||t==null||(e.extent=await P(t)),b(e,u.METADATA),b(e,u.MULTI_LAYER),I(e,u.SINGLE_LAYER),s&&I(e,u.TABLE)}function ta(a,e){for(const t of a){const s=t.parsedUrl.path,n=f(s);if(!(n==null?void 0:n.url.path))throw new p(`${e}:invalid-parameters`,S(t,`has unsupported url pattern: ${s}`),{layer:t});const c=n==null?void 0:n.serverType;if(c!=="FeatureServer"&&c!=="MapServer")throw new p(`${e}:invalid-parameters`,S(t,`has unsupported server type: ${c}`),{layer:t});if(c==="MapServer"&&a.length>1)throw new p(`${e}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const r=f(a[0].parsedUrl.path),l=r==null?void 0:r.url.path;if(!a.every(t=>{const s=f(t.parsedUrl.path);return(s==null?void 0:s.url.path)===l}))throw new p(`${e}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function ra(a){D(a,y),await Promise.all(a.map(e=>e.load()));for(const e of a)x(e,y,w);ta(a,y),U(a,y)}async function sa(a,e){let r=0,l=0;for(const{isTable:s}of e)s?l++:r++;const o=e[0].parsedUrl.path,t=f(o);if(a.url=(t==null?void 0:t.serverType)==="FeatureServer"?t.url.path:o,a.title||(a.title=t.title),a.extent=null,r>0){const s=e.map(n=>n.fullExtent).filter(k).reduce((n,i)=>n.clone().union(i));s&&(a.extent=await P(s))}b(a,u.METADATA),v(a,u.MULTI_LAYER,e.length>1),v(a,u.SINGLE_LAYER,e.length===1),v(a,u.TABLE,l>0&&r===0),N(a)}async function ya(a,e){return B({layer:a,itemType:d,validateLayer:w,createItemData:(r,l)=>J(l,[r]),errorNamePrefix:C},e)}async function fa(a,e){await aa(a);const r=a[0].portalItem,l=L(r),o=await Promise.all(a.map(s=>E(s,l,e))),t=await J(r,a.map((s,n)=>({layer:s,layerJSON:o[n]})));return N(r),await r.update({data:t}),await Promise.all(a.slice(1).map(s=>s.portalItem.reload())),$(l),r.clone()}async function da(a,e,r){return G({layer:a,itemType:d,validateLayer:w,createItemData:(l,o)=>Promise.resolve(O(l)),errorNamePrefix:H,newItem:e,setItemProperties:ea},r)}async function ha(a,e,r){await ra(a);const l=j({itemType:d,errorNamePrefix:y,newItem:e}),o=L(l),t=await Promise.all(a.map(n=>E(n,o,r))),s=await M(a.map((n,i)=>({layer:n,layerJSON:t[i]})));await sa(l,a),await V(l,s,r);for(const n of a)n.portalItem=l.clone();return $(o),l}export{ya as save,fa as saveAll,ha as saveAllAs,da as saveAs};
