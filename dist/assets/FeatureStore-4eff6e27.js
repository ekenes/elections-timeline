import{bc as Y,fh as A,k as V,gv as k,m as F,s as v,Y as M}from"./index-a1a1303e.js";import{y as C}from"./featureConversionUtils-b3c52e9d.js";import{o as w}from"./BoundsStore-50c74c8f.js";import{a as x,t as $}from"./OptimizedGeometry-33b2eb0d.js";import{Z}from"./timeSupport-9e42c29a.js";function T(r,t){return r?t?4:3:t?3:2}function j(r,t,e,s,n){if(t==null||!t.lengths.length)return null;const a=(n==null?void 0:n.originPosition)==="upperLeft"?-1:1;r.lengths.length&&(r.lengths.length=0),r.coords.length&&(r.coords.length=0);const o=r.coords,h=[],u=e?[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY]:[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY],{lengths:I,coords:g}=t,b=T(e,s);let y=0;for(const i of I){const d=G(u,g,y,i,e,s,a);d&&h.push(d),y+=i*b}if(h.sort((i,d)=>{let f=a*i[2]-a*d[2];return f===0&&e&&(f=i[4]-d[4]),f}),h.length){let i=6*h[0][2];o[0]=h[0][0]/i,o[1]=h[0][1]/i,e&&(i=6*h[0][4],o[2]=i!==0?h[0][3]/i:0),(o[0]<u[0]||o[0]>u[1]||o[1]<u[2]||o[1]>u[3]||e&&(o[2]<u[4]||o[2]>u[5]))&&(o.length=0)}if(!o.length){const i=t.lengths[0]?O(g,0,I[0],e,s):null;if(!i)return null;o[0]=i[0],o[1]=i[1],e&&i.length>2&&(o[2]=i[2])}return r}function G(r,t,e,s,n,a,o=1){const h=T(n,a);let u=e,I=e+h,g=0,b=0,y=0,i=0,d=0;for(let E=0,N=s-1;E<N;E++,u+=h,I+=h){const c=t[u],_=t[u+1],l=t[u+2],m=t[I],p=t[I+1],S=t[I+2];let B=c*p-m*_;i+=B,g+=(c+m)*B,b+=(_+p)*B,n&&(B=c*S-m*l,y+=(l+S)*B,d+=B),c<r[0]&&(r[0]=c),c>r[1]&&(r[1]=c),_<r[2]&&(r[2]=_),_>r[3]&&(r[3]=_),n&&(l<r[4]&&(r[4]=l),l>r[5]&&(r[5]=l))}if(i*o>0&&(i*=-1),d*o>0&&(d*=-1),!i)return null;const f=[g,b,.5*i];return n&&(f[3]=y,f[4]=.5*d),f}function O(r,t,e,s,n){const a=T(s,n);let o=t,h=t+a,u=0,I=0,g=0,b=0;for(let y=0,i=e-1;y<i;y++,o+=a,h+=a){const d=r[o],f=r[o+1],E=r[o+2],N=r[h],c=r[h+1],_=r[h+2],l=s?L(d,f,E,N,c,_):P(d,f,N,c);if(l)if(u+=l,s){const m=q(d,f,E,N,c,_);I+=l*m[0],g+=l*m[1],b+=l*m[2]}else{const m=R(d,f,N,c);I+=l*m[0],g+=l*m[1]}}return u>0?s?[I/u,g/u,b/u]:[I/u,g/u]:e>0?s?[r[t],r[t+1],r[t+2]]:[r[t],r[t+1]]:null}function P(r,t,e,s){const n=e-r,a=s-t;return Math.sqrt(n*n+a*a)}function L(r,t,e,s,n,a){const o=s-r,h=n-t,u=a-e;return Math.sqrt(o*o+h*h+u*u)}function R(r,t,e,s){return[r+.5*(e-r),t+.5*(s-t)]}function q(r,t,e,s,n,a){return[r+.5*(s-r),t+.5*(n-t),e+.5*(a-e)]}const z={getObjectId:r=>r.objectId,getAttributes:r=>r.attributes,getAttribute:(r,t)=>r.attributes[t],cloneWithGeometry:(r,t)=>new x(t,r.attributes,null,r.objectId),getGeometry:r=>r.geometry,getCentroid:(r,t)=>(r.centroid==null&&(r.centroid=j(new $,r.geometry,t.hasZ,t.hasM)),r.centroid)},U=Y();class Q{constructor(t){this.geometryInfo=t,this._boundsStore=new w,this._featuresById=new Map,this._markedIds=new Set,this.events=new A,this.featureAdapter=z}get geometryType(){return this.geometryInfo.geometryType}get hasM(){return this.geometryInfo.hasM}get hasZ(){return this.geometryInfo.hasZ}get numFeatures(){return this._featuresById.size}get fullBounds(){return this._boundsStore.fullBounds}get storeStatistics(){let t=0;return this._featuresById.forEach(e=>{e.geometry!=null&&e.geometry.coords&&(t+=e.geometry.coords.length)}),{featureCount:this._featuresById.size,vertexCount:t/(this.hasZ?this.hasM?4:3:this.hasM?3:2)}}getFullExtent(t){if(this.fullBounds==null)return null;const[e,s,n,a]=this.fullBounds;return{xmin:e,ymin:s,xmax:n,ymax:a,spatialReference:Z(t)}}add(t){this._add(t),this._emitChanged()}addMany(t){for(const e of t)this._add(e);this._emitChanged()}upsertMany(t){const e=t.map(s=>this._upsert(s));return this._emitChanged(),e.filter(V)}clear(){this._featuresById.clear(),this._boundsStore.clear(),this._emitChanged()}removeById(t){const e=this._featuresById.get(t);return e?(this._remove(e),this._emitChanged(),e):null}removeManyById(t){this._boundsStore.invalidateIndex();for(const e of t){const s=this._featuresById.get(e);s&&this._remove(s)}this._emitChanged()}forEachBounds(t,e){for(const s of t){const n=this._boundsStore.get(s.objectId);n&&e(k(U,n))}}getFeature(t){return this._featuresById.get(t)}has(t){return this._featuresById.has(t)}forEach(t){this._featuresById.forEach(e=>t(e))}forEachInBounds(t,e){this._boundsStore.forEachInBounds(t,s=>{e(this._featuresById.get(s))})}startMarkingUsedFeatures(){this._boundsStore.invalidateIndex(),this._markedIds.clear()}sweep(){let t=!1;this._featuresById.forEach((e,s)=>{this._markedIds.has(s)||(t=!0,this._remove(e))}),this._markedIds.clear(),t&&this._emitChanged()}_emitChanged(){this.events.emit("changed",void 0)}_add(t){if(!t)return;const e=t.objectId;if(e==null)return void F.getLogger("esri.layers.graphics.data.FeatureStore").error(new v("featurestore:invalid-feature","feature id is missing",{feature:t}));const s=this._featuresById.get(e);let n;if(this._markedIds.add(e),s?(t.displayId=s.displayId,n=this._boundsStore.get(e),this._boundsStore.delete(e)):this.onFeatureAdd!=null&&this.onFeatureAdd(t),t.geometry==null||!t.geometry.coords||!t.geometry.coords.length)return this._boundsStore.set(e,null),void this._featuresById.set(e,t);n=C(n??M(),t.geometry,this.geometryInfo.hasZ,this.geometryInfo.hasM),n!=null&&this._boundsStore.set(e,n),this._featuresById.set(e,t)}_upsert(t){const e=t==null?void 0:t.objectId;if(e==null)return F.getLogger("esri.layers.graphics.data.FeatureStore").error(new v("featurestore:invalid-feature","feature id is missing",{feature:t})),null;const s=this._featuresById.get(e);if(!s)return this._add(t),t;this._markedIds.add(e);const{geometry:n,attributes:a}=t;for(const o in a)s.attributes[o]=a[o];return n&&(s.geometry=n,this._boundsStore.set(e,C(M(),n,this.geometryInfo.hasZ,this.geometryInfo.hasM)??null)),s}_remove(t){this.onFeatureRemove!=null&&this.onFeatureRemove(t);const e=t.objectId;return this._markedIds.delete(e),this._boundsStore.delete(e),this._featuresById.delete(e),t}}export{Q as f};
