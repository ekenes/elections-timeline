import{ii as St,ij as tt,ik as bt,il as Nt,im as f,S as Lt,g2 as Bt,io as S,ip as jt,hT as gt,aJ as d,iq as It,ir as zt,is as Vt,cx as Wt,hb as qt,n as h,q as C,t as Gt,aN as Ht,it as Ut,aL as yt,cw as b,iu as Dt,iv as mt,i9 as nt,iw as Yt,m as $t,eB as W,ix as rt,eo as et,en as ot,iy as kt,cg as Jt,iz as Kt,b$ as Qt,c0 as Xt,h8 as G,iA as ht,iB as at,iC as Zt,cC as tn,b1 as nn,iD as rn,iE as en,g7 as on,iF as an}from"./index-a1a1303e.js";import{e as At}from"./mat3f64-221ce671.js";import{e as v,o as z}from"./mat4f64-1413b4a7.js";import{c as O}from"./spatialReferenceEllipsoidUtils-4aec2543.js";import{m as sn,p as ln,t as it,o as cn}from"./MeshLocalVertexSpace-f05043d2.js";import{m as un}from"./MeshGeoreferencedRelativeVertexSpace-56e4cf03.js";import{v as Y,y as fn,x as pn}from"./quat-adc6cfb9.js";import{e as Q}from"./quatf64-3363c48e.js";import{n as M,s as Pt,r as w}from"./vec32-3dafe0f1.js";import{i as F,T}from"./BufferView-605f1da3.js";function Ft(t,n,r){const e=Math.sin(t),o=Math.cos(t),a=Math.sin(n),s=Math.cos(n),i=r;return i[0]=-e,i[4]=-a*o,i[8]=s*o,i[12]=0,i[1]=o,i[5]=-a*e,i[9]=s*e,i[13]=0,i[2]=0,i[6]=s,i[10]=a,i[14]=0,i[3]=0,i[7]=0,i[11]=0,i[15]=1,i}function gn(t,n,r){return Ft(t,n,r),St(r,r),r}function q(t,n,r,e){if(t==null||e==null)return!1;const o=tt(t,bt),a=tt(e,Nt);if(o===a&&!st(a)&&(o!==f.UNKNOWN||Lt(t,e)))return Bt(r,n),!0;if(st(a)){const s=S[o][f.LON_LAT],i=S[f.LON_LAT][a];return s!=null&&i!=null&&(s(n,0,A,0),i(A,0,P,0),Ft(N*A[0],N*A[1],r),r[12]=P[0],r[13]=P[1],r[14]=P[2],!0)}if((a===f.WEB_MERCATOR||a===f.PLATE_CARREE)&&(o===f.WGS84||o===f.CGCS2000&&a===f.PLATE_CARREE||o===f.SPHERICAL_ECEF||o===f.WEB_MERCATOR)){const s=S[o][f.LON_LAT],i=S[f.LON_LAT][a];return s!=null&&i!=null&&(s(n,0,A,0),i(A,0,P,0),o===f.SPHERICAL_ECEF?gn(N*A[0],N*A[1],r):jt(r),r[12]=P[0],r[13]=P[1],r[14]=P[2],!0)}return!1}function st(t){return t===f.SPHERICAL_ECEF||t===f.SPHERICAL_MARS_PCPF||t===f.SPHERICAL_MOON_PCPF}const N=gt(1),A=d(),P=d();function _(t=Tt){return[t[0],t[1],t[2],t[3]]}function V(t,n,r=_()){return Wt(r,t),r[3]=n,r}function lt(t,n,r=_()){return Y(L,t,k(t)),Y(ct,n,k(n)),fn(L,ct,L),mn(r,qt(pn(r,L)))}function Jn(t,n,r,e=_()){return V(It,t,B),V(zt,n,ut),V(Vt,r,ft),lt(B,ut,B),lt(B,ft,e),e}function Kn(t){return t}function yn(t){return t[3]}function k(t){return gt(t[3])}function mn(t,n){return t[3]=n,t}const Tt=[0,0,1,0],L=Q(),ct=Q();_();const B=_(),ut=_(),ft=_();var J;let m=J=class extends Ht{constructor(t){super(t),this.translation=d(),this.rotationAxis=Ut(Tt),this.rotationAngle=0,this.scale=yt(1,1,1)}get rotation(){return V(this.rotationAxis,this.rotationAngle)}set rotation(t){this.rotationAxis=b(t),this.rotationAngle=yn(t)}get localMatrix(){const t=v();return Y(pt,this.rotation,k(this.rotation)),Dt(t,pt,this.translation,this.scale),t}get localMatrixInverse(){return mt(v(),this.localMatrix)}applyLocal(t,n){return nt(n,t,this.localMatrix)}applyLocalInverse(t,n){return nt(n,t,this.localMatrixInverse)}equals(t){return this===t||t!=null&&Yt(this.localMatrix,t.localMatrix)}clone(){const t={translation:b(this.translation),rotationAxis:b(this.rotationAxis),rotationAngle:this.rotationAngle,scale:b(this.scale)};return new J(t)}};h([C({type:[Number],nonNullable:!0,json:{write:!0}})],m.prototype,"translation",void 0),h([C({type:[Number],nonNullable:!0,json:{write:!0}})],m.prototype,"rotationAxis",void 0),h([C({type:Number,nonNullable:!0,json:{write:!0}})],m.prototype,"rotationAngle",void 0),h([C({type:[Number],nonNullable:!0,json:{write:!0}})],m.prototype,"scale",void 0),h([C()],m.prototype,"rotation",null),h([C()],m.prototype,"localMatrix",null),h([C()],m.prototype,"localMatrixInverse",null),m=J=h([Gt("esri.geometry.support.MeshTransform")],m);const pt=Q(),$n=m;function Ct(t,n){return t.isGeographic||t.isWebMercator&&((n==null?void 0:n.geographic)??!0)}function Qn(t,n,r){const e=!t.isGeoreferenced;(r==null?void 0:r.geographic)!=null&&r.geographic!==e&&$t.getLogger(n).warnOnce(`Specifying the 'geographic' parameter (${r.geographic}) for a Mesh vertex space of type "${t.type}" is not supported. This parameter will be ignored.`)}const H=$t.getLogger("esri.geometry.support.meshUtils.normalProjection");function hn(t,n,r,e,o){return D(e)?(U($.TO_PCPF,F.fromTypedArray(t),T.fromTypedArray(n),T.fromTypedArray(r),e,F.fromTypedArray(o)),o):(H.error("Cannot convert spatial reference to PCPF"),o)}function An(t,n,r,e,o){return D(e)?(U($.FROM_PCPF,F.fromTypedArray(t),T.fromTypedArray(n),T.fromTypedArray(r),e,F.fromTypedArray(o)),o):(H.error("Cannot convert to spatial reference from PCPF"),o)}function Pn(t,n,r){return W(t,n,0,r,O(n),0,t.length/3),r}function Fn(t,n,r){return W(t,O(r),0,n,r,0,t.length/3),n}function Tn(t,n,r){return G(u,r),M(n,t,u),ht(u)||Pt(n,n),n}function Cn(t,n,r){if(G(u,r),M(n,t,u,4),ht(u)||Pt(n,n,4),t!==n)for(let e=3;e<t.length;e+=4)n[e]=t[e];return n}function Rn(t,n,r,e,o){if(!D(e))return H.error("Cannot convert spatial reference to PCPF"),o;U($.TO_PCPF,F.fromTypedArray(t,4*Float32Array.BYTES_PER_ELEMENT),T.fromTypedArray(n),T.fromTypedArray(r),e,F.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT));for(let a=3;a<t.length;a+=4)o[a]=t[a];return o}function _n(t,n,r,e,o){if(!D(e))return H.error("Cannot convert to spatial reference from PCPF"),o;U($.FROM_PCPF,F.fromTypedArray(t,16),T.fromTypedArray(n),T.fromTypedArray(r),e,F.fromTypedArray(o,16));for(let a=3;a<t.length;a+=4)o[a]=t[a];return o}function U(t,n,r,e,o,a){if(!n)return;const s=r.count,i=O(o);if(Rt(o))for(let l=0;l<s;l++)e.getVec(l,j),n.getVec(l,y),q(i,j,I,i),rt(u,I),t===$.FROM_PCPF&&et(u,u),ot(y,y,u),a.setVec(l,y);else for(let l=0;l<s;l++){e.getVec(l,j),n.getVec(l,y),q(i,j,I,i),rt(u,I);const c=kt(r.get(l,1));let p=Math.cos(c);t===$.TO_PCPF&&(p=1/p),u[0]*=p,u[1]*=p,u[2]*=p,u[3]*=p,u[4]*=p,u[5]*=p,t===$.FROM_PCPF&&et(u,u),ot(y,y,u),Jt(y,y),a.setVec(l,y)}return a}function D(t){return Rt(t)||Mn(t)}function Rt(t){return t.isWGS84||Kt(t)||Qt(t)||Xt(t)}function Mn(t){return t.isWebMercator}var $;(function(t){t[t.TO_PCPF=0]="TO_PCPF",t[t.FROM_PCPF=1]="FROM_PCPF"})($||($={}));const j=d(),y=d(),I=v(),u=At();function X(t,n,r){return Ct(n.spatialReference,r)?dn(t,n,r):wn(t,n,r)}function _t(t,n=z){const{position:r,normal:e,tangent:o}=t;return{position:w(new Float64Array(r.length),r,n),normal:e!=null?Tn(e,new Float32Array(e.length),n):null,tangent:o!=null?Cn(o,new Float32Array(o.length),n):null}}function Mt(t,n,r,e){const{position:o,normal:a,tangent:s}=t;return n.isRelative?X(_t(t,r==null?void 0:r.localMatrix),n.getOriginPoint(e),{geographic:!n.isGeoreferenced}):{position:o,normal:a,tangent:s}}function xn(t,n,r){if(r!=null&&r.useTransform){const{position:e,normal:o,tangent:a}=t,{x:s,y:i,z:l}=n,c=yt(s,i,l??0);return{vertexAttributes:{position:e,normal:o,tangent:a},vertexSpace:r.geographic??1?new sn({origin:c}):new un({origin:c}),transform:new $n}}return{vertexAttributes:X(t,n,r),vertexSpace:new ln,transform:null}}function K(t,n,r){return Ct(n.spatialReference,r)?Nn(t,n,r):xt(t,n,r)}function En(t,n,r,e,o){if(!n.isRelative)return K(t,e,o);const{spatialReference:a}=e,s=Mt(t,n,r,a);return e.equals(n.getOriginPoint(a))?xt(s,e,o):K(s,e,o)}function vn({positions:t,transform:n,vertexSpace:r,inSpatialReference:e,outSpatialReference:o,outPositions:a,local:s}){const i=r.isRelative?r.origin:at,l=r.isRelative?(n==null?void 0:n.localMatrix)??z:z;if(r.isGeoreferenced){const g=a??it(t.length);if(Zt(l,z)?cn(g,t):w(g,t,l),!tn(i,at)){const[wt,dt,Ot]=i;for(let E=0;E<g.length;E+=3)g[E]+=wt,g[E+1]+=dt,g[E+2]+=Ot}return W(g,e,0,g,o,0,g.length/3),g}const c=O(e),p=!s&&nn(e,c)?c:e;q(e,i,R,p),rn(R,R,l);const x=a??it(t.length);return w(x,t,R),W(x,p,0,x,o,0,x.length/3),x}function wn(t,n,r){const e=new Float64Array(t.position.length),o=t.position,a=n.x,s=n.y,i=n.z??0,l=Z(r?r.unit:null,n.spatialReference);for(let c=0;c<o.length;c+=3)e[c]=o[c]*l+a,e[c+1]=o[c+1]*l+s,e[c+2]=o[c+2]*l+i;return{position:e,normal:t.normal,tangent:t.tangent}}function dn(t,n,r){const e=n.spatialReference,o=Et(n,r,R),a=new Float64Array(t.position.length),s=On(t.position,o,e,a),i=G(vt,o);return{position:s,normal:Sn(s,a,t.normal,i,e),tangent:bn(s,a,t.tangent,i,e)}}function On(t,n,r,e){w(e,t,n);const o=new Float64Array(t.length);return Fn(e,o,r)}function Sn(t,n,r,e,o){if(r==null)return null;const a=new Float32Array(r.length);return M(a,r,e),An(a,t,n,o,a),a}function bn(t,n,r,e,o){if(r==null)return null;const a=new Float32Array(r.length);M(a,r,e,4);for(let s=3;s<a.length;s+=4)a[s]=r[s];return _n(a,t,n,o,a),a}function xt(t,n,r){const e=new Float64Array(t.position.length),o=t.position,a=n.x,s=n.y,i=n.z??0,l=Z(r?r.unit:null,n.spatialReference);for(let c=0;c<o.length;c+=3)e[c]=(o[c]-a)/l,e[c+1]=(o[c+1]-s)/l,e[c+2]=(o[c+2]-i)/l;return{position:e,normal:t.normal,tangent:t.tangent}}function Nn(t,n,r){const e=n.spatialReference;Et(n,r,R);const o=mt(In,R),a=new Float64Array(t.position.length),s=Ln(t.position,e,o,a),i=G(vt,o);return{position:s,normal:Bn(t.normal,t.position,a,e,i),tangent:jn(t.tangent,t.position,a,e,i)}}function Et(t,n,r){q(t.spatialReference,[t.x,t.y,t.z??0],r,O(t.spatialReference));const e=Z(n?n.unit:null,t.spatialReference);return en(r,r,[e,e,e]),r}function Ln(t,n,r,e){const o=Pn(t,n,e),a=new Float64Array(o.length);return w(a,o,r),a}function Bn(t,n,r,e,o){if(t==null)return null;const a=hn(t,n,r,e,new Float32Array(t.length));return M(a,a,o),a}function jn(t,n,r,e,o){if(t==null)return null;const a=Rn(t,n,r,e,new Float32Array(t.length));return M(a,a,o,4),a}function Z(t,n){if(t==null)return 1;const r=on(n);return 1/an(r,"meters",t)}const R=v(),In=v(),vt=At(),Xn=Object.freeze(Object.defineProperty({__proto__:null,applyTransform:_t,georeference:X,georeferenceApplyTransform:Mt,georeferenceByTransform:xn,project:vn,ungeoreference:K,ungeoreferenceByTransform:En},Symbol.toStringTag,{value:"Module"}));export{xn as B,K as D,En as E,vn as I,q as L,$n as N,Fn as O,Rn as R,X as U,_t as V,An as _,_ as a,lt as b,Xn as c,Jn as g,Pn as h,hn as j,Kn as l,Qn as o,Mt as q,Ct as r,_n as v,k as w};
