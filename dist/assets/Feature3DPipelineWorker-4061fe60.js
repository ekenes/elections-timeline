import{C as w,D as H,J,cd as _e,id as kt,dI as Qt,ab as me,c$ as yt,ay as ze,lV as Yt,je as Xt,nG as Jt,nH as Zt,nI as Kt,dC as er,s as tr,bt as R,eZ as rr,nJ as sr,dn as ir,nK as nr,lt as z,cg as je,fV as or,nL as ke,nM as ar,nN as lr,nO as bt,db as He,g9 as _t,d3 as cr,c1 as Qe,fY as Me,nP as dr,mK as ur,fU as hr,hL as Ye,lI as fr,_ as pr,dr as wt,g0 as xe,dg as ue,bs as Xe,df as mr,dY as N,dX as U,gv as ne,j4 as gr,aE as vr,d_ as Oe,aG as yr,nQ as br,ds as _r,bp as wr,gr as xt,bu as xr,nR as Je,aP as Or,gu as Cr,a5 as Sr,iU as Ar,g as Ze,fy as Ke,bI as Tr,bJ as $r}from"./index-b8632133.js";import{$ as Pr}from"./QueryEngine-d7982a4c.js";import{h as Er,E as Ot}from"./PooledRBush-8246720e.js";import{n as Ir}from"./timeSupport-2b5ecd18.js";import{n as Rr}from"./projectVectorToVector-8b29a070.js";import{n as Dr,A as M,N as zr,s as Ct,d as Mr,f as Gr,e as Q,o as X,a as Br,p as Fr,w as St,b as At,c as Lr,g as jr,h as Tt,i as Hr,P as Vr,l as Nr,j as Ur,k as Wr,m as et,t as qr,q as B,r as kr,u as re,v as Qr,x as Yr,O as Xr,y as Jr,z as Zr,B as Kr,C as T,D as es,E as ts,F as rs,G as ss,H as is,I as ns,J as os,K as tt,L as as,W as ls,M as cs,Q as ds,R as us,S as hs,T as fs,U as ps,V as ms,X as rt,Y as st,Z as gs}from"./DefaultTechniqueConfiguration-17653ab9.js";import{t as $t}from"./glUtil-4eacbecb.js";import{n as S,a as Ce}from"./NormalAttribute.glsl-15306aae.js";import{a as vs}from"./basicInterfaces-d9412f98.js";import{t as ys}from"./NestedMap-b667f687.js";import{e as Z}from"./mat4f64-9a8384aa.js";import{s as he}from"./Util-95651989.js";import{o as bs}from"./floatRGBA-fce694d8.js";import{e as Pt}from"./mat3f64-e19cdcb8.js";import{x as _s}from"./BufferView-a598cb7c.js";import{H as ws}from"./InterleavedLayout-3c3c5582.js";import{o as g}from"./interfaces-3cb63efc.js";import{e as m}from"./VertexAttribute-ace1421c.js";import{c as xs,T as Os,a as Cs,d as Ss}from"./renderState-9bda431a.js";import{t as As}from"./Indices-3253d062.js";import{t as F}from"./Attribute-422e3b38.js";function Ts(r){r.code.add(g`const float MAX_RGBA_FLOAT =
255.0 / 256.0 +
255.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 / 256.0;
const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);
vec4 float2rgba(const float value) {
float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);
vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);
const float toU8AsFloat = 1.0 / 255.0;
return fixedPointU8 * toU8AsFloat;
}
const vec4 RGBA_2_FLOAT_FACTORS = vec4(
255.0 / (256.0),
255.0 / (256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0 * 256.0)
);
float rgba2float(vec4 rgba) {
return dot(rgba, RGBA_2_FLOAT_FACTORS);
}`)}let L=class extends _e{constructor(e){super(e),this._removing=0,this._tiles=new kt}destroy(){for(const e of this._tiles.values())e.remove();this._tiles.clear()}get updating(){if(this._removing>0)return!0;for(const e of this._tiles.values())if(!e.finished)return!0;return!1}async onTileTreeChange(e){const{added:t,removed:s}=e,i=this._tiles;for(const n of s){const o=i.get(n);o!=null&&(o.abort(),i.delete(n))}for(const n of t)i.has(n.id)||i.set(n.id,Qt(o=>this._addTile(n,o)));await this._removeTiles(s)}async _addTile(e,t){const s=await this.addTile(e,t);return me(t),s}async _removeTiles(e){this._removing++,await this.removeTiles(e),this._removing--}};w([H()],L.prototype,"updating",null),w([H({constructOnly:!0})],L.prototype,"addTile",void 0),w([H({constructOnly:!0})],L.prototype,"removeTiles",void 0),w([H()],L.prototype,"_removing",void 0),L=w([J("esri.views.3d.layers.graphics.pipeline.Tile3DManager")],L);let Ge=class{constructor(e,t){this._index=e,this._view=t}getObjectId(){return this._view.getObjectId(this._index)}getAttribute(e){return this._view.getAttribute(this._index,e)}getAttributeAsTimestamp(e){return this._view.getAttributeAsTimestamp(this._index,e)}getAttributes(){return this._view.getAttributes(this._index)}getOptimizedGeometry(){return this._view.getOptimizedGeometry(this._index)}getCentroid(e){return this._view.getCentroid(this._index,e)}getBounds(){return this._view.getBounds(this._index)}getBoundingBox(){return this._view.getBoundingBox(this._index)}cloneWithGeometry(e){return new $s(this._index,this._view,e)}},$s=class extends Ge{constructor(e,t,s){super(e,t),this._geometryOverride=s}getOptimizedGeometry(){return this._geometryOverride}getCentroid(e){return Ir(new ze,this._geometryOverride,e.hasZ,e.hasM)}},Ps=class{constructor(){this._storedTiles=new Map,this._pageBounds=new Map,this.events=new yt,this.featureAdapter=Be.shared}addTile(e){this._storedTiles.set(e.descriptor.id,e);for(const t of e.pages)this._addPage(t)}removeTile(e){const t=this._storedTiles,s=t.get(e);if(s!=null){t.delete(e);for(const i of s.pages)this._removePage(i)}}_addPage(e){const{featureCount:t}=e;if(t===0)return;const s=new Er(9,n=>e.getBounds(n)),i=new Array;for(let n=0;n<t;++n)i[n]=n;s.load(i),this._pageBounds.set(e,s),this.events.emit("changed")}_removePage(e){this._pageBounds.delete(e),this.events.emit("changed")}clear(){this._storedTiles.clear(),this._pageBounds.clear(),this.events.emit("changed")}forEach(e){for(const[t,s]of this._pageBounds)s.all(i=>e(new Ge(i,t)))}forEachInBounds(e,t){ee.minX=e[0],ee.minY=e[1],ee.maxX=e[2],ee.maxY=e[3];for(const[s,i]of this._pageBounds)i.search(ee,n=>t(new Ge(n,s)))}forEachBounds(e,t){for(const s of e)t(s.getBoundingBox())}getFullExtent(e){let t=1/0,s=1/0,i=-1/0,n=-1/0;for(const o of this._pageBounds.values()){const{minX:l,minY:a,maxX:u,maxY:d}=o.toJSON();t=Math.min(t,l),s=Math.min(s,a),i=Math.min(i,u),n=Math.min(n,d)}return{xmin:t,ymin:s,xmax:i,ymax:n,spatialReference:e}}},Be=class{getObjectId(e){return e.getObjectId()}getAttribute(e,t){return e.getAttribute(t)}getAttributeAsTimestamp(e,t){return e.getAttributeAsTimestamp(t)}getAttributes(e){return e.getAttributes()}getGeometry(e){return e.getOptimizedGeometry()}getCentroid(e,t){return e.getCentroid(t)}cloneWithGeometry(e,t){return e.cloneWithGeometry(t)}};Be.shared=new Be;const ee=new Ot;let Es=class{constructor(e,t){this.descriptor=e,this.pages=t}},Is=class{constructor(e){const t=new Yt(new Uint8Array(e),new DataView(e));this._reader=t,this._index=Rs(t)}get featureCount(){return this._index.featureIndices.length}get exceededTransferLimit(){return this._index.exceededTransferLimit}getObjectId(e){return this.getAttribute(e,this._index.objectIdFieldName)}getAttribute(e,t){var a;const{_index:{fieldsIndex:s,attributeIndices:i}}=this,n=(a=s.get(t))==null?void 0:a.index;if(n==null)return;const o=i[e*s.fields.length+n],l=this._reader;return l.move(o),Se(l)}getAttributeAsTimestamp(e,t){const s=this.getAttribute(e,t);return typeof s=="string"?new Date(s).getTime():typeof s=="number"||s==null?s:null}getAttributes(e){const{_index:{fieldsIndex:t,attributeIndices:s}}=this,i=e*t.fields.length,n=this._reader,o={};for(const l of t.fields){const a=s[i+l.index];n.move(a),o[l.name]=Se(n)}return o}getCoordinates(e,t,s=0){const i=this._reader,{transform:n,featureIndices:o}=this._index,{scale:l,translate:a}=n;i.move(o[e]),this._readCoordinates(l,a,t,s)}getOptimizedGeometry(e){const t=R();return this.getCoordinates(e,t),new ze([],t)}getCentroid(e,{hasZ:t,hasM:s}){this.getCoordinates(e,W);const[i,n,o]=W,l=[i,n];return t&&(l[3]=o),s&&(l[t?4:3]=0),new ze([],l)}getBounds(e){this.getCoordinates(e,W);const[t,s]=W,i=new Ot;return i.minX=t,i.minY=s,i.maxX=t,i.maxY=s,i}getBoundingBox(e){this.getCoordinates(e,W);const[t,s,i]=W;return Xt(t,s,i,t,s,i)}readAllObjectIds(e,t=0){const s=this._reader,{_index:i,featureCount:n}=this,{objectIdFieldName:o,attributeIndices:l,fieldsIndex:a}=i,u=a.get(o).index,d=a.fields.length;for(let c=0;c<n;++c){const f=l[c*d+u];s.move(f),e[t++]=Se(s)}return t}readAllCoordinates(e,t=0){const s=this._reader,{transform:i,featureIndices:n}=this._index,{scale:o,translate:l}=i;for(const a of n)s.move(a),t=this._readCoordinates(o,l,e,t);return t}_readCoordinates([e,t,s],[i,n,o],l,a){const c=this._reader,f=c.getLength(),h=c.pos()+f;for(;c.pos()<h&&c.next();)switch(c.tag()){case 2:{const p=c.getLength(),y=c.pos()+p;for(;c.pos()<y&&c.next();)c.tag()===3?(c.getUInt32(),l[a++]=i+e*c.getSInt64(),l[a++]=n+t*c.getSInt64(),l[a++]=o+s*c.getSInt64()):c.skip();break}default:c.skip()}return a}};function Rs(r){for(;r.next();){if(r.tag()===2)return Ds(r.getMessage());r.skip()}ge()}function Ds(r){for(;r.next();){if(r.tag()===1)return zs(r.getMessage());r.skip()}ge()}function zs(r){let d,c,f=!1,h=!1,p=0;const y=new Array,O=new Array,_=new Array;for(;r.next();)switch(r.tag()){case 1:c=r.getString();break;case 7:r.getEnum()!==0&&ge();break;case 9:f=r.getBool()??!1;break;case 12:d=Zt(r.processMessage(Kt));break;case 13:{const v=r.processMessage(Jt);v.index=p++,y.push(v);break}case 15:{O.push(r.pos());const v=r.getUInt32(),b=r.pos()+v;for(;r.pos()<b&&r.next();)r.tag()===1&&_.push(r.pos()),r.skip();break}case 10:h=r.getBool()??!1;break;default:r.skip()}const x=new er(y);return d!=null&&h&&c!=null&&x.has(c)||ge(),{transform:d,exceededTransferLimit:f,fieldsIndex:x,objectIdFieldName:c,featureIndices:O,attributeIndices:_}}function ge(){const r=new tr("pbf-parsing-failed","Error while parsing PBF",new Error);throw console.error(r),r}function Se(r){const d=r.getLength(),c=r.pos()+d;for(;r.pos()<c&&r.next();)switch(r.tag()){case 1:return r.getString();case 2:return r.getFloat();case 3:return r.getDouble();case 4:return r.getSInt32();case 5:return r.getUInt32();case 6:return r.getInt64();case 7:return r.getUInt64();case 8:return r.getSInt64();case 9:return r.getBool();default:return r.skip(),null}return null}const W=R(),Ms=8e3,Gs=4,Bs=4;let Fs=class{constructor(e,t,s,i,n){this.spatialReference=e,this.url=s,this.objectIdField=i,this.capabilities=n;const{supportsMaxRecordCountFactor:o,maxRecordCount:l}=this.capabilities.query,a=l??8e3,u=(o?Gs:null)??1,d=a*u;this._pageSize=Math.min(Ms,d);const c=t.clone();c.cacheHint=!0,c.resultType="tile",c.outSpatialReference=e,c.returnGeometry=!0,c.returnZ=!0,c.maxRecordCountFactor=u,c.num=a,c.outFields=[i],this._baseQuery=c}async fetch(e,t){const{spatialReference:s}=this,i=rr(e.extent,s),n=this._baseQuery.clone();n.geometry=i;const o=new Array;let l=0,a=!1,u=1;for(;!a;){const d=[];for(let f=0;f<u;++f)d.push(this._fetchPage(n,l++,t));const c=await Promise.all(d);me(t);for(const f of c){const h=f.featureCount!==0;a||(a=!f.exceededTransferLimit||!h),h&&o.push(f)}u=Math.min(u+1,Bs)}return new Es(e,o)}async _fetchPage(e,t,s){const i=e.clone();i.start=t*this._pageSize;const n=(await sr(this.url,i,{signal:s})).data;return me(s),new Is(n)}},Ls=class{constructor(e,t,s){this.objectIdField=e,this.spatialReference=t,this.renderSpatialReference=s}process(e){const{pages:t}=e;if(t.length===0)return null;const s=t.reduce((p,{featureCount:y})=>p+y,0);if(s===0)return null;const i=this.spatialReference,n=this.renderSpatialReference,o=new Float64Array(3*s),l=new Uint32Array(s);let a=0,u=0;for(const p of t)a=p.readAllCoordinates(o,a),u=p.readAllObjectIds(l,u);const d=new Float64Array(o.length);if(!ir(o,i,0,d,n,0,s))throw new Error("Failed to project coordinates");const c=e.descriptor.extent,f=nr(c),h=R();return Rr([f[0],f[1],0],i,h,n),{numFeatures:s,coordinates:d,objectIds:l,tileId:e.descriptor.id,localOrigin:h}}};var it;(function(r){r[r.Left=0]="Left",r[r.Center=1]="Center",r[r.Right=2]="Right"})(it||(it={}));const js=Object.freeze({"bottom-left":z(0,0),bottom:z(.5,0),"bottom-right":z(1,0),left:z(0,.5),center:z(.5,.5),right:z(1,.5),"top-left":z(0,1),top:z(.5,1),"top-right":z(1,1)}),Hs={required:[]};S.Depth;let Vs=class extends _e{consumes(){return Hs}get usedMemory(){return 0}get isDecoration(){return!1}get running(){return!1}modify(e){}get numGeometries(){return 0}get hasOccludees(){return!1}get hasEmissions(){return!1}forEachGeometry(e){}queryRenderOccludedState(e){return!1}},Et=class extends Vs{constructor(){super(...arguments),this.drapedPriority=0}},It=class{constructor(e,t){this._material=e,this._repository=t,this._map=new Map}dispose(){this._map.forEach((e,t)=>{e!=null&&this._repository.release(this._material,t)})}load(e,t,s){const i=this._material.produces.get(t);if(!(i!=null&&i(s)))return null;this._map.has(s)||this._map.set(s,this._repository.acquire(this._material,t,s));const n=this._map.get(s);if(n!=null){if(n.ensureResources(e)===vs.LOADED)return n;this._repository.requestRender()}return null}},Rt=class extends Dr{constructor(e=R()){super(),this.origin=e}get slicePlaneLocalOrigin(){return this.origin}};var nt,j;(function(r){r[r.ADD=0]="ADD",r[r.UPDATE=1]="UPDATE",r[r.REMOVE=2]="REMOVE"})(nt||(nt={})),function(r){r[r.NONE=0]="NONE",r[r.VISIBILITY=1]="VISIBILITY",r[r.GEOMETRY=2]="GEOMETRY",r[r.TRANSFORMATION=4]="TRANSFORMATION",r[r.HIGHLIGHT=8]="HIGHLIGHT",r[r.OCCLUDEE=16]="OCCLUDEE"}(j||(j={}));let Ve=class{constructor(e=0,t=0){this.from=e,this.to=t}get numElements(){return this.to-this.from}};function ot(r){const e=new Map;r.forAll(s=>e.set(s.from,s));let t=!0;for(;t;){t=!1;for(let s=0;s<r.length;++s){const i=r.data[s],n=e.get(i.to);if(!n)return;i.to=n.to,e.delete(n.from),r.removeUnordered(n),t=!0}}}let at=class extends Ve{constructor(e,t,s){super(t,s),this.geometry=e}get isVisible(){return this.geometry.visible}get hasHighlights(){return this.isVisible&&this.geometry.hasHighlights}foreachHighlightGroup(e){this.isVisible&&this.geometry.foreachHighlightGroup(e)}get hasOccludees(){return this.geometry.occludees!=null}},Ns=class{constructor(){this.first=0,this.count=0}},Us=class{constructor(){this._numElements=0,this._instances=new Map,this.holes=new je({allocator:e=>e||new Ve,deallocator:null}),this.hasHiddenInstances=!1,this.hasOccludees=!1,this.drawCommandsDirty=!0,this.highlightGroups=new Set,this.drawCommandsDefault=oe(),this.drawCommandsHighlights=new Map,this.drawCommandsOccludees=oe(),this.drawCommandsShadowHighlightRest=oe()}get numElements(){return this._numElements}get instances(){return this._instances}get hasHighlights(){return this.highlightGroups.size>0}resetInstanceSummary(){this.hasHiddenInstances=!1,this.hasOccludees=!1,this.highlightGroups.clear()}updateIfDrawCommandsDirty(e){if(this.drawCommandsDirty){this.resetInstanceSummary();for(const t of this.instances.values())this.updateDrawState(t);this.updateDrawCommands(e)}}addInstance(e,t){this.deleteInstance(e),this._instances.set(e,t),this._numElements+=t.numElements}deleteInstance(e){const t=this._instances.get(e);t&&(this._numElements-=t.numElements,this._instances.delete(e))}updateInstance(e,t,s){const i=this._instances.get(e);i&&(this._numElements-=i.numElements,i.from=t,i.to=s,this._numElements+=i.numElements)}updateDrawState(e){e.isVisible?(e.foreachHighlightGroup(t=>this.highlightGroups.add(t)),e.hasOccludees&&(this.hasOccludees=!0)):this.hasHiddenInstances=!0}updateDrawCommands(e){if(this.drawCommandsDefault.clear(),this.drawCommandsHighlights.clear(),this.drawCommandsOccludees.clear(),this.drawCommandsShadowHighlightRest.clear(),this.drawCommandsDirty=!1,this._instances.size===0)return;if(!this.needsMultipleCommands()){const i=this.drawCommandsDefault.pushNew(),n=this.holes.front();return this.vao!=null&&this.holes.length===1&&n.to===Math.floor(this.vao.byteSize/e)?(i.first=0,void(i.count=n.from)):(i.first=1/0,i.count=0,this._instances.forEach(o=>{i.first=Math.min(i.first,o.from),i.count=Math.max(i.count,o.to)}),void(i.count-=i.first))}const t=Array.from(this._instances.values()).sort((i,n)=>i.from===n.from?i.to-n.to:i.from-n.from),{drawCommandsHighlights:s}=this;for(const i of t)i.isVisible&&(Ae(i.hasOccludees?this.drawCommandsOccludees:this.drawCommandsDefault,i),i.hasHighlights?i.foreachHighlightGroup(n=>{let o=s.get(n);o||(o=oe(),s.set(n,o)),Ae(o,i)}):Ae(this.drawCommandsShadowHighlightRest,i))}needsMultipleCommands(){return this.hasOccludees||this.hasHighlights||this.hasHiddenInstances}};function Ws(r){return r.vao!=null}function oe(){return new je({allocator:r=>r||new Ns,deallocator:r=>r})}function Ae(r,e){const t=r.back();if(t==null){const s=r.pushNew();return s.first=e.from,void(s.count=e.numElements)}if(qs(t,e)){const s=e.from-t.first+e.numElements;t.count=s}else{const s=r.pushNew();s.first=e.from,s.count=e.numElements}}function qs(r,e){return r.first+r.count>=e.from}let ks=class{constructor(e){this.origin=e,this.buffers=new Array}dispose(){this.buffers.forEach(e=>e.vao.dispose()),this.buffers.length=0}findBuffer(e){return this.buffers.find(t=>t.instances.has(e))}},Te=class extends Et{get _hasAnyHighlight(){return this._highlightGroups.size>0}constructor(e){super(e),this._dataByOrigin=new Map,this._drawParameters=new Rt,this._highlightGroups=new Set,this.drapedPriority=0,this._produces=new Map,this._hasOccludees=!1}destroy(){this._glMaterials=or(this._glMaterials),this._dataByOrigin.forEach(e=>e.dispose()),this._dataByOrigin.clear(),this._vaoCache=null}initialize(){this.material.produces.forEach((e,t)=>{this._produces.set(t,s=>!(this._dataByOrigin.size===0||!(s!==S.Highlight&&s!==S.ShadowHighlight||this._hasAnyHighlight))&&e(s))})}initializeRenderContext(e,t){this._glMaterials=new It(this.material,t??e.materials),this._bufferWriter=this.material.createBufferWriter(),this._vaoCache=e.renderContext.rctx.getVaoCache(this.material.vertexAttributeLocations,$t(this._bufferWriter.vertexBufferLayout))}uninitializeRenderContext(){}get produces(){return this._produces}get hasOccludees(){return this._hasOccludees}get hasEmissions(){return this.material.hasEmissions}get isDecoration(){return this.material.parameters.isDecoration}queryRenderOccludedState(e){return this.material.queryRenderOccludedState(e)}get numGeometries(){let e=0;return this._dataByOrigin.forEach(t=>e+=t.buffers.reduce((s,i)=>s+i.instances.size,0)),e}get usedMemory(){let e=0;return this._dataByOrigin.forEach(t=>e+=t.buffers.reduce((s,i)=>s+i.vao.usedMemory,0)),e}forEachGeometry(e){this._dataByOrigin.forEach(t=>t.buffers.forEach(s=>s.instances.forEach(({geometry:i})=>e(i))))}modify(e){this._updateGeometries(e.updates),this._addAndRemoveGeometries(e.adds,e.removes),this._updateDrawCommands()}_updateGeometries(e){const t=this._bufferWriter;if(t==null)return;const s=t.vertexBufferLayout.stride/4;for(const i of e){const n=i.renderGeometry,o=this._dataByOrigin.get(n.localOrigin.id),l=o==null?void 0:o.findBuffer(n.id);if(l==null)return;const a=l.instances.get(n.id);if(i.updateType&(j.GEOMETRY|j.TRANSFORMATION)){const u=ce(t.elementCount(a.geometry.geometry.attributes)*s),d=t.vertexBufferLayout.createView(u.buffer);this._writeGeometry(n,d,0),l.vao.vertexBuffers.get("geometry").setSubData(u,a.from*s,0,a.numElements*s)}i.updateType&(j.HIGHLIGHT|j.OCCLUDEE|j.VISIBILITY)&&(l.drawCommandsDirty=!0)}}_computeDeltas(e,t){const s=new ys;for(const i of e){const n=i.localOrigin;if(n==null)continue;let o=s.get(n.id,null);o==null&&(o=new lt(n.vec3),s.set(n.id,null,o)),o.changes.push(i)}for(const i of t){const n=i.localOrigin;if(n==null)continue;const o=this._dataByOrigin.get(n.id),l=o==null?void 0:o.findBuffer(i.id);if(l==null)continue;let a=s.get(n.id,l);a==null&&(a=new lt(n.vec3),s.set(n.id,l,a)),a.changes.push(i)}return s}_addAndRemoveGeometries(e,t){if(this._bufferWriter==null||this._vaoCache==null)return;const{_bufferWriter:s,_dataByOrigin:i}=this,n=s.vertexBufferLayout.stride/4,o=this._computeDeltas(e,t);o.forEach((l,a)=>{const u=l.get(null),d=u!=null?u.changes:[];o.delete(a,null);let c=i.get(a);if(l.forEach((f,h)=>{if(o.delete(a,h),h==null)return void he(!1,"No VAO for removed geometries");if(h.instances.size===f.changes.length)return this._vaoCache.deleteVao(h.vao),ke(c.buffers,h),void(c.buffers.length===0&&d.length===0&&i.delete(a));const p=h.numElements,y=h.vao.byteSize/4,O=d.reduce((b,C)=>b+s.elementCount(C.geometry.attributes),0),_=f.changes.reduce((b,C)=>b+s.elementCount(C.geometry.attributes),0),x=Math.min((p+O-_)*n,le),v=x>y;x>ve&&x<y/2?(f.changes.forEach(({id:b})=>h.deleteInstance(b)),h.instances.forEach(({geometry:b})=>d.push(b)),this._vaoCache.deleteVao(h.vao),ke(c.buffers,h)):v?this._applyAndRebuild(h,d,f):this._applyRemoves(h,f)}),d.length>0)for(c==null&&(c=new ks(u.origin),i.set(a,c)),c.buffers.forEach(f=>this._applyAdds(f,d));d.length>0;)c.buffers.push(this._applyAndRebuild(new Us,d,null))})}_updateDrawCommands(){this._highlightGroups.clear(),this._hasOccludees=!1,this._dataByOrigin.forEach(e=>{e.buffers.forEach(t=>{t.updateIfDrawCommandsDirty(this._bufferWriter.vertexBufferLayout.stride),t.hasHighlights&&ar(this._highlightGroups,t.highlightGroups),this._hasOccludees=this._hasOccludees||t.hasOccludees})})}_applyAndRebuild(e,t,s){if(s!=null)for(const p of s.changes)e.deleteInstance(p.id);const i=this._bufferWriter,n=i.vertexBufferLayout.stride,o=n/4,l=Math.floor(le/o);let a=e.numElements;for(;t.length>0;){const p=t.pop(),y=i.elementCount(p.geometry.attributes);if(a+y>l&&a>0){t.push(p);break}a+=y;const O=new at(p,0,0);he(e.instances.get(p.id)==null),e.addInstance(p.id,O)}const u=a*o,d=ce(u),c=i.vertexBufferLayout.createView(d.buffer);let f=0;e.resetInstanceSummary(),e.instances.forEach((p,y)=>{this._writeGeometry(p.geometry,c,f);const O=f;f+=i.elementCount(p.geometry.geometry.attributes),e.updateInstance(y,O,f),e.updateDrawState(p)}),this._vaoCache.deleteVao(e.vao),e.vao=this._vaoCache.newVao(Fe(u)),e.vao.vertexBuffers.get("geometry").setSubData(d,0,0,f*o),e.holes.clear();const h=e.holes.pushNew();return h.from=f,h.to=Math.floor(e.vao.byteSize/n),e.updateDrawCommands(n),e}_applyRemoves(e,t){if(t.changes.length===0||this._bufferWriter==null)return;for(const l of t.changes){const a=l.id,u=e.instances.get(a);if(!u)continue;e.deleteInstance(a);const d=D.back();if(d){if(d.to===u.from){d.to=u.to;continue}if(d.from===u.to){d.from=u.from;continue}}const c=D.pushNew();c.from=u.from,c.to=u.to}ot(D);const s=this._bufferWriter.vertexBufferLayout.stride/4,i=D.reduce((l,a)=>Math.max(l,a.numElements),0)*s,n=ce(i);n.fill(0,0,i);const o=e.vao.vertexBuffers.get("geometry");D.forAll(l=>o.setSubData(n,l.from*s,0,l.numElements*s)),e.holes.pushArray(D.data,D.length),D.forAll((l,a)=>D.data[a]=null),D.clear(),e.drawCommandsDirty=!0}_applyAdds(e,t){if(t.length===0||this._bufferWriter==null)return;if(!Ws(e))return void this._applyAndRebuild(e,t,null);const s=this._bufferWriter,i=s.vertexBufferLayout.stride/4,n=e.numElements,o=t.reduce((_,x)=>_+s.elementCount(x.geometry.attributes),0),l=Math.min((n+o)*i,le),a=4*l;if(e.vao.byteSize<Fe(le-ve)&&a>e.vao.byteSize)return void this._applyAndRebuild(e,t,null);ot(e.holes);const u=new Array;for(const _ of t){const x=s.elementCount(_.geometry.attributes),v=Qs(e.holes,x);u.push(v)}const d=e.vao.vertexBuffers.get("geometry");let c=0,f=0,h=0;const p=ce(l),y=s.vertexBufferLayout.createView(p.buffer);t.forEach((_,x)=>{const v=u[x];if(v==null)return;if(h!==v){const E=h-f;E>0&&d.setSubData(p,f*i,0,E*i),f=v,c=0}const b=s.elementCount(_.geometry.attributes);this._writeGeometry(_,y,c),c+=b,h=v+b;const C=new at(_,v,v+b);he(e.instances.get(_.id)==null),e.addInstance(_.id,C),e.drawCommandsDirty=!0});const O=h-f;O>0&&d.setSubData(p,f*i,0,O*i),lr(t,(_,x)=>u[x]==null)}_writeGeometry(e,t,s){this._bufferWriter!=null&&(bt(q,e.transformation),q[12]-=e.localOrigin.vec3[0],q[13]-=e.localOrigin.vec3[1],q[14]-=e.localOrigin.vec3[2],He(ae,q),_t(ae,ae),this._bufferWriter.write(q,ae,e.geometry.attributes,e.geometry.objectAndLayerIdColor,t,s))}updateAnimation(e){return this.material.update(e)}prepareTechnique(e){var c;if(!this.material.shouldRender(e))return null;const{output:t,bind:s}=e,i=this.material.produces.get(s.slot);if(!(i!=null&&i(t)))return null;const{highlightGroup:n}=s,o=t===S.ShadowHighlight,l=t===S.Highlight,a=l||o;if(a&&(this._highlightGroups.size===0||l&&n&&!this._highlightGroups.has(n)))return null;const u=t===S.ShadowExcludeHighlight,d=!(a||u);for(const f of this._dataByOrigin.values())for(const h of f.buffers){if(a&&(h.highlightGroups.size===0||n&&!h.highlightGroups.has(n)))continue;const p=o?h.drawCommandsHighlights.size>0:a?n?h.drawCommandsHighlights.get(n):h.drawCommandsHighlights.size>0:((c=(u&&h.needsMultipleCommands()?h.drawCommandsShadowHighlightRest:h.drawCommandsDefault)||null)==null?void 0:c.length)??!1,y=d&&h.drawCommandsOccludees||null;if(p||y!=null&&y.length){const O=this._glMaterials.load(e.rctx,s.slot,t),_=O!=null?O.beginSlot(s):null;if(_!=null)return _}}return null}render(e,t){const{output:s,bind:i}=e,n=s===S.Highlight,o=s===S.ShadowHighlight,l=n||o,a=s===S.ShadowExcludeHighlight,u=!(l||a),d=i.slot===M.OCCLUDER_MATERIAL||i.slot===M.TRANSPARENT_OCCLUDER_MATERIAL?i.slot:null,{rctx:c}=e;c.runAppleAmdDriverHelper(),c.bindTechnique(t,i,this.material.parameters);const{highlightGroup:f}=i;if(s!==S.Highlight||f)for(const h of this._dataByOrigin.values())for(const p of h.buffers){if(n&&(!p.hasHighlights||!p.drawCommandsHighlights.has(f))||o&&!p.hasHighlights)continue;const y=()=>{const b=[];for(const C of p.drawCommandsHighlights.values())b.push(C);return b},O=l&&!o?p.drawCommandsHighlights.get(f)??null:null,_=o?y():l?O?[O]:dt:(a&&p.needsMultipleCommands()?[p.drawCommandsShadowHighlightRest]:[p.drawCommandsDefault])||dt,x=_.some(b=>b.length>0),v=u&&p.drawCommandsOccludees||null;if(x||v!=null&&v.length){const b=t.program;if(this._drawParameters.origin=h.origin,b.bindDraw(i,this.material.parameters,this._drawParameters),t.ensureAttributeLocations(p.vao),c.bindVAO(p.vao),x)for(const C of _)c.setPipelineState(t.getPipeline(!1,d)),C.forAll(E=>c.drawArrays(t.primitiveType,E.first,E.count));v!=null&&v.length&&(c.setPipelineState(t.getPipeline(!0,d)),v.forAll(C=>c.drawArrays(t.primitiveType,C.first,C.count)))}}}get test(){}};w([H({constructOnly:!0})],Te.prototype,"material",void 0),Te=w([J("esri.views.3d.webgl-engine.materials.renderers.MergedRenderer")],Te);let lt=class{constructor(e){this.origin=e,this.changes=new Array}};function Qs(r,e){let t;if(!r.some(i=>!(i.numElements<e)&&(t=i,!0)))return null;const s=t.from;return t.from+=e,t.from>=t.to&&r.removeUnordered(t),s}const q=Z(),ae=Z(),D=new je({allocator:r=>r||new Ve,deallocator:null}),ve=65536,$e=4*ve,ct=1024,Dt=16777216,le=Dt/4;let Pe=new Float32Array(ve);function ce(r){return Pe.length<r&&(Pe=new Float32Array(r)),Pe}function Fe(r){const e=4*r;return e<=ct?ct:e<$e?cr(e):Math.max(Math.min(Math.ceil(1.5*e/$e)*$e,Dt),e)}const dt=[];let fe=class extends Et{constructor(e){super(e),this._hasHighlights=!1,this._glMaterials=null,this._produces=new Map,this._renderGeometries=new Map,this._vaoCache=null,this._drawParameters=new Rt,this._bufferWriter=null}get produces(){return this._produces}initialize(){this._bufferWriter=this.material.createBufferWriter(),this.material.produces.forEach((e,t)=>{this._produces.set(t,s=>!!(s!==S.Highlight&&s!==S.ShadowHighlight||this._hasHighlights)&&e(s))})}destroy(){this._glMaterials.dispose();const e=this._renderGeometries.keys();for(const t of e)this.destroyRenderGeometry(t)}prepareTechnique(e){const t=this.material;if(!t.shouldRender(e))return null;const{output:s,bind:i}=e,n=t.produces.get(i.slot);if(!(n!=null&&n(s))||(s===S.Highlight||s===S.ShadowHighlight)&&!this._hasHighlights)return null;const o=this._glMaterials.load(e.rctx,i.slot,s);return o==null?void 0:o.beginSlot(i)}render(e,t){const s=this._renderGeometries;if(s.size===0)return;const{bind:i}=e,n=i.slot===M.OCCLUDER_MATERIAL||i.slot===M.TRANSPARENT_OCCLUDER_MATERIAL?i.slot:null,o=e.rctx;o.runAppleAmdDriverHelper(),o.bindTechnique(t,i,this.material.parameters);const l=t.program;for(const[a,u]of s)this._drawParameters.origin=u.localOrigin,l.bindDraw(i,this.material.parameters,this._drawParameters),t.ensureAttributeLocations(u.vao),o.bindVAO(u.vao),o.setPipelineState(t.getPipeline(!1,n)),o.drawArrays(t.primitiveType,0,u.numElements)}initializeRenderContext(e,t){this._glMaterials=new It(this.material,e.materials);const s=e.renderContext.rctx.getVaoCache(this.material.vertexAttributeLocations,$t(this._bufferWriter.vertexBufferLayout));this._vaoCache=s}uninitializeRenderContext(){}createRenderGeometry(e,t,s){this.destroyRenderGeometry(e);const i=this._bufferWriter.vertexBufferLayout.stride/4,n=this._vaoCache.newVao(Fe(t.data.length));n.vertexBuffers.get("geometry").setSubData(t.data,0,0,t.numElements*i);const o={localOrigin:s,vao:n,numElements:t.numElements};return this._renderGeometries.set(e,o),o}destroyRenderGeometry(e){const t=this._renderGeometries.get(e);t!=null&&(this._vaoCache.deleteVao(t.vao),this._renderGeometries.delete(e))}};w([H({constructOnly:!0})],fe.prototype,"material",void 0),fe=w([J("esri.views.3d.layers.graphics.pipeline.rendering.SimpleMaterialRenderer")],fe);const zt=128,Y=.5;function Ys(r){return r==="cross"||r==="x"}function Xs(r,e=zt,t=e*Y,s=0){const i=Js(r,e,t,s);return new zr(i,{mipmap:!1,wrap:{s:Qe.CLAMP_TO_EDGE,t:Qe.CLAMP_TO_EDGE},width:e,height:e,components:4,noUnpackFlip:!0,reloadable:!0})}function Js(r,e=zt,t=e*Y,s=0){switch(r){case"circle":default:return Zs(e,t);case"square":return Ks(e,t);case"cross":return ti(e,t,s);case"x":return ri(e,t,s);case"kite":return ei(e,t);case"triangle":return si(e,t);case"arrow":return ii(e,t)}}function Zs(r,e){const t=r/2-.5;return se(r,Bt(t,t,e/2))}function Ks(r,e){return Mt(r,e,!1)}function ei(r,e){return Mt(r,e,!0)}function ti(r,e,t=0){return Gt(r,e,!1,t)}function ri(r,e,t=0){return Gt(r,e,!0,t)}function si(r,e){return se(r,Ft(r/2,e,e/2))}function ii(r,e){const t=e,s=e/2,i=r/2,n=.8*t,o=Bt(i,(r-e)/2-n,Math.sqrt(n*n+s*s)),l=Ft(i,t,s);return se(r,(a,u)=>Math.max(l(a,u),-o(a,u)))}function Mt(r,e,t){return t&&(e/=Math.SQRT2),se(r,(s,i)=>{let n=s-.5*r+.25,o=.5*r-i-.75;if(t){const l=(n+o)/Math.SQRT2;o=(o-n)/Math.SQRT2,n=l}return Math.max(Math.abs(n),Math.abs(o))-.5*e})}function Gt(r,e,t,s=0){e-=s,t&&(e*=Math.SQRT2);const i=.5*e;return se(r,(n,o)=>{let l,a=n-.5*r,u=.5*r-o-1;if(t){const d=(a+u)/Math.SQRT2;u=(u-a)/Math.SQRT2,a=d}return a=Math.abs(a),u=Math.abs(u),l=a>u?a>i?Math.sqrt((a-i)*(a-i)+u*u):u:u>i?Math.sqrt(a*a+(u-i)*(u-i)):a,l-=s/2,l})}function Bt(r,e,t){return(s,i)=>{const n=s-r,o=i-e;return Math.sqrt(n*n+o*o)-t}}function Ft(r,e,t){const s=Math.sqrt(e*e+t*t);return(i,n)=>{const o=Math.abs(i-r)-t,l=n-r+e/2+.75,a=(e*o+t*l)/s,u=-l;return Math.max(a,u)}}function se(r,e){const t=new Uint8Array(4*r*r);for(let s=0;s<r;s++)for(let i=0;i<r;i++){const n=i+r*s;let o=e(i,s);o=o/r+.5,bs(o,t,4*n)}return t}function ni(r){return r instanceof Float32Array&&r.length>=16}function oi(r){return Array.isArray(r)&&r.length>=16}function ai(r){return ni(r)||oi(r)}const Lt=.5;function li(r,e){r.include(Ct),r.attributes.add(m.POSITION,"vec3"),r.attributes.add(m.NORMAL,"vec3"),r.attributes.add(m.CENTEROFFSETANDDISTANCE,"vec4");const t=r.vertex;Mr(t,e),Gr(t,e),t.uniforms.add(new Q("viewport",(s,i)=>i.camera.fullViewport),new X("polygonOffset",s=>s.shaderPolygonOffset),new X("cameraGroundRelative",(s,i)=>i.camera.aboveGround?1:-1)),e.hasVerticalOffset&&Br(t),t.constants.add("smallOffsetAngle","float",.984807753012208),t.code.add(g`struct ProjectHUDAux {
vec3 posModel;
vec3 posView;
vec3 vnormal;
float distanceToCamera;
float absCosAngle;
};`),t.code.add(g`
    float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {
      float pointGroundSign = ${e.multipassEnabled?g.float(0):g`sign(pointGroundDistance)`};
      if (pointGroundSign == 0.0) {
        pointGroundSign = cameraGroundRelative;
      }

      // cameraGroundRelative is -1 if camera is below ground, 1 if above ground
      // groundRelative is 1 if both camera and symbol are on the same side of the ground, -1 otherwise
      float groundRelative = cameraGroundRelative * pointGroundSign;

      // view angle dependent part of polygon offset emulation: we take the absolute value because the sign that is
      // dropped is instead introduced using the ground-relative position of the symbol and the camera
      if (polygonOffset > .0) {
        float cosAlpha = clamp(absCosAngle, 0.01, 1.0);
        float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;
        float factor = (1.0 - tanAlpha / viewport[2]);

        // same side of the terrain
        if (groundRelative > 0.0) {
          posView *= factor;
        }
        // opposite sides of the terrain
        else {
          posView /= factor;
        }
      }

      return groundRelative;
    }
  `),e.draped&&!e.hasVerticalOffset||Fr(t),e.draped||(t.uniforms.add(new X("perDistancePixelRatio",(s,i)=>Math.tan(i.camera.fovY/2)/(i.camera.fullViewport[2]/2))),t.code.add(g`
    void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {
      float distanceToCamera = length(posView);

      // Compute offset in world units for a half pixel shift
      float pixelOffset = distanceToCamera * perDistancePixelRatio * ${g.float(Lt)};

      // Apply offset along normal in the direction away from the ground surface
      vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;

      // Apply the same offset also on the view space position
      vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;

      posModel += modelOffset;
      posView += viewOffset;
    }
  `)),e.screenCenterOffsetUnitsEnabled&&St(t),e.hasScreenSizePerspective&&At(t),t.code.add(g`
    vec4 projectPositionHUD(out ProjectHUDAux aux) {
      vec3 centerOffset = centerOffsetAndDistance.xyz;
      float pointGroundDistance = centerOffsetAndDistance.w;

      aux.posModel = position;
      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;
      aux.vnormal = normal;
      ${e.draped?"":"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);"}

      // Screen sized offset in world space, used for example for line callouts
      // Note: keep this implementation in sync with the CPU implementation, see
      //   - MaterialUtil.verticalOffsetAtDistance
      //   - HUDMaterial.applyVerticalOffsetTransformation

      aux.distanceToCamera = length(aux.posView);

      vec3 viewDirObjSpace = normalize(cameraPosition - aux.posModel);
      float cosAngle = dot(aux.vnormal, viewDirObjSpace);

      aux.absCosAngle = abs(cosAngle);

      ${e.hasScreenSizePerspective&&(e.hasVerticalOffset||e.screenCenterOffsetUnitsEnabled)?"vec3 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);":""}

      ${e.hasVerticalOffset?e.hasScreenSizePerspective?"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);":"float verticalOffsetScreenHeight = verticalOffset.x;":""}

      ${e.hasVerticalOffset?g`
            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);
            vec3 modelOffset = aux.vnormal * worldOffset;
            aux.posModel += modelOffset;
            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;
            aux.posView += viewOffset;
            // Since we elevate the object, we need to take that into account
            // in the distance to ground
            pointGroundDistance += worldOffset;`:""}

      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);

      ${e.screenCenterOffsetUnitsEnabled?"":g`
            // Apply x/y in view space, but z in screen space (i.e. along posView direction)
            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);

            // Same material all have same z != 0.0 condition so should not lead to
            // branch fragmentation and will save a normalization if it's not needed
            if (centerOffset.z != 0.0) {
              aux.posView -= normalize(aux.posView) * centerOffset.z;
            }
          `}

      vec4 posProj = proj * vec4(aux.posView, 1.0);

      ${e.screenCenterOffsetUnitsEnabled?e.hasScreenSizePerspective?"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);":"float centerOffsetY = centerOffset.y;":""}

      ${e.screenCenterOffsetUnitsEnabled?"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;":""}

      // constant part of polygon offset emulation
      posProj.z -= groundRelative * polygonOffset * posProj.w;
      return posProj;
    }
  `)}let ci=class{constructor(){this.factor=new ut,this.factorAlignment=new ut}},ut=class{constructor(){this.scale=0,this.factor=0,this.minScaleFactor=0}};function Ne(r){r.uniforms.add(new Lr("alignPixelEnabled",(e,t)=>t.alignPixelEnabled)),r.code.add(g`vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {
if (!alignPixelEnabled)
return clipCoord;
vec2 xy = vec2(0.500123) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`),r.code.add(g`vec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {
if (!alignPixelEnabled)
return clipCoord;
vec2 xy = vec2(0.5) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = floor((xy + 0.5 * pixelSz) * widthHeight) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`)}function di(r,e){const{vertex:t,fragment:s}=r;t.include(Ne),e.multipassEnabled&&r.varyings.add("depth","float"),t.main.add(g`
    vec4 posProjCenter;
    if (dot(position, position) > 0.0) {
      // Render single point to center of the pixel to avoid subpixel filtering to affect the marker color
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      posProjCenter = alignToPixelCenter(posProj, viewport.zw);

      ${e.multipassEnabled?g`depth = projectAux.posView.z;`:""}
      vec3 vpos = projectAux.posModel;
      if (rejectBySlice(vpos)) {
        // Project out of clip space
        posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
      }

    } else {
      // Project out of clip space
      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
    }

    gl_Position = posProjCenter;
    gl_PointSize = 1.0;
  `),r.include(jr,e),s.main.add(g`
    fragColor = vec4(1);
    ${e.multipassEnabled?g`if(terrainDepthTest(depth)) {
             fragColor.g = 0.5;
           }`:""}`)}var ye;(function(r){r[r.Occluded=0]="Occluded",r[r.NotOccluded=1]="NotOccluded",r[r.Both=2]="Both",r[r.COUNT=3]="COUNT"})(ye||(ye={}));function ui(r){r.vertex.uniforms.add(new X("renderTransparentlyOccludedHUD",(e,t)=>t.hudRenderStyle===ye.Occluded?1:t.hudRenderStyle===ye.NotOccluded?0:.75),new Q("viewport",(e,t)=>t.camera.fullViewport),new Tt("hudVisibilityTexture",(e,t)=>{var s;return(s=t.hudVisibility)==null?void 0:s.getTexture()})),r.vertex.include(Ne),r.vertex.code.add(g`bool testHUDVisibility(vec4 posProj) {
vec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);
vec4 occlusionPixel = texture(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);
if (renderTransparentlyOccludedHUD > 0.5) {
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * renderTransparentlyOccludedHUD < 1.0;
}
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;
}`)}function hi(r){const e=new Hr,t=r.signedDistanceFieldEnabled;if(e.include(li,r),e.include(Vr,r),r.occlusionPass)return e.include(di,r),e;const{vertex:s,fragment:i}=e;e.include(Ct),e.include(Nr,r),e.include(Ur,r),e.include(ui),i.include(Ts),i.include(Wr),e.varyings.add("vcolor","vec4"),e.varyings.add("vtc","vec2"),e.varyings.add("vsize","vec2"),e.varyings.add("voccluded","float"),s.uniforms.add(new Q("viewport",(d,c)=>c.camera.fullViewport),new et("screenOffset",(d,c)=>Me(jt,2*d.screenOffset[0]*c.camera.pixelRatio,2*d.screenOffset[1]*c.camera.pixelRatio)),new et("anchorPosition",d=>be(d)),new Q("materialColor",d=>d.color),new X("materialRotation",d=>d.rotation)),St(s),t&&(s.uniforms.add(new Q("outlineColor",d=>d.outlineColor)),i.uniforms.add(new Q("outlineColor",d=>ht(d)?d.outlineColor:dr),new X("outlineSize",d=>ht(d)?d.outlineSize:0))),r.pixelSnappingEnabled&&s.include(Ne),r.hasScreenSizePerspective&&(qr(s),At(s)),r.debugDrawLabelBorder&&e.varyings.add("debugBorderCoords","vec4"),e.attributes.add(m.UV0,"vec2"),e.attributes.add(m.COLOR,"vec4"),e.attributes.add(m.SIZE,"vec2"),e.attributes.add(m.ROTATION,"float"),e.attributes.add(m.FEATUREATTRIBUTE,"vec4"),s.main.add(g`
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      forwardObjectAndLayerIdColor();

      if (rejectBySlice(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }
      vec2 inputSize;
      ${r.hasScreenSizePerspective?g`
            inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
            vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);
         `:g`
            inputSize = size;
            vec2 screenOffsetScaled = screenOffset;`}

      ${r.vvSize?"inputSize *= vvScale(featureAttribute).xx;":""}

      vec2 combinedSize = inputSize * pixelRatio;
      vec4 quadOffset = vec4(0.0);
      bool visible = testHUDVisibility(posProj);
      voccluded = visible ? 0.0 : 1.0;
    `);const n=g`
      vec2 uv01 = floor(uv0);
      vec2 uv = uv0 - uv01;
      quadOffset.xy = uv01 * 2.0 * combinedSize;

      ${r.hasRotation?g`
            float angle = radians(materialRotation + rotation);
            float cosAngle = cos(angle);
            float sinAngle = sin(angle);
            mat2 rotate = mat2(cosAngle, -sinAngle, sinAngle,  cosAngle);

            quadOffset.xy = rotate * (quadOffset.xy - combinedSize) + combinedSize;
          `:""}

      quadOffset.xy = (quadOffset.xy - anchorPosition * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;
  `,o=r.pixelSnappingEnabled?t?g`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;`:g`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}`:g`posProj += quadOffset;`;s.main.add(g`
    ${r.occlusionTestEnabled?"if (visible) {":""}
    ${n}
    ${r.vvColor?"vcolor = interpolateVVColor(featureAttribute.y) * materialColor;":"vcolor = color / 255.0 * materialColor;"}

    ${r.output===S.ObjectAndLayerIdColor?g`vcolor.a = 1.0;`:""}

    bool alphaDiscard = vcolor.a < ${g.float(B)};
    ${t?`alphaDiscard = alphaDiscard && outlineColor.a < ${g.float(B)};`:""}
    if (alphaDiscard) {
      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    } else {
      ${o}
      gl_Position = posProj;
    }

    vtc = uv;

    ${r.debugDrawLabelBorder?"debugBorderCoords = vec4(uv01, 1.5 / combinedSize);":""}
    vsize = inputSize;
    ${r.occlusionTestEnabled?g`} else { vtc = vec2(0.0);
      ${r.debugDrawLabelBorder?"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);}":"}"}`:""}`),i.uniforms.add(new Tt("tex",d=>d.texture));const l=r.debugDrawLabelBorder?g`(isBorder > 0.0 ? 0.0 : ${g.float(B)})`:g.float(B),a=r.output===S.Highlight,u=g`
    ${r.debugDrawLabelBorder?g`
      float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));`:""}

    ${r.sampleSignedDistanceFieldTexelCenter?g`
      // Attempt to sample texel centers to avoid that thin cross outlines
      // disappear with large symbol sizes.
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041
      float txSize = float(textureSize(tex, 0).x);
      float texelSize = 1.0 / txSize;

      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;
      `:g`
      vec2 samplePos = vtc;
      `}

    ${t?g`
      vec4 fillPixelColor = vcolor;

      // Get distance and map it into [-0.5, 0.5]
      float d = rgba2float(texture(tex, samplePos)) - 0.5;

      // Distance in output units (i.e. pixels)
      float dist = d * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${l} ||
          fillPixelColor.a + outlinePixelColor.a < ${g.float(B)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        ${a?"":"fragColor = vec4(compositeColor, compositeAlpha);"}
      } else {
        if (fillAlphaFactor < ${l}) {
          discard;
        }

        ${a?"":"fragColor = premultiplyAlpha(fillPixelColor);"}
      }

      // visualize SDF:
      // fragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      `:g`
          vec4 texColor = texture(tex, vtc, -0.5);
          if (texColor.a < ${l}) {
            discard;
          }
          ${a?"":"fragColor = texColor * premultiplyAlpha(vcolor);"}
          `}

    // Draw debug border with transparency, so that original texels along border are still partially visible
    ${!a&&r.debugDrawLabelBorder?g`fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);`:""}
  `;switch(r.output){case S.Color:r.oitPass===re.ColorAlpha&&(e.outputs.add("fragColor","vec4",0),e.outputs.add("fragAlpha","float",1)),i.main.add(g`
        ${u}
        ${r.oitPass===re.FrontFace?"fragColor.rgb /= fragColor.a;":""}
        ${r.oitPass===re.ColorAlpha?"fragAlpha = fragColor.a;":""}`);break;case S.ObjectAndLayerIdColor:i.main.add(g`
        ${u}
        outputObjectAndLayerIdColor();`);break;case S.Highlight:e.include(kr,r),i.main.add(g`
        ${u}
        outputHighlightNet(voccluded == 1.0);`)}return e}function ht(r){return r.outlineColor[3]>0&&r.outlineSize>0}function be(r,e=jt){return r.textureIsSignedDistanceField?fi(r.anchorPosition,r.distanceFieldBoundingBox,e):ur(e,r.anchorPosition),e}function fi(r,e,t){e!=null?Me(t,r[0]*(e[2]-e[0])+e[0],r[1]*(e[3]-e[1])+e[1]):Me(t,0,0)}const jt=hr(),pi=Object.freeze(Object.defineProperty({__proto__:null,build:hi,calculateAnchorPosForRendering:be},Symbol.toStringTag,{value:"Module"}));let Ht=class Vt extends Qr{constructor(e,t,s){super(e,t,s),this.primitiveType=t.occlusionPass?Ye.POINTS:Ye.TRIANGLES}initializeProgram(e,t){return new Yr(e.rctx,Vt.shader.get().build(t),Xr)}initializePipeline(e){const{oitPass:t,hasPolygonOffset:s,draped:i,output:n,depthEnabled:o,occlusionPass:l}=e,a=t===re.NONE,u=t===re.FrontFace,d=s?mi:null,c=i?null:(a||u)&&n!==S.Highlight&&(o||l)?xs:null;return Os({blending:n===S.Color?a?Cs:Jr(t):null,depthTest:i?null:{func:fr.LEQUAL},depthWrite:c,drawBuffers:Zr(t,n),colorWrite:Ss,polygonOffset:d})}};Ht.shader=new Kr(pi,()=>pr(()=>import("./HUDMaterial.glsl-1932ecb5.js"),["assets/HUDMaterial.glsl-1932ecb5.js","assets/index-b8632133.js","assets/index-d85835aa.css","assets/NormalAttribute.glsl-15306aae.js","assets/interfaces-3cb63efc.js","assets/VertexAttribute-ace1421c.js","assets/mat4f64-9a8384aa.js","assets/BindType-d21d71dd.js","assets/DefaultTechniqueConfiguration-17653ab9.js","assets/mat3f64-e19cdcb8.js","assets/requestImageUtils-07ee909b.js","assets/basicInterfaces-d9412f98.js","assets/Util-95651989.js","assets/BufferView-a598cb7c.js","assets/sphere-df5b271a.js","assets/plane-a919c55a.js","assets/quatf64-81e039e4.js","assets/lineSegment-2e31aeda.js","assets/renderState-9bda431a.js","assets/QueryEngine-d7982a4c.js","assets/featureConversionUtils-0d61f1ce.js","assets/WhereClause-3a6ddd19.js","assets/TimeOnly-2246638c.js","assets/timeSupport-2b5ecd18.js","assets/QueryEngineCapabilities-85c4f1d0.js","assets/utils-afed9034.js","assets/utils-75d79faa.js","assets/ClassBreaksDefinition-ef348958.js","assets/PooledRBush-8246720e.js","assets/projectVectorToVector-8b29a070.js","assets/projectPointToVector-8bba8dd3.js","assets/glUtil-4eacbecb.js","assets/VertexElementDescriptor-2925c6af.js","assets/NestedMap-b667f687.js","assets/floatRGBA-fce694d8.js","assets/InterleavedLayout-3c3c5582.js","assets/types-1305598a.js","assets/Indices-3253d062.js","assets/Attribute-422e3b38.js"]));const mi={factor:0,units:-4};let A=class extends es{constructor(e){super(),this.spherical=e,this.screenCenterOffsetUnitsEnabled=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.vvSize=!1,this.vvColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.hasRotation=!1,this.debugDrawLabelBorder=!1,this.hasSlicePlane=!1,this.hasPolygonOffset=!1,this.depthEnabled=!0,this.pixelSnappingEnabled=!0,this.draped=!1,this.multipassEnabled=!1,this.cullAboveGround=!1,this.occlusionPass=!1,this.objectAndLayerIdColorInstanced=!1,this.textureCoordinateType=ts.None,this.emissionSource=rs.None,this.discardInvisibleFragments=!0,this.hasSliceInVertexProgram=!0,this.hasVvInstancing=!1}};w([T()],A.prototype,"screenCenterOffsetUnitsEnabled",void 0),w([T()],A.prototype,"occlusionTestEnabled",void 0),w([T()],A.prototype,"signedDistanceFieldEnabled",void 0),w([T()],A.prototype,"sampleSignedDistanceFieldTexelCenter",void 0),w([T()],A.prototype,"vvSize",void 0),w([T()],A.prototype,"vvColor",void 0),w([T()],A.prototype,"hasVerticalOffset",void 0),w([T()],A.prototype,"hasScreenSizePerspective",void 0),w([T()],A.prototype,"hasRotation",void 0),w([T()],A.prototype,"debugDrawLabelBorder",void 0),w([T()],A.prototype,"hasSlicePlane",void 0),w([T()],A.prototype,"hasPolygonOffset",void 0),w([T()],A.prototype,"depthEnabled",void 0),w([T()],A.prototype,"pixelSnappingEnabled",void 0),w([T()],A.prototype,"draped",void 0),w([T()],A.prototype,"multipassEnabled",void 0),w([T()],A.prototype,"cullAboveGround",void 0),w([T()],A.prototype,"occlusionPass",void 0),w([T()],A.prototype,"objectAndLayerIdColorInstanced",void 0);class gi extends ss{constructor(e,t){super(e,Ai),this.produces=new Map([[M.HUD_MATERIAL,s=>Ce(s)&&!this.parameters.drawInSecondSlot],[M.LABEL_MATERIAL,s=>Ce(s)&&this.parameters.drawInSecondSlot],[M.OCCLUSION_PIXELS,()=>this.parameters.occlusionTest],[M.DRAPED_MATERIAL,s=>Ce(s)]]),this._visible=!0,this._configuration=new A(t)}getConfiguration(e,t){return this._configuration.output=e,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled=this.parameters.centerOffsetUnits==="screen",this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=this.parameters.draped,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.hasRotation=this.parameters.hasRotation,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.occlusionPass=t.slot===M.OCCLUSION_PIXELS&&this.parameters.occlusionTest,e===S.Color&&(this._configuration.debugDrawLabelBorder=!!is.LABELS_SHOW_BORDER),this._configuration.depthEnabled=this.parameters.depthEnabled,this._configuration.oitPass=t.oitPass,this._configuration.multipassEnabled=t.multipassEnabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration}intersect(e,t,s,i,n,o){const{options:{selectionMode:l,hud:a,excludeLabels:u},point:d,camera:c}=s,{parameters:f}=this;if(!l||!a||u&&f.isLabel||!e.visible||!d)return;const{scaleX:h,scaleY:p}=this._getScreenScale(e,c.pixelRatio);wt(Ie,t),e.attributes.has(m.FEATUREATTRIBUTE)&&bi(Ie);const y=e.attributes.get(m.POSITION),O=e.attributes.get(m.SIZE),_=e.attributes.get(m.NORMAL),x=e.attributes.get(m.CENTEROFFSETANDDISTANCE);he(y.size>=3);const v=be(f),b=this.parameters.centerOffsetUnits==="screen";for(let C=0;C<y.data.length/y.size;C++){const E=C*y.size;xe($,y.data[E],y.data[E+1],y.data[E+2]),ue($,$,t),ue($,$,c.viewMatrix);const V=C*x.size;if(xe(I,x.data[V],x.data[V+1],x.data[V+2]),!b&&($[0]+=I[0],$[1]+=I[1],I[2]!==0)){const ie=I[2];Xe(I,$),mr($,$,N(I,I,ie))}const we=C*_.size;if(xe(te,_.data[we],_.data[we+1],_.data[we+2]),ft(te,Ie,c,De),this._applyVerticalOffsetTransformationView($,De,c,Ee),c.applyProjection($,P),P[0]>-1){b&&(I[0]||I[1])&&(P[0]+=I[0]*c.pixelRatio,I[1]!==0&&(P[1]+=ns(I[1],Ee.factorAlignment)*c.pixelRatio),c.unapplyProjection(P,$)),P[0]+=this.parameters.screenOffset[0]*c.pixelRatio,P[1]+=this.parameters.screenOffset[1]*c.pixelRatio,P[0]=Math.floor(P[0]),P[1]=Math.floor(P[1]);const ie=C*O.size;G[0]=O.data[ie]*h,G[1]=O.data[ie+1]*p,os(G,Ee.factor,G);const qt=Oi*c.pixelRatio;let Ue=0;if(f.textureIsSignedDistanceField&&(Ue=f.outlineSize*c.pixelRatio/2),pt(d,P[0],P[1],G,qt,Ue,f,v)){const We=s.ray;if(ue(mt,$,He(wi,c.viewMatrix)),P[0]=d[0],P[1]=d[1],c.unprojectFromRenderScreen(P,$)){const K=R();U(K,We.direction);const qe=1/ne(K);N(K,K,qe),o(gr(We.origin,$)*qe,K,-1,!0,1,mt)}}}}}intersectDraped(e,t,s,i,n,o){const l=e.attributes.get(m.POSITION),a=e.attributes.get(m.SIZE),u=this.parameters,d=be(u),{scaleX:c,scaleY:f}=this._getScreenScale(e,e.screenToWorldRatio),h=Ci*e.screenToWorldRatio;for(let p=0;p<l.data.length/l.size;p++){const y=p*l.size,O=l.data[y],_=l.data[y+1],x=p*a.size;G[0]=a.data[x]*c,G[1]=a.data[x+1]*f;let v=0;u.textureIsSignedDistanceField&&(v=u.outlineSize*e.screenToWorldRatio/2),pt(i,O,_,G,h,v,u,d)&&n(o.dist,o.normal,-1,!1)}}createBufferWriter(){return new $i}_updateScaleInfo(e,t,s){const i=this.parameters;i.screenSizePerspective!=null?tt(s,t,i.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minScaleFactor=0),i.screenSizePerspectiveAlignment!=null?tt(s,t,i.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minScaleFactor=e.factor.minScaleFactor)}applyShaderOffsetsView(e,t,s,i,n,o,l){const a=ft(t,s,n,De);return this._applyVerticalGroundOffsetView(e,a,n,l),this._applyVerticalOffsetTransformationView(l,a,n,o),this._applyPolygonOffsetView(l,a,i[3],n,l),this._applyCenterOffsetView(l,i,l),l}applyShaderOffsetsNDC(e,t,s,i,n){return this._applyCenterOffsetNDC(e,t,s,i),n!=null&&U(n,i),this._applyPolygonOffsetNDC(i,t,s,i),i}_applyPolygonOffsetView(e,t,s,i,n){const o=i.aboveGround?1:-1;let l=Math.sign(s);l===0&&(l=o);const a=o*l;if(this.parameters.shaderPolygonOffset<=0)return U(n,e);const u=vr(Math.abs(t.cosAngle),.01,1),d=1-Math.sqrt(1-u*u)/u/i.viewport[2];return N(n,e,a>0?d:1/d),n}_applyVerticalGroundOffsetView(e,t,s,i){const n=ne(e),o=s.aboveGround?1:-1,l=s.computeRenderPixelSizeAtDist(n)*Lt,a=N($,t.normal,o*l);return Oe(i,e,a),i}_applyVerticalOffsetTransformationView(e,t,s,i){var u;const n=this.parameters;if(!((u=n.verticalOffset)!=null&&u.screenLength)){if(n.screenSizePerspective||n.screenSizePerspectiveAlignment){const d=ne(e);this._updateScaleInfo(i,d,t.cosAngle)}else i.factor.scale=1,i.factorAlignment.scale=1;return e}const o=ne(e),l=n.screenSizePerspectiveAlignment??n.screenSizePerspective,a=as(s,o,n.verticalOffset,t.cosAngle,l);return this._updateScaleInfo(i,o,t.cosAngle),N(t.normal,t.normal,a),Oe(e,e,t.normal)}_applyCenterOffsetView(e,t,s){const i=this.parameters.centerOffsetUnits!=="screen";return s!==e&&U(s,e),i&&(s[0]+=t[0],s[1]+=t[1],t[2]&&(Xe(te,s),Oe(s,s,N(te,te,t[2])))),s}_applyCenterOffsetNDC(e,t,s,i){const n=this.parameters.centerOffsetUnits!=="screen";return i!==e&&U(i,e),n||(i[0]+=t[0]/s.fullWidth*2,i[1]+=t[1]/s.fullHeight*2),i}_applyPolygonOffsetNDC(e,t,s,i){const n=this.parameters.shaderPolygonOffset;if(e!==i&&U(i,e),n){const o=s.aboveGround?1:-1,l=o*Math.sign(t[3]);i[2]-=(l||o)*n}return i}set visible(e){this._visible=e}get visible(){const{color:e,outlineSize:t,outlineColor:s}=this.parameters,i=e[3]>=B||t>=B&&s[3]>=B;return this._visible&&i}createGLMaterial(e){return new vi(e)}calculateRelativeScreenBounds(e,t,s=yr()){return yi(this.parameters,e,t,s),s[2]=s[0]+e[0],s[3]=s[1]+e[1],s}_getScreenScale(e,t){const s=e.attributes.get(m.FEATUREATTRIBUTE);if(s==null)return{scaleX:t,scaleY:t};const i=br(s.data,xi);return ls(Re,this.parameters,i),{scaleX:Re[0]*t,scaleY:Re[1]*t}}}class vi extends cs{constructor(e){super({...e,...e.material.parameters})}selectProgram(e){return this.ensureTechnique(Ht,e)}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.selectProgram(e)}}function yi(r,e,t,s){s[0]=r.anchorPosition[0]*-e[0]+r.screenOffset[0]*t,s[1]=r.anchorPosition[1]*-e[1]+r.screenOffset[1]*t}function ft(r,e,t,s){return ai(e)&&(e=wt(_i,e)),_r(s.normal,r,e),ue(s.normal,s.normal,t.viewInverseTransposeMatrix),s.cosAngle=wr(Nt,Si),s}function bi(r){const e=r[0],t=r[1],s=r[2],i=r[3],n=r[4],o=r[5],l=r[6],a=r[7],u=r[8],d=1/Math.sqrt(e*e+t*t+s*s),c=1/Math.sqrt(i*i+n*n+o*o),f=1/Math.sqrt(l*l+a*a+u*u);return r[0]=e*d,r[1]=t*d,r[2]=s*d,r[3]=i*c,r[4]=n*c,r[5]=o*c,r[6]=l*f,r[7]=a*f,r[8]=u*f,r}function pt(r,e,t,s,i,n,o,l){let a=e-i-s[0]*l[0],u=a+s[0]+2*i,d=t-i-s[1]*l[1],c=d+s[1]+2*i;const f=o.distanceFieldBoundingBox;return o.textureIsSignedDistanceField&&f!=null&&(a+=s[0]*f[0],d+=s[1]*f[1],u-=s[0]*(1-f[2]),c-=s[1]*(1-f[3]),a-=n,u+=n,d-=n,c+=n),r[0]>a&&r[0]<u&&r[1]>d&&r[1]<c}const Ee=new ci,$=R(),te=R(),P=xt(),Nt=R(),mt=R(),Ie=Pt(),_i=Pt(),wi=Z(),I=R(),Re=R(),xi=xt(),De={normal:Nt,cosAngle:0},Oi=1,Ci=2,G=[0,0],Si=xr(0,0,1);class Ai extends ds{constructor(){super(...arguments),this.renderOccluded=us.Occlude,this.isDecoration=!1,this.color=Je(1,1,1,1),this.polygonOffset=!1,this.anchorPosition=z(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=Je(1,1,1,1),this.outlineSize=0,this.rotation=0,this.hasRotation=!1,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.centerOffsetUnits="world",this.drawInSecondSlot=!1,this.depthEnabled=!0,this.draped=!1,this.isLabel=!1}}const Ut=ws().vec3f(m.POSITION).vec3f(m.NORMAL).vec2f(m.UV0).vec4u8(m.COLOR).vec2f(m.SIZE).f32(m.ROTATION).vec4f(m.CENTEROFFSETANDDISTANCE).vec4f(m.FEATUREATTRIBUTE),Ti=Ut.clone().vec4u8(m.OBJECTANDLAYERIDCOLOR);class $i{constructor(){this.vertexBufferLayout=Or("enable-feature:objectAndLayerId-rendering")?Ti:Ut}elementCount(e){return 6*e.get(m.POSITION).indices.length}write(e,t,s,i,n,o){var x,v;hs(s.get(m.POSITION),e,n.position,o,6),fs(s.get(m.NORMAL),t,n.normal,o,6);const l=(x=s.get(m.UV0))==null?void 0:x.data;let a=0,u=0,d=1,c=1;l&&l.length>=4&&(a=l[0],u=l[1],d=l[2],c=l[3]),d=Math.min(1.99999,d+1),c=Math.min(1.99999,c+1);let f=s.get(m.POSITION).indices.length,h=o;const p=n.uv0;for(let b=0;b<f;++b)p.set(h,0,a),p.set(h,1,u),h++,p.set(h,0,d),p.set(h,1,u),h++,p.set(h,0,d),p.set(h,1,c),h++,p.set(h,0,d),p.set(h,1,c),h++,p.set(h,0,a),p.set(h,1,c),h++,p.set(h,0,a),p.set(h,1,u),h++;ps(s.get(m.COLOR),4,n.color,o,6);const{data:y,indices:O}=s.get(m.SIZE);f=O.length;const _=n.size;h=o;for(let b=0;b<f;++b){const C=y[2*O[b]],E=y[2*O[b]+1];for(let V=0;V<6;++V)_.set(h,0,C),_.set(h,1,E),h++}if(ms(s.get(m.ROTATION),n.rotation,o,6),s.get(m.CENTEROFFSETANDDISTANCE)?rt(s.get(m.CENTEROFFSETANDDISTANCE),n.centerOffsetAndDistance,o,6):st(n.centerOffsetAndDistance,o,6*f),s.get(m.FEATUREATTRIBUTE)?rt(s.get(m.FEATUREATTRIBUTE),n.featureAttribute,o,6):st(n.featureAttribute,o,6*f),i!=null){const b=(v=s.get(m.POSITION))==null?void 0:v.indices;if(b){const C=b.length,E=n.getField(m.OBJECTANDLAYERIDCOLOR,_s);gs(i,E,C,o,6)}}}}let gt=class extends _e{constructor(r){super(),this.view=null,this._renderGeometries=new Map,this._materials=new Map,this._renderers=new Map,this.view=r.view}initialize(){}destroy(){}async executeRenderCommands(r){for(const e of r)switch(e.id){case"create-rendergeometry":await this._createRenderGeometry(e);break;case"destroy-rendergeometry":await this._destroyRenderGeometry(e);break;case"create-material":await this._createMaterial(e)}}async _createMaterial(r){const{view:e}=this,{sharedSymbolResources:t}=e;if(t==null)throw new Error("No shared symbol resources found!");const{textures:s}=t,i=r.materialId,[n,o]=Wt(s,e.state.viewingMode===Cr.Global);this._materials.set(i,n);const l=new fe({material:n});this._renderers.set(n,l),e._stage.addRenderPlugin(l),e._stage.renderView.renderer.updateHasFlags(),this.addHandles([Sr(()=>Ar(o))])}async _createRenderGeometry(r){const e=r.renderGeometryId,t=r.materialId;this._renderGeometries.get(e)!=null&&await this._destroyRenderGeometry({renderGeometryId:e});const s=this._materials.get(t);if(s==null)return void console.error(`material ${r.materialId} not found`);const i=this._renderers.get(s);if(i==null)return void console.error("no renderer assigned to provided material");const n=i.createRenderGeometry(e,r.renderGeometryBuffer,r.localOrigin);this._renderGeometries.set(e,{renderGeometry:n,materialId:t}),this.view._stage.renderView.requestRender()}async _destroyRenderGeometry(r){const e=r.renderGeometryId,t=this._renderGeometries.get(e);if(t==null)return;const s=t.materialId,i=this._materials.get(s);if(i==null)return void console.error(`material ${s} not found`);const n=this._renderers.get(i);n!=null?n.destroyRenderGeometry(r.renderGeometryId):console.error("no renderer assigned to provided material")}};function Wt(r,e){const t={anchorPosition:js.center,occlusionTest:!0,hasSlicePlane:!1},s=t,i=1;s.color=[1,0,0,1],s.outlineColor=[0,0,0,1],s.outlineSize=i;const n=null;if(r!=null){const o=r.fromData("circle-icon",()=>Xs("circle"));s.textureId=o.texture.id,s.textureIsSignedDistanceField=!0,s.sampleSignedDistanceFieldTexelCenter=Ys("circle")}return s.distanceFieldBoundingBox=Pi,[new gi(t,e),n]}gt=w([J("esri.views.3d.layers.graphics.pipeline.rendering.FeaturePipelineRenderer")],gt);const Pi=[Y/2,Y/2,1-Y/2,1-Y/2];class Ei{constructor(e){this._bufferWriter=null,this._bufferWriter=e.createBufferWriter()}createBuffer(e){const t=this._bufferWriter;bt(k,e.transformation),k[12]-=e.localOrigin[0],k[13]-=e.localOrigin[1],k[14]-=e.localOrigin[2],He(de,k),_t(de,de);const s=new Map;for(const[u,d]of e.attributes)s.set(u,{...d,indices:As(d.indices)});const i=t.elementCount(s),n=t.vertexBufferLayout.stride/4;i>Math.floor(Ii/n)&&console.warn("geometry with very large number of elements encountered");const o=new Float32Array(i*n),l=t.vertexBufferLayout.createView(o.buffer),a=0;return t.write(k,de,s,e.objectAndLayerIdColor,l,a),{data:o,numElements:i}}}const k=Z(),de=Z(),Ii=16777216/4;let Ri=class{constructor(e){this._context=e,this._commands=[],this._transferables=new Set}createMaterial(){const e=this._context,t=e.generateId("material"),s=Wt(null,!0)[0],i=new Ei(s);return e.registerRenderGeometryBufferWriter(t,i),this._commands.push({id:"create-material",materialId:t}),t}createRenderGeometry(e,t){const s=t.materialId,i=this._context.getRenderGeometryBufferWriter(s);if(i==null)throw new Error(`no bufferwriter found for material ${s}`);const n=i.createBuffer(t);this._transferables.add(n.data.buffer),this._commands.push({id:"create-rendergeometry",renderGeometryId:e,materialId:s,renderGeometryBuffer:n,localOrigin:t.localOrigin})}destroyRenderGeometry(e){this._commands.push({id:"destroy-rendergeometry",renderGeometryId:e})}dispatch(){const e={commands:this._commands,transferList:Array.from(this._transferables)};return this._clearCommandBuffer(),e}_clearCommandBuffer(){this._commands=[],this._transferables.clear()}};class Di{constructor(){this._idCounter=0,this._bufferWriters=new Map}generateId(e=""){return`${e}${this._idCounter++}`}createEncoder(){return new Ri(this)}registerRenderGeometryBufferWriter(e,t){this._bufferWriters.set(e,t)}getRenderGeometryBufferWriter(e){return this._bufferWriters.get(e)}}let Le=class extends _e{constructor(){super(),this.materialId=null}async remove(r,e){e.destroyRenderGeometry(r)}async render(r,e){this.materialId==null&&(this.materialId=e.createMaterial());const t=r.numFeatures,s=new Float64Array([0,0,1]),i=new Float64Array([255,255,255,255]),n=new Float64Array([24,24]),o=new Float64Array([0,0,0,1]),l=new Float64Array([0,0]),a=new Float64Array([0]),u=new Uint32Array(t);for(let v=0;v<t;++v)u[v]=v;const d=new Uint32Array(t);for(let v=0;v<t;++v)d[v]=0;const c=new F(r.coordinates,u,3,!0),f=new F(s,d,3,!0),h=new F(l,d,2,!0),p=new F(i,d,4,!0),y=new F(a,d,1,!0),O=new F(n,d,2,!0),_=new F(o,d,4,!0),x={attributes:[[m.POSITION,c],[m.NORMAL,f],[m.UV0,h],[m.COLOR,p],[m.ROTATION,y],[m.SIZE,O],[m.CENTEROFFSETANDDISTANCE,_]],objectAndLayerIdColor:void 0,transformation:Z(),localOrigin:r.localOrigin,materialId:this.materialId};e.createRenderGeometry(r.tileId,x)}};Le=w([J("esri.views.3d.layers.graphics.pipeline.symbolization.TestSymbol")],Le);class zi{constructor(){this._testSymbol=new Le}async remove(e,t){this._testSymbol.remove(e,t)}async symbolize(e,t){this._testSymbol.render(e,t)}}let pe=class extends yt.EventedAccessor{constructor(){super(...arguments),this.remoteClient=null,this._renderCommandContext=new Di,this._featureStore=new Ps,this._tileManager=new L({addTile:(r,e)=>this._addTile(r,e),removeTiles:r=>this._removeTiles(r)}),this._fetcher=null,this._processor=null,this._symbolizer=null,this._queryEngine=null,this._defaultQueryJSON=null}get updating(){return this._tileManager.updating}destroy(){this._featureStore.clear(),this._tileManager.destroy()}async setup({spatialReference:r,renderSpatialReference:e,baseQuery:t,url:s,objectIdField:i,capabilities:n,fieldsIndex:o,timeInfo:l}){const a=Ze.fromJSON(r);return this._fetcher=new Fs(a,Ke.fromJSON(t),s,i,n),this._processor=new Ls(i,a,Ze.fromJSON(e)),this._symbolizer=new zi,this._queryEngine=new Pr({hasZ:!0,hasM:!1,geometryType:"esriGeometryPoint",objectIdField:i,fieldsIndex:o,availableFields:[i],spatialReference:r,featureStore:this._featureStore,timeInfo:l}),this._defaultQueryJSON=new Ke({outSpatialReference:a}).toJSON(),this.addHandles(Tr(()=>this.updating,async u=>{this.emit("notify-updating",{updating:u})}),$r),vt}async executeQuery(r,e){return{result:await this._queryEngine.executeQuery(this._ensureQuery(r),e)}}async executeQueryForIds(r,e){const t=await this._queryEngine.executeQueryForIdSet(this._ensureQuery(r),e);return{result:Array.from(t)}}async executeQueryForCount(r,e){return{result:await this._queryEngine.executeQueryForCount(this._ensureQuery(r),e)}}async executeQueryForExtent(r,e){return{result:await this._queryEngine.executeQueryForExtent(this._ensureQuery(r),e)}}async executeQueryForLatestObservations(r,e){return{result:await this._queryEngine.executeQueryForLatestObservations(this._ensureQuery(r),e)}}async onTileTreeChange(r){return await this._tileManager.onTileTreeChange(r),vt}async _addTile(r,e){const t=await this._fetcher.fetch(r,e);me(e);const s=this._processor.process(t);if(s==null)return t;const i=this._renderCommandContext.createEncoder();await this._symbolizer.symbolize(s,i),this._featureStore.addTile(t);const{commands:n,transferList:o}=i.dispatch();return await this.remoteClient.invoke("dispatchRenderCommands",n,{signal:e,transferList:o}),t}async _removeTiles(r){const e=this._renderCommandContext.createEncoder(),t=this._featureStore,s=this._symbolizer;for(const o of r)t.removeTile(o),await s.remove(o,e);const{commands:i,transferList:n}=e.dispatch();await this.remoteClient.invoke("dispatchRenderCommands",i,{transferList:n})}_ensureQuery(r){return r??this._defaultQueryJSON}};w([H()],pe.prototype,"updating",null),pe=w([J("esri.views.3d.layers.graphics.pipeline.Feature3DPipelineWorker")],pe);const Mi=pe,vt={result:void 0},Pn=Object.freeze(Object.defineProperty({__proto__:null,default:Mi},Symbol.toStringTag,{value:"Module"}));export{Pn as F,be as L,hi as O};
