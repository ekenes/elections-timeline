import{au as v,eu as X,t as Y,iR as x,az as A,iS as E,cl as f,ai as p,dE as l,eM as Z,aS as ss,bC as es,fk as ts,bi as os,fb as ns,x as as}from"./index-09dc31eb.js";import{h as rs,a as is,i as I,o as _,A as cs}from"./MeshTransform-0001f835.js";import{r as ls,n as us,a as ps,d as ms,c as k,l as fs,t as ds,u as gs,p as hs}from"./uploadAssetErrors-33dfda50.js";import{s as ws,u as U,i as ys}from"./infoFor3D-24efd44a.js";import{i as Ps,n as Ts}from"./meshFeatureAttributes-8fddbe90.js";import"./mat4f64-9a8384aa.js";import"./quat-d40c4b9d.js";import"./mat3f64-e19cdcb8.js";import"./quatf64-81e039e4.js";const $={upload:{createFromFiles:.8,loadMesh:.2},uploadAssetBlobs:{prepareAssetItems:.9,uploadAssetItems:.1},uploadConvertibleSource:{uploadEditSource:.5,serviceAssetsToGlb:.5},uploadLocalMesh:{meshToAssetBlob:.5,uploadAssetBlobs:.5}};function w(e,t=o=>{},s){return new bs(e,t,s)}let bs=class{constructor(t,s=n=>{},o){if(this.onProgress=s,this.taskName=o,this._progressMap=new Map,this._startTime=void 0,this._timingsMap=new Map,typeof t=="number"){this._weights={};for(let n=0;n<t;n++){const a=n,r=1/t;this._weights[a]=r,this._progressMap.set(a,0)}}else this._weights=t;this.emitProgress()}emitProgress(){let t=0;for(const[s,o]of this._progressMap.entries())t+=o*this._weights[s];if(t===1&&v("enable-feature:esri-3dofl-upload-timings")){const s=Math.round(performance.now()-(this._startTime??0))/1e3;console.log(`${this.taskName} done in ${s} sec`);for(const[o,n]of this._timingsMap){const a=Math.round(n.end-n.start)/1e3,r=Math.round(a/s*100);console.log(this.taskName??"Task",{stepKey:o,stepTime:a,relativeTime:r})}}this.onProgress(t)}setProgress(t,s){if(this._progressMap.set(t,s),v("enable-feature:esri-3dofl-upload-timings")){const o=performance.now();this._startTime??(this._startTime=o);const n=X(this._timingsMap,t,()=>({start:o,end:0}));s===1&&(n.end=o)}this.emitProgress()}simulate(t,s){return D(o=>this.setProgress(t,o),s)}makeOnProgress(t){return s=>this.setProgress(t,s)}};function D(e=s=>{},t=js){const s=performance.now();e(0);const o=setInterval(()=>{const n=performance.now()-s,a=1-Math.exp(-n/t);e(a)},Ss);return Y(()=>{clearInterval(o),e(1)})}function As(e,t=Ms){return x(E(e*R/t))}function $s(e,t=Fs){return x(E(e*R/t))}const Ms=10,Fs=10,R=8e-6,Ss=A(50),js=A(1e3),O=1e6,N=20*O,vs=2e9,Ns=3;async function xs({data:e,name:t,description:s},o,n){let a=null;try{const r=f(o,"uploads"),i=f(r,"info"),{data:c}=await p(i,{query:{f:"json"},responseType:"json"});l(n);const d=Z(o),g=c.maxUploadFileSize*O,h=d?vs:g,m=d?Math.min(N,g):N;if(e.size>h)throw new Error("Data too large");const L=f(r,"register"),{data:M}=await p(L,{query:{f:"json",itemName:Es(t),description:s},responseType:"json",method:"post"});if(l(n),!M.success)throw new Error("Registration failed");const{itemID:H}=M.item;a=f(r,H);const G=f(a,"uploadPart"),F=Math.ceil(e.size/m),y=new Array;for(let u=0;u<F;++u)y.push(e.slice(u*m,Math.min((u+1)*m,e.size)));const P=y.slice().reverse(),S=new Array,J=w(F,n==null?void 0:n.onProgress,"uploadItem"),W=async()=>{for(;P.length!==0;){const u=y.length-P.length,T=P.pop(),b=new FormData,V=J.simulate(u,As(T.size));try{b.append("f","json"),b.append("file",T),b.append("partId",`${u}`);const{data:Q}=await p(G,{timeout:0,body:b,responseType:"json",method:"post"});if(l(n),!Q.success)throw new Error("Part upload failed")}finally{V.remove()}}};for(let u=0;u<Ns&&P.length!==0;++u)S.push(W());await Promise.all(S);const K=f(a,"commit"),{data:j}=await p(K,{query:{f:"json",parts:y.map((u,T)=>T).join(",")},responseType:"json",method:"post"});if(l(n),!j.success)throw new Error("Commit failed");return j.item}catch(r){if(a!=null){const i=f(a,"delete");await p(i,{query:{f:"json"},responseType:"json",method:"post"})}throw r}}function Es(e){return e.replaceAll("/","_").replaceAll("\\","_")}async function le(e,t,s){var a;const o=e.length;if(!o)return(a=s==null?void 0:s.onProgress)==null||a.call(s,1),[];const n=w(o,s==null?void 0:s.onProgress,"uploadAssets");return Promise.all(e.map((r,i)=>Is(r,t,{...s,onProgress:n.makeOnProgress(i)})))}async function Is(e,{layer:t,ongoingUploads:s},o){var r;const n=s.get(e);if(n)return n;if(!Qs(t))throw new ls;if(_s(e,t))return(r=o==null?void 0:o.onProgress)==null||r.call(o,1),e;const a=ks(e,t,o);s.set(e,a);try{await a}finally{s.delete(e)}return e}function _s(e,t){const{parsedUrl:s}=t;return s!=null&&e.metadata.externalSources.some(o=>rs(o,s))}async function ks(e,t,s){const{metadata:o}=e,{displaySource:n}=o,a=B(n==null?void 0:n.source,t),r=!!a,i=o.externalSources.length>0,c=r?Us(a,t,s):i?Ds(e,t,s):Rs(e,t,s),d=await c;return l(s),e.addExternalSources([d]),e}async function Us(e,t,s){return{source:await C(e,t,s),original:!0}}async function Ds(e,t,s){const o=z(t),{externalSources:n}=e.metadata,a=Bs(n,t);if(!a)throw new us;const r=w($.uploadConvertibleSource,s==null?void 0:s.onProgress,"uploadConvertibleSource"),i=await C(a,t,{onProgress:r.makeOnProgress("uploadEditSource")});e.addExternalSources([{source:i,original:!0}]);const c=a.reduce((g,{asset:h})=>h instanceof File?g+h.size:g,0),d=r.simulate("serviceAssetsToGlb",$s(c));try{const{source:g,transform:h,origin:m}=await Js(i,t,o);return h&&(e.transform=h),m&&(s!=null&&s.useAssetOrigin)&&(e.vertexSpace.origin=[m.x,m.y,m.z??0],e.spatialReference=m.spatialReference),{source:g}}finally{d.remove()}}async function Rs(e,t,s){const o=w($.uploadLocalMesh,s==null?void 0:s.onProgress,"uploadLocalMesh"),n=Os(e,t,{...s,onProgress:o.makeOnProgress("meshToAssetBlob")});return{source:await q([n],t,{...s,onProgress:o.makeOnProgress("uploadAssetBlobs")}),extent:e.extent.clone(),original:!0}}async function Os(e,t,s){const o=z(t),n=await e.load(s),a=await n.toBinaryGLTF({origin:n.origin,signal:s==null?void 0:s.signal,ignoreLocalTransform:!0});return l(s),{blob:new Blob([a],{type:"model/gltf-binary"}),assetName:`${ss()}.glb`,assetType:o}}function Bs(e,t){for(const s of e){const o=B(s.source,t);if(o)return o}return null}function B(e,t){if(!e)return null;const{infoFor3D:{supportedFormats:s,editFormats:o}}=t,n=cs(e),a=new Array;let r=!1;for(let i=0;i<n.length;++i){const c=Cs(n[i],s);if(!c)return null;o.includes(c.assetType)&&(r=!0),a.push(c)}return r?a:null}function Cs(e,t){const s=is(e,t);return s?{asset:e,assetType:s}:null}async function C(e,t,s){return q(e.map(o=>qs(o,s)),t,s)}async function q(e,t,s){const o=w($.uploadAssetBlobs,s==null?void 0:s.onProgress,"uploadAssetBlobs"),n=await Ls(e,t,{...s,onProgress:o.makeOnProgress("prepareAssetItems")});l(s);const a=n.map(({item:i})=>i),{uploadResults:r}=await Hs(a,t,{...s,onProgress:o.makeOnProgress("uploadAssetItems")});return l(s),e.map((i,c)=>Gs(n[c],r[c],t))}async function qs(e,t){const{asset:s,assetType:o}=e;if(s instanceof File)return{blob:s,assetName:s.name,assetType:o};const n=await s.toBlob(t);return l(t),{blob:n,assetName:s.assetName,assetType:o}}async function zs(e,t,s){const{blob:o,assetType:n,assetName:a}=e;let r=null;try{const i=await xs({data:o,name:a},t.url,s);l(s),r={assetType:n,assetUploadId:i.itemID}}catch(i){os(i),Xs().warnOnce(`Service ${t.url} does not support the REST Uploads API.`)}if(!r){const i=await ns(o);if(l(s),!i.isBase64)throw new gs;r={assetType:n,assetData:i.data}}if(!r)throw new hs;return{item:r,assetName:a}}function Ls(e,t,s){const o=w(e.length,s==null?void 0:s.onProgress,"prepareAssetItems");return Promise.all(e.map(async(n,a)=>{const r=zs(await n,t,{...s,onProgress:o.makeOnProgress(a)});return l(s),r}))}async function Hs(e,t,s){const o=D(s==null?void 0:s.onProgress);try{const n=await p(f(t.parsedUrl.path,"uploadAssets"),{timeout:0,query:{f:"json",assets:JSON.stringify(e)},method:"post",responseType:"json"});if(l(s),n.data.uploadResults.length!==e.length)throw new ps(e.length,n.data.uploadResults.length);return n.data}finally{o.remove()}}function Gs(e,t,s){const{success:o}=t;if(!o){const{error:d}=t;throw new ms(e.assetName,d)}const{assetHash:n}=t,{assetName:a,item:{assetType:r}}=e,{infoFor3D:{supportedFormats:i}}=s,c=ws(r,i);if(!c)throw new k(r);return new I(a,c,[new _(`${s.parsedUrl.path}/assets/${n}`,n)])}async function Js(e,t,s){var a;const o=e.map(({assetName:r,parts:i})=>({assetName:r,assetHash:i[0].partHash}));let n;try{const r=f(t.parsedUrl.path,"convert3D"),i=(a=t.capabilities)==null?void 0:a.operations.supportsAsyncConvert3D;n=(await(i?Vs:Ks)(r,{query:{f:"json",assets:JSON.stringify(o),transportType:"esriTransportTypeUrl",targetFormat:s,async:i},responseType:"json",timeout:0})).data}catch{throw new fs}return Ws(n,t.infoFor3D)}function Ws(e,{supportedFormats:t}){const s={source:e.assets.map(o=>{const n=U(o.contentType,t);if(!n)throw new k(n);return new I(o.assetName,o.contentType,[new _(o.assetURL,o.assetHash)])})};if(e.transform&&(s.transform=Ps(e.transform),e.spatialReference)){const o=es.fromJSON(e.spatialReference);s.origin=Ts(e.transform,o)}return s}function Ks(e,t){return p(e,t)}async function Vs(e,t){const s=(await p(e,t)).data.statusUrl;for(;;){const o=(await p(s,{query:{f:"json"},responseType:"json"})).data;switch(o.status){case"Completed":return p(o.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new Error(o.status);case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new Error}await ts(Ys)}}function Qs(e){return!!e.infoFor3D&&!!e.url}function z(e){const{infoFor3D:t}=e,s=U("model/gltf-binary",t.supportedFormats)??ys("glb",t.supportedFormats);if(!s)throw new ds;return s}function Xs(){return as.getLogger("esri.layers.graphics.sources.support.uploadAssets")}const Ys=A(1e3);export{le as uploadAssets};
