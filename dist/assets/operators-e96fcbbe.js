import{B as as,cj as us,Y as Ke,bF as ms,P as cs,_ as mt,bB as ct,F as xt,hm as xe,hn as Pe,hl as be,ge as Ce,q4 as ls,br as hs,fL as Jt,fM as Wt,q5 as st,q6 as It}from"./index-02eff6e6.js";import{t as rt,s as U}from"./SimpleGeometryCursor-e3941f41.js";import{_ as tt,as as wt,aE as fn,i as X,ax as fs,au as _s,a as d,S as p,D as Kt,c as z,m as _n,n as V,f as Dt,g as F,y as gs,M as $t,o as gn,aW as pe,b2 as Ht,aS as Q,b3 as He,b4 as ps,b5 as ds,b6 as Qe,b7 as ys,b as G,h as Qt,w as xs,ak as St,A as ht,x as Et,H as Tt,b8 as ve,s as Ps,K as Ct,al as ut,b9 as yt,C as bs,$ as pn,ba as Cs,bb as vs,B as dn,b1 as Ds,aQ as ft,a8 as ws,R as $s,bc as Nt,bd as Ms,be as Ss,bf as Ts,bg as Es,bh as Is,bi as yn,bj as Ft,bk as Ut,bl as Zt,bm as Ns,bn as Gs,E as qs,F as As,bo as vt,bp as Rt,am as Rs,bq as tn,br as Vs,bs as Vt,q as ks,d as Ys,a9 as Xs,z as Os,a5 as H,X as kt,bt as js,bu as Bs,bv as zs,bw as Ls,bx as Fs,by as Us,bz as Zs,bA as Js,bB as Ws,G as xn}from"./OperatorProject-2baa0db8.js";import{fromGeometryToGXGeometry as Pn,toGeometry as bn}from"./jsonConverter-a6951154.js";import{u as Ks,a as Hs,c as Qs,e as Mt,i as tr,s as er}from"./geodeticCurveType-c06dca40.js";import{i as nr}from"./GeometryCleaner-DVgW95-D-a14fea1e.js";import{t as sr}from"./OperatorCrosses-8fea82d6.js";import{t as rr}from"./OperatorIntersects-7e9721fd.js";import{t as ir}from"./OperatorOverlaps-ad323958.js";import{t as or}from"./OperatorTouches-27ed77bf.js";import{t as ar}from"./OperatorWithin-4b2f705b.js";let ur=class{getOperatorType(){return 10303}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s){return new mr(t,e,s)}execute(t,e,s){const r=t.clone();return r.applyTransformation(e),r}},mr=class extends rt{constructor(t,e,s){super(),this.m_index=-1,this.m_transformation=e.clone(),this.m_inputGeometryCursor=t}next(){let t;if(t=this.m_inputGeometryCursor.next()){tt(t),this.m_index=this.m_inputGeometryCursor.getGeometryID();const e=t.clone();return e.applyTransformation(this.m_transformation),e}return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}};const Cn=new ur;function cr(n,t){return Cn.execute(n,t,null)}function lr(){return Cn.supportsCurves()}const L="_gxVersion",vn=2,Dn=1;function w(n){return Array.isArray(n)?n[0].spatialReference:n.spatialReference}function b(n){switch(n.type){case"point":return Gt(n);case"multipoint":return wn(n);case"polyline":return De(n);case"polygon":return $n(n);case"extent":return ee(n);default:throw new Error(`Unsupported geometry type: ${n.type}`)}}function ee(n){if(!n.getCacheValue(L)){const t=new wt;t.setCoords(n.xmin,n.ymin,n.xmax,n.ymax),n.hasM&&t.setInterval(vn,0,n.mmin,n.mmax),n.hasZ&&t.setInterval(Dn,0,n.zmin,n.zmax),n.setCacheValue(L,t)}return n.getCacheValue(L)}function wn(n){if(!n.getCacheValue(L)){const t=new fn,e=new X,s=n.points,r=n.hasM,i=n.hasZ,o=i?3:2;for(let a=0,u=s.length;a<u;a++){const m=s[a];e.setXYCoords(m[0],m[1]),i&&e.setZ(m[2]??0),r&&e.setM(m[o]??NaN),t.add(e)}n.setCacheValue(L,t)}return n.getCacheValue(L)}function Gt(n){if(!n.getCacheValue(L)){const t=new X;t.setXYCoords(n.x,n.y),n.hasM&&t.setM(n.m),n.hasZ&&t.setZ(n.z),n.setCacheValue(L,t)}return n.getCacheValue(L)}function $n(n){if(!n.getCacheValue(L)){const{curveRings:t,hasM:e,hasZ:s,rings:r}=n,i=Pn({curveRings:t,hasM:e,hasZ:s,rings:r});n.setCacheValue(L,i)}return n.getCacheValue(L)}function De(n){if(!n.getCacheValue(L)){const{curvePaths:t,hasM:e,hasZ:s,paths:r}=n,i=Pn({curvePaths:t,hasM:e,hasZ:s,paths:r});n.setCacheValue(L,i)}return n.getCacheValue(L)}function S(n){if(n.wkid)return fs(n.wkid);const t=n.wkt2||n.wkt;return t?_s(t):null}function R(n,t){if(n)switch(n.getGeometryType()){case d.enumPoint:return ne(n,t);case d.enumEnvelope:return Mn(n,t);case d.enumMultiPoint:return Sn(n,t);case d.enumPolyline:return En(n,t);case d.enumPolygon:return Tn(n,t)}return null}function Mn(n,t){if(n.isEmpty())return null;const e=new as({xmin:n.getXMin(),ymin:n.getYMin(),xmax:n.getXMax(),ymax:n.getYMax(),spatialReference:t}),s=n.getDescription();if(s.hasM()){const r=n.queryInterval(vn,0);e.mmin=r.vmin,e.mmax=r.vmax}if(s.hasZ()){const r=n.queryInterval(Dn,0);e.zmin=r.vmin,e.zmax=r.vmax}return e.setCacheValue(L,n),e}function Sn(n,t){if(n.isEmpty())return null;const e=n.getDescription(),s=e.hasM(),r=e.hasZ(),i=[],o=new X;for(let u=0,m=n.getPointCount();u<m;u++){n.getPointByVal(u,o);const l=[o.getX(),o.getY()];r&&l.push(o.getZ()),s&&l.push(o.getM()),i.push(l)}const a=new us({hasM:s,hasZ:r,points:i,spatialReference:t});return a.setCacheValue(L,n),a}function ne(n,t){if(n instanceof p)return new Ke({x:n.x,y:n.y,spatialReference:t});if(n.isEmpty())return null;const e=new Ke({x:n.getX(),y:n.getY(),spatialReference:t}),s=n.getDescription();return s.hasM()&&(e.m=n.getM()),s.hasZ()&&(e.z=n.getZ()),e.setCacheValue(L,n),e}function Tn(n,t){if(n.isEmpty())return null;const e=ms.fromJSON({spatialReference:t,...bn(n,null)});return e.setCacheValue(L,n),e}function En(n,t){if(n.isEmpty())return null;const e=cs.fromJSON({spatialReference:t,...bn(n,null)});return e.setCacheValue(L,n),e}const se=Object.freeze(Object.defineProperty({__proto__:null,fromExtent:ee,fromGeometry:b,fromMultipoint:wn,fromPoint:Gt,fromPolygon:$n,fromPolyline:De,fromSpatialReference:S,getSpatialReference:w,toExtent:Mn,toGeometry:R,toMultipoint:Sn,toPoint:ne,toPolygon:Tn,toPolyline:En},Symbol.toStringTag,{value:"Module"}));function hr(n,t){const e=w(n);return R(cr(b(n),t.transform),e)}lr();let re,we,$e,Me,In;function Nn(){return!!re&&er()}async function Gn(){if(!Nn()){const[n]=await Promise.all([mt(()=>Promise.resolve().then(()=>se),void 0),Ks()]);re=n.fromGeometry,we=n.fromSpatialReference,$e=n.getSpatialReference,Me=n.toGeometry,In=Hs()}}function fr(n,t,e={}){let{curveType:s="geodesic",maxDeviation:r=NaN,unit:i}=e;i&&(t=ct(t,i,"meters"),r&&(r=ct(r,i,"meters")));const o=$e(n);return Me(Qs(re(n),we(o),Mt[s],t,r),o)}function _r(n,t,e={}){let{curveType:s="geodesic",maxDeviation:r=NaN,union:i=!1,unit:o}=e;o&&(t=t.map(m=>ct(m,o,"meters")),r&&(r=ct(r,o,"meters")));const a=n.map(re),u=$e(n);return tr(a,we(u),Mt[s],t,r,i).map(m=>Me(m,u)).filter(xt)}const Fa=Object.freeze(Object.defineProperty({__proto__:null,execute:fr,executeMany:_r,isLoaded:Nn,load:Gn,get supportsCurves(){return In}},Symbol.toStringTag,{value:"Module"}));let ie;function qn(){return!!ie&&be()}async function gr(){if(!qn()){const[n,t]=await Promise.all([mt(()=>import("./OperatorGeodeticArea-58514cf9.js"),["assets/OperatorGeodeticArea-58514cf9.js","assets/OperatorProject-2baa0db8.js","assets/SimpleGeometryCursor-e3941f41.js","assets/index-02eff6e6.js","assets/index-d85835aa.css","assets/OperatorShapePreservingLength-74425419.js"]),mt(()=>import("./OperatorProject-2baa0db8.js").then(e=>e.bC),["assets/OperatorProject-2baa0db8.js","assets/SimpleGeometryCursor-e3941f41.js","assets/index-02eff6e6.js","assets/index-d85835aa.css"]).then(e=>e.a8).then(({injectPe:e})=>e),xe()]);ie=new n.OperatorGeodeticArea,t(Pe)}}function pr(n,t,e){return ie.execute(n,t,e,null)}function dr(){return ie.supportsCurves()}let Se,An,Rn,Vn;function kn(){return!!Se&&qn()}async function Yn(){if(!kn()){const[n]=await Promise.all([mt(()=>Promise.resolve().then(()=>se),void 0),gr()]);Se=n.fromGeometry,An=n.fromSpatialReference,Rn=n.getSpatialReference,Vn=dr()}}function yr(n,t={}){const{curveType:e="geodesic",unit:s}=t,r=Rn(n);let i=pr(Se(n),An(r),Mt[e]);return i&&s&&(i=ct(i,"square-meters",s)),i}const Ua=Object.freeze(Object.defineProperty({__proto__:null,execute:yr,isLoaded:kn,load:Yn,get supportsCurves(){return Vn}},Symbol.toStringTag,{value:"Module"}));let qt;function Xn(){return!!qt&&be()}async function xr(){if(!Xn()){const[n,t]=await Promise.all([mt(()=>import("./OperatorGeodeticDensifyByLength-b465b793.js"),["assets/OperatorGeodeticDensifyByLength-b465b793.js","assets/SimpleGeometryCursor-e3941f41.js","assets/OperatorProject-2baa0db8.js","assets/index-02eff6e6.js","assets/index-d85835aa.css"]),mt(()=>import("./OperatorProject-2baa0db8.js").then(e=>e.bC),["assets/OperatorProject-2baa0db8.js","assets/SimpleGeometryCursor-e3941f41.js","assets/index-02eff6e6.js","assets/index-d85835aa.css"]).then(e=>e.a8).then(({injectPe:e})=>e),xe()]);qt=new n.OperatorGeodeticDensifyByLength,t(Pe)}}function Pr(n,t,e,s){return qt.execute(n,t,e,s,null)}function br(n,t,e,s){const r=qt.executeMany(new U(n),t,e,s,null);return Array.from(r)}function Cr(){return qt.supportsCurves()}let oe,Te,Ee,Ie,On;function jn(){return!!oe&&Xn()}async function Bn(){if(!jn()){const[n]=await Promise.all([mt(()=>Promise.resolve().then(()=>se),void 0),xr()]);oe=n.fromGeometry,Te=n.fromSpatialReference,Ee=n.getSpatialReference,Ie=n.toGeometry,On=Cr()}}function vr(n,t,e={}){const{curveType:s="geodesic",unit:r}=e;r&&(t=ct(t,r,"meters"));const i=Ee(n);return Ie(Pr(oe(n),t,Te(i),Mt[s]),i)}function Dr(n,t,e={}){const{curveType:s="geodesic",unit:r}=e;r&&(t=ct(t,r,"meters"));const i=n.map(oe),o=Ee(n);return br(i,t,Te(o),Mt[s]).map(a=>Ie(a,o))}const Za=Object.freeze(Object.defineProperty({__proto__:null,execute:vr,executeMany:Dr,isLoaded:jn,load:Bn,get supportsCurves(){return On}},Symbol.toStringTag,{value:"Module"}));let ae;function zn(){return!!ae&&be()}async function wr(){if(!zn()){const[n,t]=await Promise.all([mt(()=>import("./OperatorGeodeticLength-b7879047.js"),["assets/OperatorGeodeticLength-b7879047.js","assets/index-02eff6e6.js","assets/index-d85835aa.css","assets/OperatorProject-2baa0db8.js","assets/SimpleGeometryCursor-e3941f41.js","assets/OperatorShapePreservingLength-74425419.js"]),mt(()=>import("./OperatorProject-2baa0db8.js").then(e=>e.bC),["assets/OperatorProject-2baa0db8.js","assets/SimpleGeometryCursor-e3941f41.js","assets/index-02eff6e6.js","assets/index-d85835aa.css"]).then(e=>e.a8).then(({injectPe:e})=>e),xe()]);ae=new n.OperatorGeodeticLength,t(Pe)}}function $r(n,t,e){return ae.execute(n,t,e,null)}function Mr(){return ae.supportsCurves()}let Ne,Ln,Fn,Un;function Zn(){return!!Ne&&zn()}async function Jn(){if(!Zn()){const[n]=await Promise.all([mt(()=>Promise.resolve().then(()=>se),void 0),wr()]);Ne=n.fromGeometry,Ln=n.fromSpatialReference,Fn=n.getSpatialReference,Un=Mr()}}function Sr(n,t={}){const{curveType:e="geodesic",unit:s}=t,r=Fn(n);let i=$r(Ne(n),Ln(r),Mt[e]);return i&&s&&(i=ct(i,"meters",s)),i}const Ja=Object.freeze(Object.defineProperty({__proto__:null,execute:Sr,isLoaded:Zn,load:Jn,get supportsCurves(){return Un}},Symbol.toStringTag,{value:"Module"})),Tr={uniform:0,conformal:1,rigid:2,"rigid-motion":3,general:4},Yt=n=>n.map(t=>new p(t.x,t.y));let Er=class{constructor(){this.transform=new Kt}calculateErrors(t,e){const s=t.length,r=e.length;if(s!==r)throw new Error(`The input length (${s}) is not the same as output length (${r})`);const i=[];return{rms:this.transform.calculateErrors(s,Yt(t),Yt(e),i),errorsOut:i}}flipX(t,e){return this.transform.flipX(t,e),this}flipY(t,e){return this.transform.flipY(t,e),this}initializeFromControlPoints(t,e,s,r){const i=e.length,o=s.length;if(i!==o)throw new Error(`The input length (${i}) is not the same as output length (${o})`);this.transform.initializeFromControlPoints(Tr[t],i,Yt(e),Yt(s),r==null?void 0:r.transform)}isIdentity(){return this.transform.isIdentity()}rotate(t,e,s){const r=Ce(t);return e!=null&&s!=null?this.transform.rotateAngleAbout(r,new p(e,s)):this.transform.rotateAngle(r),this}scale(t,e){return this.transform.scale(t,e),this}setIdentity(){this.transform.setIdentity()}setSwapCoordinates(){return this.transform.setSwapCoordinates(),this}shear(t,e){return this.transform.shear(t,e),this}shift(t,e){return this.transform.shiftCoords(t,e),this}};function Ir(n,t={}){const{unit:e}=t;let s=b(n).calculateArea2D();if(s&&e){const r=w(n);if(r.isGeographic)throw new Error("Unable to convert from an angular area unit to a linear area unit.");const i=ls(r);i!==e&&(i?s=ct(s,i,e):(s=Math.sqrt(s),s*=hs(r),s**=2,s=ct(s,"square-meters",e)))}return s}const Nr=!0,Ka=Object.freeze(Object.defineProperty({__proto__:null,execute:Ir,supportsCurves:Nr},Symbol.toStringTag,{value:"Module"}));let Wn=class{getOperatorType(){return 10204}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s,r){return new en(t,e,s,r)}execute(t,e,s,r){return t||z("null param is not allowed."),new en(null,e,s,r).generalize(t)}},en=class extends rt{constructor(t,e,s,r){super(),this.m_pline=null,this.m_point=new X,this.m_stack=[],this.m_resultstack=[],this.m_callCount=0,this.m_progressTracker=r,this.m_geoms=t,this.m_maxDeviation=e,this.m_bRemoveDegenerateParts=s}tock(){return!0}getRank(){return 1}next(){const t=this.m_geoms.next();return t===null?null:(tt(t),this.generalize(t))}getGeometryID(){return this.m_geoms.getGeometryID()}generalize(t){const e=t.getGeometryType();if(_n(e))return t;if(e===d.enumEnvelope){const o=new V({vd:t.getDescription()});return o.addEnvelope(t,!1),this.generalize(o)}if(Dt(e)){const o=new F({vd:t.getDescription()});return o.addSegment(t,!0),this.generalize(o)}if(gs(e)||$t(""),t.isEmpty()||this.m_maxDeviation<=0)return t;const s=new gn().execute(t,0,.05*this.m_maxDeviation,0,this.m_progressTracker);t.hasNonLinearSegments()&&(this.m_maxDeviation*=.95);const r=s,i=t.createInstance();i.getGeometryType()===d.enumPolygon&&i.setFillRule(t.getFillRule()),this.m_xy=r.getAttributeStreamRef(0);{const o={stack:[],error:void 0,hasError:!1};try{const a=new pe;this.m_pline=a,Jt(o,Ht(()=>{this.m_pline=null},!1),!1);for(let u=0,m=r.getPathCount();u<m;u++)this.generalizePath(r.getImpl(),u,i.getImpl())}catch(a){o.error=a,o.hasError=!0}finally{Wt(o)}}return this.m_resultstack.length=0,this.m_stack.length=0,i}generalizePath(t,e,s){if(t.getPathSize(e)<2)return;this.m_resultstack.length=0,this.m_stack.length=0;const r=t.getPathStart(e),i=t.getPathEnd(e)-1,o=t.isClosedPath(e),a=t.isClosedPathInXYPlane(e);let u=0,m=-1;this.m_stack.push(o?r:i),this.m_stack.push(r);let l=!1,c=!1;for(!this.m_bRemoveDegenerateParts&&a&&(l=!0,c=!0);this.m_stack.length>1;){const h=this.m_stack.at(-1);this.m_stack.pop();const _=this.m_stack.at(-1);let g=t.getXY(h);this.m_pline.setStartXY(g),g=t.getXY(_),this.m_pline.setEndXY(g);const x=[0];let y=this.findGreatestDistance(h,_,i,x);y>=0&&(l?l=!1:(c&&x[0]>u&&(u=x[0],m=y),x[0]<=this.m_maxDeviation&&(y=-1))),y>=0?(this.m_stack.push(y),this.m_stack.push(h)):this.m_resultstack.push(h)}o||this.m_resultstack.push(this.m_stack[0]);const f=this.m_resultstack.length;if(f===t.getPathSize(e)&&f===this.m_stack.length)s.addPath(t,e,!0);else if(this.m_resultstack.length>0){if(this.m_bRemoveDegenerateParts&&this.m_resultstack.length<=2&&(o||this.m_resultstack.length===1||p.distance(t.getXY(this.m_resultstack[0]),t.getXY(this.m_resultstack[1]))<=this.m_maxDeviation))return;if(c&&m>=0&&u<=this.m_maxDeviation){const h=this.m_resultstack.at(-1)>m;this.m_resultstack.push(m),h&&(this.m_resultstack[this.m_resultstack.length-2]=Q(this.m_resultstack[this.m_resultstack.length-1],this.m_resultstack[this.m_resultstack.length-1]=this.m_resultstack[this.m_resultstack.length-2]))}for(let h=0,_=this.m_resultstack.length;h<_;h++)t.getPointByVal(this.m_resultstack[h],this.m_point),h===0?s.startPathPoint(this.m_point):s.lineToPoint(this.m_point);if(o){for(let h=this.m_resultstack.length;h<3;h++)s.lineToPoint(this.m_point);s.closePathWithLine()}}}findGreatestDistance(t,e,s,r){let i=e-1;e<=t&&(i=s);let o=-1,a=0;const u=new p;for(let m=t+1;m<=i;m++){this.m_xy.queryPoint2D(2*m,u);const l=u.x,c=u.y,f=this.m_pline.getClosestCoordinate(u,!1);u.assign(this.m_pline.getCoord2D(f)),u.x-=l,u.y-=c;const h=u.length();h>a&&(o=m,a=h),this.m_callCount++}return r[0]=a,o}},Gr=class{getOperatorType(){return 10104}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}isSimple(t,e,s,r,i){return Cs(t,e,s,r,i)===5}executeMany(t,e,s,r){return new qr(t,e,s,r)}execute(t,e,s,r){const i=new U([t]),o=this.executeMany(i,e,s,r).next();return o||ht("null output"),o}},qr=class extends rt{constructor(t,e,s,r){super(),t||z(""),this.m_progressTracker=r,this.m_bForceSimplify=s,this.m_index=-1,this.m_inputGeometryCursor=t,this.m_spatialReference=e}next(){const t=this.m_inputGeometryCursor.next();return t?(tt(t),this.m_index=this.m_inputGeometryCursor.getGeometryID(),this.simplify(t)):null}getGeometryID(){return this.m_index}tock(){return!1}getRank(){return 1}simplify(t){return t||z(""),vs(t,this.m_spatialReference,this.m_bForceSimplify,this.m_progressTracker)}};var q;function ot(n,t,e,s,r,i){return{m_from:n.clone(),m_to:t.clone(),m_center:e.clone(),m_next:r,m_type:s}}function Xt(n,t,e,s,r){return{m_from:n.clone(),m_to:t.clone(),m_next:e,m_type:4,m_center:new p}}(function(n){n[n.enumDummy=256]="enumDummy",n[n.enumLine=1]="enumLine",n[n.enumArc=2]="enumArc",n[n.enumMiter=8]="enumMiter",n[n.enumBevel=16]="enumBevel",n[n.enumJoinMask=26]="enumJoinMask",n[n.enumConnectionMask=27]="enumConnectionMask"})(q||(q={}));class Ar extends rt{constructor(t,e,s,r,i,o,a,u,m,l){super(),this.m_index=0,this.m_bufferedPolygon=null,this.m_x=0,this.m_y=0,this.m_progressTracker=l,this.m_parent=t,this.m_mp=e,this.m_distance=s,this.m_spatialReference=r,this.m_densifyDist=u,this.m_maxVertexInCompleteCircle=m,this.m_joins=i,this.m_caps=o,this.m_miterLimit=a}next(){const t=new X;for(;;){if(this.m_index===this.m_mp.getPointCount())return null;if(this.m_caps===1)return this.m_index=this.m_mp.getPointCount(),new V({vd:this.m_mp.getDescription()});if(this.m_mp.getPointByVal(this.m_index,t),this.m_index++,!t.isEmpty())break}let e,s=!1;if(this.m_bufferedPolygon===null&&(this.m_x=t.getX(),this.m_y=t.getY(),this.m_bufferedPolygon=this.m_parent.buffer(t,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle),s=!0),e=this.m_index<this.m_mp.getPointCount()?this.m_bufferedPolygon.clone():this.m_bufferedPolygon,!s){const r=new Kt,i=t.getX()-this.m_x,o=t.getY()-this.m_y;r.setShiftCoords(i,o),e.applyTransformation(r)}return pn(e,0),e}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class Rr extends rt{constructor(t){super(),this.m_currentPathIndex=0,this.m_polyline=t}next(){if(!this.m_polyline)return null;const t=this.m_polyline.getImpl(),e=t.getPathCount();if(this.m_currentPathIndex<e){const s=this.m_currentPathIndex;if(this.m_currentPathIndex++,!t.isClosedPathInXYPlane(s)){let i=t.getXY(t.getPathEnd(s)-1);for(;this.m_currentPathIndex<t.getPathCount();){const o=t.getXY(t.getPathStart(this.m_currentPathIndex));if(t.isClosedPathInXYPlane(this.m_currentPathIndex)||!o.equals(i))break;i=t.getXY(t.getPathEnd(this.m_currentPathIndex)-1),this.m_currentPathIndex++}}if(s===0&&this.m_currentPathIndex===this.m_polyline.getPathCount()){const i=this.m_polyline;return this.m_polyline=null,i}const r=new F({vd:this.m_polyline.getDescription()});r.addPath(this.m_polyline,s,!0);for(let i=s+1;i<this.m_currentPathIndex;i++)r.addSegmentsFromPath(this.m_polyline,i,0,t.getSegmentCountPath(i),!1);return this.m_currentPathIndex===this.m_polyline.getPathCount()&&(this.m_polyline=null),r}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class Vr extends rt{constructor(t,e,s){super(),this.m_geometry=null,this.m_index=0,this.m_bufferer=t,this.m_geoms=e,this.m_index=0,this.m_bFilter=s}next(){if(this.m_geometry===null&&(this.m_index=0,this.m_geometry=this.m_geoms.next(),!this.m_geometry))return null;const t=this.m_geometry.getImpl();if(this.m_index<t.getPathCount()){const e=this.m_index;return this.m_index++,this.m_bufferer.bufferPolylinePath(this.m_geometry,e,this.m_bFilter)}return this.m_geometry=null,this.next()}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class kr extends rt{constructor(t){super(),this.m_index=0,this.m_bufferer=t}next(){const t=this.m_bufferer.m_geometry;if(this.m_index<t.getPathCount()){const e=this.m_index,s=t.calculateRingArea2D(this.m_index);for(ut(s>0),this.m_index++;this.m_index<t.getPathCount()&&!(t.calculateRingArea2D(this.m_index)>0);)this.m_index++;let r;return r=e===0&&this.m_index===t.getPathCount()?this.m_bufferer.bufferPolygonImpl(t,0,t.getPathCount()):this.m_bufferer.bufferPolygonImpl(t,e,this.m_index),r}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class Yr{constructor(t){this.m_geometry=null,this.m_bufferCommands=[],this.m_originalGeomType=d.enumUnknown,this.m_maxVertexInCompleteCircle=-1,this.m_circleTemplateSize=-1,this.m_oldCircleTemplateSize=0,this.m_spatialReference=null,this.m_tolerance=new He(0,0),this.m_smallTolerance=new He(0,0),this.m_filterTolerance=0,this.m_densifyDist=-1,this.m_distance=Number.NaN,this.m_absDistance=0,this.m_absDistanceReversed=0,this.m_dA=-1,this.m_miterLimit=4,this.m_joins=0,this.m_caps=0,this.m_bRoundBuffer=!0,this.m_bOutputLoops=!0,this.m_bFilter=!0,this.m_circleTemplate=[],this.m_leftStack=[],this.m_middleStack=[],this.m_helperLine1=new pe,this.m_helperLine2=new pe,this.m_helperArray=[],this.m_progressCounter=0,this.m_densificator=ps.constructDefault(t),this.m_progressTracker=t}buffer(t,e,s,r,i,o,a,u){if(t||z("Geometry.Bufferer.Impl.Buffer"),a<0&&z("Geometry.Bufferer.Impl.Buffer"),ds(t.getGeometryType())&&$t("Unsupported geometry type."),t.isEmpty())return new V({vd:t.getDescription()});if(this.m_joins=r,this.m_caps=i,this.m_bRoundBuffer=!1,this.m_miterLimit=o,this.m_originalGeomType=t.getGeometryType(),Qe(this.m_originalGeomType)?this.m_bRoundBuffer=this.m_joins===0:_n(this.m_originalGeomType)?this.m_bRoundBuffer=this.m_caps===0:ys(this.m_originalGeomType)&&(this.m_bRoundBuffer=this.m_joins===0&&this.m_caps===0),this.m_bFilter=this.m_bRoundBuffer,this.m_geometry=nr(t),this.m_geometry.isEmpty())return new V({vd:t.getDescription()});const m=new G;this.m_geometry.queryLooseEnvelope(m),e>0&&m.inflateCoords(e,e),this.m_tolerance=Qt(s,m,!0),this.m_smallTolerance=Qt(null,m,!0),u<=0&&(u=96),this.m_spatialReference=s,this.m_distance=e,this.m_absDistance=Math.abs(this.m_distance),this.m_absDistanceReversed=this.m_absDistance!==0?1/this.m_absDistance:0,Number.isNaN(a)||a===0?a=1e-5*this.m_absDistance:a>.5*this.m_absDistance&&(a=.5*this.m_absDistance),u<12&&(u=12);const l=Math.abs(e)*(1-Math.cos(Math.PI/u));if(l>a)a=l;else if(e!==0){const f=Math.PI/Math.acos(1-a/Math.abs(e));f<u-1&&(u=Math.trunc(f))<12&&(u=12,a=Math.abs(e)*(1-Math.cos(Math.PI/u)))}this.m_densifyDist=a,this.m_maxVertexInCompleteCircle=u,this.m_filterTolerance=this.m_bRoundBuffer?Math.min(this.m_smallTolerance.total(),.25*this.m_densifyDist):0,this.m_circleTemplateSize=this.calcN(),this.m_circleTemplateSize!==this.m_oldCircleTemplateSize&&(this.m_circleTemplate.length=0,this.m_oldCircleTemplateSize=this.m_circleTemplateSize),this.m_densifyDist>0&&xs(this.m_geometry)&&(this.m_geometry=this.m_densificator.densifyEx(this.m_geometry,0,this.m_densifyDist,0,this.m_joins!==0,St()));const c=this.bufferImpl();return this.m_geometry=null,c}generateCircleTemplate(){if(this.m_circleTemplate.length)return;const t=this.m_circleTemplateSize,e=Math.trunc((t+3)/4),s=.5*Math.PI/e;this.m_dA=s,this.m_circleTemplate.length=4*e;const r=Math.cos(s),i=Math.sin(s),o=p.construct(0,1);for(let a=0;a<e;a++)this.m_circleTemplate[a+0*e]=p.construct(o.y,-o.x),this.m_circleTemplate[a+1*e]=p.construct(-o.x,-o.y),this.m_circleTemplate[a+2*e]=p.construct(-o.y,o.x),this.m_circleTemplate[a+3*e]=o.clone(),o.rotateReverse(r,i)}bufferImpl(){const t=this.m_geometry.getGeometryType();if(Dt(t)){const e=new F({vd:this.m_geometry.getDescription()});return e.addSegment(this.m_geometry,!0),this.m_geometry=e,this.bufferImpl()}if(this.m_distance<=this.m_tolerance.total()){if(!Qe(t))return new V({vd:this.m_geometry.getDescription()});if(this.m_distance<0){const e=new G;if(this.m_geometry.queryEnvelope(e),e.width()<=2*this.m_absDistance||e.height()<=2*this.m_absDistance)return new V({vd:this.m_geometry.getDescription()})}}switch(this.m_geometry.getGeometryType()){case d.enumPoint:return this.bufferPoint();case d.enumMultiPoint:return this.bufferMultiPoint();case d.enumPolyline:return this.bufferPolyline();case d.enumPolygon:return this.bufferPolygon();case d.enumEnvelope:return this.bufferEnvelope();default:ht("")}}bufferPolyline(){if(this.isDegenerateGeometry(this.m_geometry)){const m=new X;this.m_geometry.getPointByVal(0,m);const l=new G;return this.m_geometry.queryEnvelope(l),m.setXY(l.getCenter()),this.bufferDegeneratePath(m,!0)}const t=this.m_geometry,e=this.m_geometry.getDescription();this.m_geometry=null;const s=new Rr(t);let r,i;r=this.m_joins===0?new Wn().executeMany(s,.25*this.m_densifyDist,!1,this.m_progressTracker):s,i=this.m_bRoundBuffer?new Gr().executeMany(r,null,!0,this.m_progressTracker):r;const o=new Vr(this,i,this.m_bFilter),a=new Et().executeMany(o,this.m_spatialReference,this.m_progressTracker,2),u=new Tt().executeMany(a,this.m_spatialReference,!1,this.m_progressTracker).next();return u!==null?u:new V({vd:e})}bufferPolygon(){if(this.m_distance===0)return this.m_geometry;this.generateCircleTemplate();const t=new Tt().execute(this.m_geometry,null,!1,this.m_progressTracker);if(this.m_distance<0){if(this.m_geometry=t,this.m_geometry.isEmpty())return this.m_geometry;const e=this.m_geometry,s=this.bufferPolygonImpl(e,0,e.getPathCount());return new Tt().execute(s,this.m_spatialReference,!1,this.m_progressTracker)}{if(this.m_geometry=t,this.isDegenerateGeometry(this.m_geometry)){const i=new X;this.m_geometry.getPointByVal(0,i);const o=new G;return this.m_geometry.queryEnvelope(o),i.setXY(o.getCenter()),this.bufferDegeneratePath(i,!0)}const e=new kr(this),s=new Et().executeMany(e,this.m_spatialReference,this.m_progressTracker,2),r=new Tt().executeMany(s,this.m_spatialReference,!1,this.m_progressTracker).next();return r!==null?r:new V({vd:this.m_geometry.getDescription()})}}bufferPolygonImpl(t,e,s){const r=t,i=r.getImpl();let o=new V({vd:t.getDescription()});for(let a=e;a<s;a++){if(i.getPathSize(a)<1)continue;const u=i.calculateRingArea2D(a),m=new G;if(i.queryPathEnvelope(a,m),this.m_distance>0)if(u>0)if(this.isDegeneratePath(i,a)){const l=new X;i.getPointByVal(i.getPathStart(a),l),l.setXY(m.getCenter()),o.add(this.bufferDegeneratePath(l,!0),!1)}else{const l=new F({vd:t.getDescription()}),c=l.getImpl();if(ve(this.m_geometry,a)){const f=this.bufferConvexPath(r,a);o.add(f,!1)}else{this.bufferClosedPath(this.m_geometry,a,c,this.m_bRoundBuffer,1);const f=this.bufferCleanup(l);o.add(f,!1)}}else{if(m.width()+this.m_tolerance.total()<=2*this.m_absDistance||m.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;const l=new F({vd:t.getDescription()}),c=l.getImpl();if(this.bufferClosedPath(this.m_geometry,a,c,this.m_bRoundBuffer,1),!l.isEmpty()){const f=m,h=Math.max(1,this.m_absDistance),_=f.clone();_.inflateCoords(h,h),c.addEnvelope(_,!1);const g=this.bufferCleanup(l);o.reserve(o.getPointCount()+g.getPointCount()-4),fe(g,o,_,!0)}}else if(u>0){if(m.width()+this.m_tolerance.total()<=2*this.m_absDistance||m.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;const l=new F({vd:t.getDescription()}),c=l.getImpl();if(this.bufferClosedPath(this.m_geometry,a,c,this.m_bRoundBuffer,-1),!l.isEmpty()){const f=new G;c.queryLooseEnvelope(f);const h=Math.max(1,this.m_absDistance),_=f.clone();_.inflateCoords(h,h),c.addEnvelope(_,!1),fe(this.bufferCleanup(l),o,_,!0)}}else{const l=new F({vd:t.getDescription()}),c=l.getImpl();this.bufferClosedPath(this.m_geometry,a,c,this.m_bRoundBuffer,-1);const f=this.bufferCleanup(l);for(let h=0,_=f.getPathCount();h<_;h++)o.addPath(f,h,!0)}}if(this.m_distance>0)return o.getPathCount()>1?this.bufferCleanup(o):Ot(o);{const a=new G;if(o.queryLooseEnvelope(a),o.isEmpty())return Ot(o);{const u=Math.max(1,this.m_absDistance),m=a.clone();m.inflateCoords(u,u),o.addEnvelope(m,!1);const l=this.bufferCleanup(o);o=new V;const c=new V({vd:l.getDescription()});return fe(l,c,m,!1),Ot(c)}}}bufferPoint(){return this.bufferPointImpl(this.m_geometry)}bufferPointImpl(t){const e=new V({vd:t.getDescription()});return this.m_caps===0?(this.addCircle(e.getImpl(),t),this.setStrongSimple(e)):this.m_caps===2?(this.addSquare(e.getImpl(),t),this.setStrongSimple(e)):e}bufferDegeneratePath(t,e){const s=new V({vd:t.getDescription()});return e&&this.m_joins===0||!e&&this.m_caps===0?(this.addCircle(s.getImpl(),t),this.setStrongSimple(s)):e||this.m_caps!==2?s:(this.addSquare(s.getImpl(),t),this.setStrongSimple(s))}bufferMultiPoint(){const t=new Ar(this,this.m_geometry,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle,this.m_progressTracker);return new Et().executeMany(t,this.m_spatialReference,this.m_progressTracker,2).next()}bufferEnvelope(){let t=new V({vd:this.m_geometry.getDescription()});if(this.m_distance<=0){if(this.m_distance===0)t.addEnvelope(this.m_geometry,!1),nn(this.m_geometry,this.m_tolerance.total())&&(t=this.setStrongSimple(t));else{const s=new wt;this.m_geometry.queryEnvelope(s),s.inflateCoords(this.m_distance,this.m_distance),t.addEnvelope(s,!1),nn(s,this.m_tolerance.total())&&(t=this.setStrongSimple(t))}return t}if(this.m_joins===1){const s=new wt({copy:this.m_geometry});return s.inflateCoords(this.m_absDistance,this.m_absDistance),t.addEnvelope(s,!1),t}const e=this.m_geometry.clone();if(e.width()===0||e.height()===0){if(e.width()===0&&e.height()===0){const i=new X({vd:this.m_geometry.getDescription()});return e.queryCornerByVal(0,i),this.m_geometry=i,this.bufferImpl()}const s=new F({vd:this.m_geometry.getDescription()}),r=new X;return e.queryCornerByVal(0,r),s.startPathPoint(r),e.queryCornerByVal(2,r),s.lineToPoint(r),this.m_geometry=s,this.bufferImpl()}return t.addEnvelope(this.m_geometry,!1),this.m_geometry=t,this.bufferConvexPath(t,0)}bufferConvexPath(t,e){this.generateCircleTemplate();const s=t.hasAttribute(10),r=new V({vd:t.getDescription()}),i=r.getImpl();r.reserve((this.m_circleTemplate.length/10+4)*t.getPathSize(e));const o=new p,a=new p,u=new p,m=new p(0,0),l=new p,c=new p,f=t.getImpl(),h=t.getPathSize(e),_=t.getPathStart(e);for(let g=0,x=t.getPathSize(e);g<x;g++){const y=f.getXY(_+g),P=f.getXY(_+(g+1)%h),C=f.getXY(_+(g+2)%h);l.setSub(P,y),l.length()===0&&ht("");const v=s&&!!(1&f.getAttributeAsInt(10,(g+1)%h,0));l.normalize();const D=l.clone();l.leftPerpendicularThis(),l.scale(this.m_absDistance),o.setAdd(l,y),a.setAdd(l,P),g===0?i.startPath(o):i.lineTo(o),i.lineTo(a),c.setSub(C,P),c.length()===0&&ht(""),c.normalize();const $=c.clone();c.leftPerpendicularThis(),c.scale(this.m_absDistance),u.setAdd(c,P);let E=q.enumArc;const k=v?0:this.m_joins;if(k===2)E=q.enumBevel;else if(k===1){const Z=-D.crossProduct($);m.setSub(D,$),m.scale(this.m_absDistance/Z),m.length()<this.m_miterLimit*this.m_absDistance?(m.addThis(P),E=q.enumMiter):E=q.enumBevel}else m.assign(P);this.addJoin(E,i,m,a,u,!1,!1)}return Ot(r)}bufferPolylinePath(t,e,s){this.generateCircleTemplate();const r=t,i=r.getImpl();if(i.getPathSize(e)<1)return null;let o;if(o=this.m_bRoundBuffer?i.isClosedPathInXYPlane(e):i.isClosedPath(e),this.isDegeneratePath(i,e)&&this.m_distance>0){const m=new X;i.getPointByVal(i.getPathStart(e),m);const l=new G;return i.queryPathEnvelope(e,l),m.setXY(l.getCenter()),this.bufferDegeneratePath(m,o)}const a=new F({vd:t.getDescription()});a.reserve((Math.trunc(this.m_circleTemplate.length/10)+4)*i.getPathSize(e));const u=a.getImpl();return o?this.bufferClosedPath(r,e,u,s,1)!==2&&this.bufferClosedPath(r,e,u,s,-1):this.bufferOpenPath(r,e,u,s),this.bufferCleanup(a)}progress_(){}bufferCleanup(t,e=!1){const s=e?this.m_tolerance:this.m_smallTolerance;return Ps(t,s,!0,!e,-1,this.m_progressTracker,0,!1)}calcN(){if(this.m_densifyDist===0)return this.m_maxVertexInCompleteCircle;const e=1-this.m_densifyDist*Math.abs(this.m_absDistanceReversed);let s=4;return s=e<-1?4:2*Math.PI/Math.acos(e)+.5,s<4?s=4:s>this.m_maxVertexInCompleteCircle&&(s=this.m_maxVertexInCompleteCircle),Math.trunc(s)}addJoin(t,e,s,r,i,o,a){if(this.generateCircleTemplate(),o&&(e.startPath(r),o=!1),t===q.enumBevel)return void(a&&e.lineTo(i));if(t===q.enumMiter){const y=s.clone();return e.lineTo(y),void(a&&e.lineTo(i))}const u=new p;u.setSub(r,s),u.scale(this.m_absDistanceReversed);const m=new p;m.setSub(i,s),m.scale(this.m_absDistanceReversed);let l=Math.atan2(u.y,u.x)/this.m_dA;l<0&&(l=this.m_circleTemplate.length+l),l=this.m_circleTemplate.length-l;let c=Math.atan2(m.y,m.x)/this.m_dA;c<0&&(c=this.m_circleTemplate.length+c),c=this.m_circleTemplate.length-c,c<l&&(c+=this.m_circleTemplate.length);let f=Math.trunc(c),h=Math.ceil(l),_=this.m_circleTemplate[h%this.m_circleTemplate.length].clone();_.scaleAddThis(this.m_absDistance,s);const g=10*this.m_tolerance.total();_.sub(r).length()<g&&(h+=1),_=this.m_circleTemplate[f%this.m_circleTemplate.length].clone(),_.scaleAddThis(this.m_absDistance,s),_.sub(i).length()<g&&(f-=1);let x=f-h;x++;for(let y=0,P=h%this.m_circleTemplate.length;y<x;y++,P=(P+1)%this.m_circleTemplate.length)_=this.m_circleTemplate[P].clone(),_.scaleAddThis(this.m_absDistance,s),e.lineTo(_),this.progress_();a&&e.lineTo(i)}bufferClosedPath(t,e,s,r,i){const o=new Ct,a=o.addPathFromMultiPath(t,e,!0);return this.bufferClosedPathImpl(o,a,s,r,i)}bufferClosedPathImpl(t,e,s,r,i){const o=t.getFirstVertex(t.getFirstPath(e)),a=new X;if(t.queryPoint(o,a),t.filterClosePoints(this.m_filterTolerance,!1,!1,!1,-1),t.getPointCount(e)<2)return i<0?0:(this.m_bRoundBuffer&&this.addCircle(s,a),2);ut(t.getFirstPath(e)!==yt),ut(t.getFirstVertex(t.getFirstPath(e))!==yt);const u=t.getXY(t.getFirstVertex(t.getFirstPath(e))),m=new Kt;if(m.setShift(u.negate()),t.applyTransformation(m),r){const T=Br(t,e,i,!0,this.m_absDistance,this.m_filterTolerance,this.m_densifyDist);if(ut(T===1),t.getPointCount(e)<2)return i<0?0:(this.addCircle(s,a),2)}const l=this.m_joins!==0&&t.getVertexDescription().hasAttribute(10);this.m_bufferCommands.length=0;const c=t.getFirstPath(e);let f=t.getFirstVertex(c),h=i===1?t.getPrevVertex(f):t.getNextVertex(f),_=i===1?t.getNextVertex(f):t.getPrevVertex(f),g=!0;const x=new p,y=new p,P=new p,C=new p,v=new p,D=new p,$=new p,E=new p,k=this.m_absDistance,Z=t.getPathSize(c),J=new p(0,0);for(let T=0;T<Z;T++){y.assign(t.getXY(_)),g&&(x.assign(t.getXY(f)),P.assign(t.getXY(h)),D.setSub(x,P),D.normalize(),E.leftPerpendicularOther(D),E.scale(k),C.setAdd(E,x));const M=l&&!!(1&t.getAttributeAsDbl(10,f,0));v.setSub(y,x),v.normalize(),$.leftPerpendicularOther(v),$.scale(k);const A=new p;A.setAdd(x,$);const et=D.crossProduct(v),I=D.dotProduct(v);if(et<0||I<0&&et<Math.abs(I)*Number.EPSILON*8){let nt=!1;const it=M?0:this.m_joins;if(it===1){const W=-et;J.setSub(D,v),J.scale(this.m_absDistance/W),J.length()<this.m_miterLimit*this.m_absDistance&&(J.addThis(x),nt=!0),this.m_bufferCommands.push(ot(C,A,J,nt?q.enumMiter:q.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(ot(C,A,x,it===0?q.enumArc:q.enumBevel,this.m_bufferCommands.length+1))}else C.equals(A)||(this.m_bufferCommands.push(Xt(C,x,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(Xt(x,A,this.m_bufferCommands.length+1)));const Y=new p;Y.setAdd(y,$),this.m_bufferCommands.push(ot(A,Y,x,q.enumLine,this.m_bufferCommands.length+1)),C.setCoordsPoint2D(Y),E.setCoordsPoint2D($),P.setCoordsPoint2D(x),x.setCoordsPoint2D(y),D.setCoordsPoint2D(v),h=f,f=_,g=!1,_=i===1?t.getNextVertex(f):t.getPrevVertex(f)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(s),m.setShift(u),s.applyTransformationToPath(m,s.getPathCount()-1),1}bufferOpenPath(t,e,s,r){if(this.m_bRoundBuffer){const M=new F({vd:t.getDescription()});return M.addPath(t,e,!1),M.addSegmentsFromPath(t,e,0,t.getSegmentCountPath(e),!1),this.bufferClosedPath(M,0,s,r,1)}let i=0;const o=new F({vd:t.getDescription()}),a=new p(0,0);{const M=new Ct,A=M.addPathFromMultiPath(t,e,!1),et=M.getFirstVertex(M.getFirstPath(A)),I=new X;if(M.queryPoint(et,I),a.assign(I.getXY()),M.filterClosePoints(0,!1,!1,!1,-1),M.getPointCount(A)<2)return this.m_bRoundBuffer&&this.addCircle(s,I),2;const Y=M.getGeometry(M.getFirstGeometry());o.addPath(Y,0,!1),i=o.getPointCount()-1,o.addSegmentsFromPath(Y,0,0,Y.getSegmentCountPath(0)-1,!1)}const u=new Ct,m=u.addPathFromMultiPath(o,0,!0);ut(u.getFirstPath(m)!==yt),ut(u.getFirstVertex(u.getFirstPath(m))!==yt);const l=new Kt;l.setShift(a.negate()),u.applyTransformation(l),this.m_bufferCommands.length=0;const c=u.getFirstPath(m),f=this.m_joins!==0&&u.getVertexDescription().hasAttribute(10);let h=u.getFirstVertex(c),_=u.getPrevVertex(h),g=u.getNextVertex(h),x=!0;const y=new p,P=new p,C=new p,v=new p,D=new p,$=new p,E=new p,k=new p,Z=this.m_absDistance,J=u.getPathSize(c),T=new p(0,0);for(let M=0;M<J;M++){let A=!1;M!==0&&M!==i||(A=!0),P.assign(u.getXY(g)),x&&(y.assign(u.getXY(h)),C.assign(u.getXY(_)),$.setSub(y,C),$.normalize(),k.leftPerpendicularOther($),k.scale(Z),v.setAdd(k,y));const et=f&&!!(1&u.getAttributeAsDbl(10,h,0));D.setSub(P,y),D.normalize(),E.leftPerpendicularOther(D),E.scale(Z);const I=new p;I.setAdd(y,E);const Y=$.crossProduct(D),nt=$.dotProduct(D);if(Y<0||nt<0&&Y<Math.abs(nt)*Number.EPSILON*8)if(A)if(this.m_caps===0)this.m_bufferCommands.push(ot(v,I,y,q.enumArc,this.m_bufferCommands.length+1));else if(this.m_caps===1)this.m_bufferCommands.push(ot(v,I,y,q.enumLine,this.m_bufferCommands.length+1));else{const W=D.mul(this.m_absDistance).negate(),at=W.clone();W.addThis(v),at.addThis(I),this.m_bufferCommands.push(ot(v,W,y,q.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(ot(W,at,y,q.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(ot(at,I,y,q.enumLine,this.m_bufferCommands.length+1))}else{let W=!1;const at=et?0:this.m_joins;if(at===1){const O=-Y;T.setSub($,D),T.scale(this.m_absDistance/O),T.length()<this.m_miterLimit*this.m_absDistance&&(T.addThis(y),W=!0),this.m_bufferCommands.push(ot(v,I,T,W?q.enumMiter:q.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(ot(v,I,y,at===0?q.enumArc:q.enumBevel,this.m_bufferCommands.length+1))}else v.equals(I)||(this.m_bufferCommands.push(Xt(v,y,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(Xt(y,I,this.m_bufferCommands.length+1)));const it=new p;it.setAdd(P,E),this.m_bufferCommands.push(ot(I,it,y,q.enumLine,this.m_bufferCommands.length+1)),v.setCoordsPoint2D(it),k.setCoordsPoint2D(E),C.setCoordsPoint2D(y),y.setCoordsPoint2D(P),$.setCoordsPoint2D(D),_=h,h=g,x=!1,g=u.getNextVertex(h)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(s),l.setShift(a),s.applyTransformationToPath(l,s.getPathCount()-1),1}processBufferCommands(t){const e=this.cleanupBufferCommands();let s=!0,r=e+1;for(let i=e;r!==e;i=r){const o=this.m_bufferCommands[i];r=o.m_next!==-1?o.m_next:(i+1)%this.m_bufferCommands.length,o.m_type&&(s&&(t.startPath(o.m_from),s=!1),o.m_type&q.enumJoinMask?this.addJoin(o.m_type,t,o.m_center,o.m_from,o.m_to,!1,!0):t.lineTo(o.m_to))}}cleanupBufferCommands(){this.m_helperArray=bs(p,9);let t=0;for(let s=0,r=this.m_bufferCommands.length;s<r;){const i=this.m_bufferCommands[s];if(i.m_type&q.enumConnectionMask){t=s;break}s=i.m_next}let e=t+1;for(let s=t;e!==t;s=e){const r=this.m_bufferCommands[s];e=r.m_next;let i=1,o=null;for(;e!==s&&(o=this.m_bufferCommands[e],!(o.m_type&q.enumConnectionMask));)e=o.m_next,i++;i!==1&&(r.m_type&o.m_type)===q.enumLine&&(this.m_helperLine1.setStartXY(r.m_from),this.m_helperLine1.setEndXY(r.m_to),this.m_helperLine2.setStartXY(o.m_from),this.m_helperLine2.setEndXY(o.m_to),this.m_helperLine1.intersect(this.m_helperLine2,this.m_helperArray,null,null,this.m_smallTolerance.total())===1&&(r.m_to.assign(this.m_helperArray[0]),o.m_from.assign(this.m_helperArray[0]),r.m_next=e))}return t}isDegeneratePath(t,e){if(t.getPathSize(e)===1)return!0;if(this.m_joins===0&&this.m_caps===0){const s=new G;if(t.queryPathEnvelope(e,s),Math.max(s.width(),s.height())<.5*this.m_densifyDist)return!0}return!1}isDegenerateGeometry(t){if(this.m_joins===0&&this.m_caps===0){const e=new G;if(t.queryEnvelope(e),Math.max(e.width(),e.height())<.5*this.m_densifyDist)return!0}return!1}addCircle(t,e){const s=e.getXY();if(this.m_circleTemplate.length!==0){let m=this.m_circleTemplate[0].clone();m.scaleAddThis(this.m_absDistance,s),t.startPath(m);for(let l=1,c=this.m_circleTemplate.length;l<c;l++)m=this.m_circleTemplate[l].clone(),m.scaleAddThis(this.m_absDistance,s),t.lineTo(m);return}const r=this.m_circleTemplateSize,i=Math.trunc((r+3)/4),o=.5*Math.PI/i;t.reserve(4*i);const a=Math.cos(o),u=Math.sin(o);for(let m=3;m>=0;m--){const l=p.construct(0,this.m_absDistance);switch(m){case 0:for(let c=0;c<i;c++)t.lineToCoords(l.x+s.x,l.y+s.y),l.rotateReverse(a,u);break;case 1:for(let c=0;c<i;c++)t.lineToCoords(-l.y+s.x,l.x+s.y),l.rotateReverse(a,u);break;case 2:for(let c=0;c<i;c++)t.lineToCoords(-l.x+s.x,-l.y+s.y),l.rotateReverse(a,u);break;default:t.startPathCoords(l.y+s.x,-l.x+s.y);for(let c=1;c<i;c++)l.rotateReverse(a,u),t.lineToCoords(l.y+s.x,-l.x+s.y)}this.progress_()}}addSquare(t,e){const s=new wt({vd:e.getDescription()});s.setCoords(e.getX(),e.getY(),e.getX(),e.getY()),s.inflateCoords(this.m_absDistance,this.m_absDistance),t.addEnvelope(s,!1)}setStrongSimple(t){return t.getImpl().setIsSimple(4,this.m_tolerance.total()),t.getImpl().updateOGCFlagsProtected(),t}}function Ot(n){return pn(n,0),n}function nn(n,t){return!!n.isEmpty()||Math.min(n.width(),n.height())>t}function Xr(n,t,e,s,r,i,o,a){const u=n.getXY(e),m=n.getXY(s);if(u.equals(m))return-1;const l=.25*o,c=.25*o,f=new p;f.setSub(m,u);const h=f.length(),_=h*h*.25,g=i*i-_;if(g<=_)return-1;const x=Math.sqrt(g);f.normalize();const y=f.clone();y.rightPerpendicularThis();const P=_/x,C=P<=c,v=p.lerp(m,u,.5),D=y.clone(),$=P-l;D.scaleAddThis(Math.max(0,$),v),y.negate().scaleAddThis(x,v);const E=3.61*Ds(i-c),k=D.sub(u),Z=D.sub(m);let J=!1,T=0;const M=dn(64,0);ut(a===M.length);{for(let K=n.getPrevVertexEx(s,r);K!==e;){if(n.getUserIndex(K,t)===1)return-1;if(!n.getXY(K).equals(m))break;{const lt=n.getPrevVertexEx(K,r);n.removeVertex(K,!1),K=lt}}const O=new p,j=u.clone();M[T++]=1;for(let K=n.getNextVertexEx(e,r);K!==s;){if(n.getUserIndex(K,t)===1)return-1;const lt=n.getXY(K);if(lt.equals(j)){const os=n.getNextVertexEx(K,r);n.removeVertex(K,!1),K=os;continue}M[T++]=0;const We=new p;if(We.setSub(lt,u),We.dotProduct(y)<0)return 0;(p.sqrDistance(lt,u)>E||p.sqrDistance(lt,m)>E)&&(J=!0);let At=0;if(lt.sub(u).crossProduct(k)>=0&&(At=1),lt.sub(m).crossProduct(Z)<=0&&(At|=2),At===0)return 0;M[T-1]=At,O.assign(j),j.assign(lt),K=n.getNextVertexEx(K,r)}if(T===1)return 0;ut(T<M.length),M[T++]=2}let A=!0;for(let O=1,j=0;O<T;O++)if(M[O]!==M[O-1]&&(j++,A=j<3&&(j===1&&M[O]===3||j===2&&M[O]===2),!A))return 0;if(T>2&&A&&(T===3||!J)){let O=0,j=n.getNextVertexEx(e,r);for(C||(n.setXY(j,D),j=n.getNextVertexEx(j,r));j!==s;){const K=n.getNextVertexEx(j,r);n.removeVertex(j,!1),j=K,++O}return O}if(ut(T!==3),J&&T>3)return 0;const et=u.clone();let I=e;const Y=u.clone();let nt=1,it=-1,W=I,at=0;for(T=1;W!==s;){W=n.getNextVertexEx(W,r);const O=M[T++];if(O===0){if(W===s)break;continue}const j=n.getXY(W);if(it!==-1){if(3&(it&nt&O)){n.removeVertex(I,!0),at++,I=W,Y.setCoordsPoint2D(j),nt=O;continue}if(nt===3&&it!==0&&O!==0){if(Y.setCoordsPoint2D(D),C||Y.equals(et)){n.removeVertex(I,!0),at++,I=W,Y.setCoordsPoint2D(j),nt=O;continue}n.setXY(I,Y)}}it=nt,et.setCoordsPoint2D(Y),I=W,nt=O,Y.setCoordsPoint2D(j)}return at}function Or(n,t,e,s){let r=-1;const i=new p,o=new p,a=new p;for(let u=0,m=n.getPathSize(s),l=n.getFirstVertex(s);u<m;++u){r===-1&&(n.queryXY(l,o),r=n.getPrevVertex(l),r!==-1&&(n.queryXY(r,i),a.setSub(o,i),a.normalize()));const c=n.getNextVertex(l);if(c===-1)break;const f=n.getXY(c),h=f.sub(o);h.normalize(),r!==-1&&h.dotProduct(a)<-.99&&Math.abs(h.crossProduct(a))<1e-7&&n.setUserIndex(l,t,1),r=l,l=c,i.assign(o),o.assign(f),a.assign(h)}}function jr(n,t,e,s,r,i,o){const a={stack:[],error:void 0,hasError:!1};try{const u=n.getFirstPath(t),m=n.createUserIndex();Jt(a,Ht(()=>{n.removeUserIndex(m)},!1),!1),Or(n,m,t,u);for(let l=0;l<100;++l){if(n.getPathSize(u)===0)return 1;let c=n.getFirstVertex(u),f=n.getPathSize(u);if(f<3)return 1;n.isClosedPath(u)||(f-=1);const h=64;let _=0,g=!1;for(let x=0;x<f&&c!==yt;x++){let y=0,P=c;for(let C=1,v=Math.min(h,f-x);C<v;C++)if(P=n.getNextVertexEx(P,e),C>1){const D=Xr(n,m,c,P,e,r,o,h);if(D===-1)break;y+=D,f-=D}if(_+=y,g=y>0,g){const C=n.getPrevVertexEx(c,e);if(C!==-1){c=C,f++;continue}}c=n.getNextVertexEx(c,e)}if(_===0)break}return n.filterClosePoints(i,!1,!1,!1,-1),1}catch(u){a.error=u,a.hasError=!0}finally{Wt(a)}}function Br(n,t,e,s,r,i,o){return jr(n,t,e,s,r,i,o)}function fe(n,t,e,s){for(let r=0,i=n.getPathCount();r<i;r++){const o=n.getXY(n.getPathStart(r));o.x!==e.xmin&&o.x!==e.xmax&&t.addPath(n,r,s)}}let zr=class{getOperatorType(){return 10004}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s,r,i){return this.executeManyEx(t,e,s,Number.NaN,96,r,i)}execute(t,e,s,r){Number.isFinite(s)||z("Invalid distance for buffer operation");const i=new U([t]),o=[s],a=this.executeMany(i,e,o,!1,r).next();return a||ht("null buffer output"),a}executeManyEx(t,e,s,r,i,o,a){if(s.find(u=>!Number.isFinite(u))!==void 0&&z("Invalid distance for buffer operation"),o){const u=new sn(t,e,s,r,i,!1,a);return new Et().executeMany(u,e,a,2)}return new sn(t,e,s,r,i,!1,a)}},sn=class extends rt{constructor(t,e,s,r,i,o,a){super(),this.m_currentUnionEnvelope2D=new G,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=a,this.m_bufferer=new Yr(a),this.m_inputGeoms=t,this.m_spatialReference=e,this.m_distances=s,this.m_maxDeviation=r,this.m_maxVerticesInFullCircle=i}tock(){return!0}getRank(){return 1}next(){{let t;for(;t=this.m_inputGeoms.next();)return tt(t),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.buffer(t,this.m_distances[this.m_dindex]);return null}}getGeometryID(){return this.m_index}buffer(t,e){return this.m_bufferer.buffer(t,e,this.m_spatialReference,0,0,4,this.m_maxDeviation,this.m_maxVerticesInFullCircle)}};const Ge=new zr;function Lr(n,t,e){return Ge.execute(n,t,e,null)}function Fr(n,t,e,s,r,i){const o=Ge.executeManyEx(new U(n),t,e,s,r,i,null);return Array.from(o)}function Ur(){return Ge.supportsCurves()}function Zr(n,t,e={}){const{unit:s}=e,r=w(n);return s&&(t=st(t,s,r)),R(Lr(b(n),S(r),t),r)}function Jr(n,t,e={}){let{maxDeviation:s=NaN,maxVerticesInFullCircle:r=96,union:i=!1,unit:o}=e;const a=w(n);o&&(t=t.map(m=>st(m,o,a)),s&&(s=st(s,o,a)));const u=n.map(b);return Fr(u,S(a),t,s,r,i).map(m=>R(m,a)).filter(xt)}const Wr=Ur(),ru=Object.freeze(Object.defineProperty({__proto__:null,execute:Zr,executeMany:Jr,supportsCurves:Wr},Symbol.toStringTag,{value:"Module"}));function Kr(n,t){if(!n.isEmpty())switch(n.getGeometryType()){case d.enumPolygon:return Hr(n);case d.enumPolyline:return Qr(n);case d.enumLine:case d.enumBezier:case d.enumEllipticArc:return ti(n);case d.enumMultiPoint:return ei(n);case d.enumEnvelope:return n.getCenterXY();case d.enumPoint:return n.getXY();default:return p.construct(Number.NaN,Number.NaN)}return p.construct(Number.NaN,Number.NaN)}function Hr(n,t=-1){const e=new ft(0),s=new ft(0),r=n.getImpl();let i;const o=r.hasNonLinearSegments();let a;const u=r.getXY(0);if(t===-1){if(a=r.calculateArea2D(),a===0)return an(n);o&&(i=r.querySegmentIterator());for(let c=0,f=r.getPathCount();c<f;c++)rn(u,r,c,e,s),o&&on(u,i,e,s)}else{if(a=r.calculateRingArea2D(t),a===0)return an(n,t);o&&(i=r.querySegmentIterator(),i.resetToPath(t)),rn(u,r,t,e,s),o&&on(u,i,e,s)}const m=new p,l=new p;return m.setCoords(e.getResult(),s.getResult()),l.assign(m.mul(1/a).add(u)),l}function rn(n,t,e,s,r){const i=t.getPathStart(e),o=t.getPathEnd(e);if(o-i<3)return;const a=t.getAttributeStreamRef(0),u=a.readPoint2D(2*i),m=a.readPoint2D(2*(i+1));m.subThis(u);const l=new ft(0),c=t.hasNonLinearSegments(),f=1/3,h=new p;for(let x=i+2;x<o;x++){a.queryPoint2D(2*x,h),h.subThis(u);const y=.5*h.crossProduct(m);c&&l.add(y);const P=f*y;s.add((m.x+h.x)*P),r.add((m.y+h.y)*P),m.setCoordsPoint2D(h)}const _=c?l.getResult():t.calculateRingArea2D(e),g=u.sub(n).mul(_);s.add(g.x),r.add(g.y)}function on(n,t,e,s){let r;for(t.nextPath()||ht("centroid");(r=t.nextCurve())!==null;){const i=r.calculateWeightedAreaCentroid2D(n);e.add(i.x),s.add(i.y)}}function Qr(n){return Kn(n.getImpl())}function ti(n){const t=n.calculateLength2D();return t===0?n.getStartXY():n.calculateWeightedCentroid2D().mul(1/t)}function ei(n){const t=new ft(0),e=new ft(0),s=n.getImpl(),r=s.getAttributeStreamRef(0),i=s.getPointCount(),o=new p;for(let u=0;u<i;u++)r.queryPoint2D(2*u,o),t.add(o.x),e.add(o.y);const a=new p;return a.setCoords(t.getResult(),e.getResult()),a.divThis(i)}function an(n,t=-1){return Kn(n.getImpl(),t)}function Kn(n,t=-1){const e=t===-1?n.calculateLength2D():n.calculatePathLength2D(t);if(e===0)return ni(n,t);const s=new ft(0),r=new ft(0),i=n.querySegmentIterator();for(t!==-1&&i.resetToPath(t);i.nextPath();){const a=i.getPathIndex(),u=n.getXY(n.getPathStart(a));for(;i.hasNextSegment();){const l=i.nextSegment(),c=l.calculateLength2D();if(c===0)continue;const f=l.calculateWeightedCentroid2D().sub(u.mul(c));s.add(f.x),r.add(f.y)}const m=u.mul(n.calculatePathLength2D(a));if(s.add(m.x),r.add(m.y),t!==-1)break}const o=new p;return o.setCoords(s.getResult(),r.getResult()),o.mul(1/e)}function ni(n,t=-1){if(t!==-1)return n.getXY(n.getPathStart(t));const e=new ft(0),s=new ft(0);for(let r=0;r<n.getPathCount();++r){const i=n.getXY(n.getPathStart(r));e.add(i.x),s.add(i.y)}return p.construct(e.getResult(),s.getResult()).mul(1/n.getPathCount())}let si=class{getOperatorType(){return 10205}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}execute(t,e){return Kr(t)}};const Hn=new si;function ri(n){const t=Hn.execute(b(n),null);return ne(t,w(n))}const ii=Hn.supportsCurves(),ou=Object.freeze(Object.defineProperty({__proto__:null,execute:ri,supportsCurves:ii},Symbol.toStringTag,{value:"Module"})),qe=new ws;function oi(n,t,e){return qe.execute(n,t,e,null)}function ai(n,t,e){const s=qe.executeMany(new U(n),t,e,null);return Array.from(s)}function ui(){return qe.supportsCurves()}function mi(n,t){const e=w(n),s=ee(t).asEnvelope2D();return R(oi(b(n),s,S(e)),e)}function ci(n,t){const e=n.map(b),s=w(n),r=ee(t).asEnvelope2D();return ai(e,r,S(s)).map(i=>R(i,s))}const li=ui(),au=Object.freeze(Object.defineProperty({__proto__:null,execute:mi,executeMany:ci,supportsCurves:li},Symbol.toStringTag,{value:"Module"})),Ae=new $s;function hi(n){const t=w(n);return Ae.accelerateGeometry(b(n),S(t),1)}function fi(n,t){return Ae.execute(b(n),b(t),S(n.spatialReference),null)}const _i=Ae.supportsCurves(),uu=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:hi,execute:fi,supportsCurves:_i},Symbol.toStringTag,{value:"Module"}));let gi=class{getOperatorType(){return 10102}supportsCurves(){return!1}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s){return new pi(e,t,s)}execute(t,e){return ts(t)}isConvex(t,e){if(Nt(t),tt(t),t.isEmpty())return!0;const s=t.getGeometryType();if(s===d.enumPoint)return!0;if(s===d.enumEnvelope){const i=t;return i.getXMin()!==i.getXMax()&&i.getYMin()!==i.getYMax()}if(Dt(s)){const i=t;return!i.getStartXY().equals(i.getEndXY())}if(s===d.enumMultiPoint)return t.getPointCount()===1;if(s===d.enumPolyline){const i=t;return i.getPathCount()===1&&i.getPointCount()===2&&!i.getXY(0).equals(i.getXY(1))}if(s===d.enumGeometryCollection){const i=t;return i.getGeometryCount()===1&&this.isConvex(i.getGeometry(0),e)}const r=t;return!(r.getPathCount()!==1||r.getPointCount()<3)&&ve(r,0)}constructOrientedMinimumBoundingBox(t,e,s,r,i){Ms(t,e,s,r,i)}},pi=class extends rt{constructor(t,e,s){super(),e||z(""),this.m_progressTracker=s,this.m_index=-1,this.m_bMerge=t,this.m_bDone=!1,this.m_inputGeometryCursor=e}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}next(){if(this.m_bMerge){if(!this.m_bDone){const t=Qn(this.m_inputGeometryCursor);return this.m_bDone=!0,t}return null}if(!this.m_bDone){const t=this.m_inputGeometryCursor.next();if(t!==null)return Nt(t),tt(t),this.m_index=this.m_inputGeometryCursor.getGeometryID(),ts(t);this.m_bDone=!0}return null}};function Qn(n,t){const e=new Ss;let s;for(;s=n.next();)Nt(s),tt(s),e.addGeometry(s);return e.getBoundingGeometry()}function ts(n,t){if(n||z(""),Nt(n),tt(n),n.isEmpty())return n.createInstance();const e=n.getGeometryType();if(Dt(e)){const s=n;if(s.getStartXY().equals(s.getEndXY())){const r=new X;return s.queryStart(r),r}{const r=new X,i=new F({vd:n.getDescription()});return s.queryStart(r),i.startPathPoint(r),s.queryEnd(r),i.lineToPoint(r),i}}if(e===d.enumEnvelope){const s=n,r=new G;if(s.queryEnvelope(r),r.xmin===r.xmax&&r.ymin===r.ymax){const i=new X;return s.queryCornerByVal(0,i),i}if(r.xmin===r.xmax||r.ymin===r.ymax){const i=new X,o=new F({vd:n.getDescription()});return s.queryCornerByVal(0,i),o.startPathPoint(i),s.queryCornerByVal(1,i),o.lineToPoint(i),o}{const i=new V({vd:n.getDescription()});return i.addEnvelope(s,!1),i}}if(e===d.enumGeometryCollection)return Qn(Ts(n,-1));if(es(n)){if(e===d.enumMultiPoint){const s=n,r=new X;return s.getPointByVal(0,r),r}return n}return Es(n)}function es(n,t){if(Nt(n),tt(n),n.isEmpty())return!0;const e=n.getGeometryType();if(e===d.enumPoint)return!0;if(e===d.enumEnvelope){const r=n;return r.getXMin()!==r.getXMax()&&r.getYMin()!==r.getYMax()}if(Dt(e)){const r=n;return!r.getStartXY().equals(r.getEndXY())}if(e===d.enumMultiPoint)return n.getPointCount()===1;if(e===d.enumPolyline){const r=n;return r.getPathCount()===1&&r.getPointCount()===2&&!r.getXY(0).equals(r.getXY(1))}if(e===d.enumGeometryCollection){const r=n;return r.getGeometryCount()===1&&es(r.getGeometry(0))}const s=n;return!(s.getPathCount()!==1||s.getPointCount()<3)&&ve(s,0)}const ue=new gi;function di(n){return ue.execute(n,null)}function yi(n,t){const e=ue.executeMany(new U(n),t,null);return Array.from(e)}function xi(n){return ue.isConvex(n,null)}function Pi(){return ue.supportsCurves()}function bi(n){const t=w(n);return R(di(b(n)),t)}function Ci(n,t={}){const{merge:e=!1}=t,s=n.map(b),r=w(n);return yi(s,e).map(i=>R(i,r))}function vi(n){return xi(b(n))}const Di=Pi(),lu=Object.freeze(Object.defineProperty({__proto__:null,execute:bi,executeMany:Ci,isConvex:vi,supportsCurves:Di},Symbol.toStringTag,{value:"Module"})),Re=new sr;function wi(n){const t=w(n);return Re.accelerateGeometry(b(n),S(t),1)}function $i(n,t){return Re.execute(b(n),b(t),S(n.spatialReference),null)}const Mi=Re.supportsCurves(),hu=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:wi,execute:$i,supportsCurves:Mi},Symbol.toStringTag,{value:"Module"}));var ns=Gs;function dt(n,t){return{m_geometry:n,m_side:t}}function Si(n,t,e,s,r,i){if(t.isEmpty()){const u=dt(t,0);return void r.push(u)}if(e.isEmpty()){const u=dt(t,0);return void r.push(u)}const o=[],a=new Ct;{const u=a.createGeometryUserIndex(),m=a.addGeometry(t),l=a.addGeometry(e),c=new yn(i);let f=0,h=null;if(a.hasCurves()){h=new ns;const _=a.getEnvelope2D(i);f=Ft(s.total());const g=Ut(s.total(),_);Zt(a,g,s.total(),12e3,h,null,i)}a.dbgVerifyCurves(),c.setEditShapeCrackAndCluster(a,s),c.cut(n,u,m,l,o);for(const _ of o){h!==null&&h.stitchCurves(a,_,f,!1);const g=dt(a.getGeometry(_),Ns(a.getGeometryUserIndex(_,u)));r.push(g)}h!==null&&h.clearStitcher(a)}}function Ti(n,t,e,s,r,i){if(t.isEmpty()){const u=dt(t,0);return void r.push(u)}if(e.isEmpty()){const u=dt(t,0);return void r.push(u)}const o=[],a=new Ct;{const u=a.createGeometryUserIndex(),m=a.addGeometry(t),l=a.addGeometry(e),c=new yn(i);let f=0,h=null;if(a.hasCurves()){h=new ns;const P=a.getEnvelope2D(i);f=Ft(s.total());const C=Ut(s.total(),P);Zt(a,C,s.total(),12e3,h,null,i)}a.dbgVerifyCurves(),c.setEditShapeCrackAndCluster(a,s),c.cut(!1,u,m,l,o),h!==null&&h.stitchCurves(a,yt,f,!0);let _=a.getGeometry(m);const g=new V,x=new V,y=[];for(let P=0;P<o.length;P++){let C=null;{const v=new Ct,D=v.addGeometry(_),$=v.addGeometry(a.getGeometry(o[P]));if(v.hasCurves()){const Z=v.getEnvelope2D(i);f=Ft(s.total());const J=Ut(s.total(),Z);Zt(v,J,s.total(),12e3,h,null,i)}c.setEditShapeCrackAndCluster(v,s);const E=c.intersection(D,$);if(h!==null&&h.stitchCurves(v,yt,f,!0),C=v.getGeometry(E),C.isEmpty())continue;const k=a.getGeometryUserIndex(o[P],u);k===2?g.add(C,!1):k===1?x.add(C,!1):y.push(C)}{const v=new Ct,D=v.addGeometry(_),$=v.addGeometry(a.getGeometry(o[P]));if(v.hasCurves()){const k=v.getEnvelope2D(i);f=Ft(s.total());const Z=Ut(s.total(),k);Zt(v,Z,s.total(),12e3,h,null,i)}c.setEditShapeCrackAndCluster(v,s);const E=c.difference(D,$);h!==null&&h.stitchCurves(v,yt,f,!0),_=v.getGeometry(E)}}if(!_.isEmpty()&&o.length>0&&y.push(_),g.isEmpty()&&x.isEmpty())return;if(!g.isEmpty()){const P=dt(g,1);r.push(P)}if(!x.isEmpty()){const P=dt(x,2);r.push(P)}for(let P=0,C=y.length;P<C;++P){const v=dt(y[P],3);r.push(v)}}}let Ei=class{getOperatorType(){return 10005}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}execute(t,e,s,r,i){return new Ii(t,e,s,r,i)}},Ii=class extends rt{constructor(t,e,s,r,i){super(),this.m_cutIndex=-1,this.m_cuts=[],this.m_progressTracker=i,this.m_cuttee=e.clone(),this.m_cutter=new F({copy:s}),this.m_bConsiderTouch=t;const o=Is(e,s);this.m_tolerance=Qt(r,o,!0)}next(){return this.m_cutIndex===-1&&this.generateCuts(),++this.m_cutIndex<this.m_cuts.length?this.m_cuts[this.m_cutIndex]:null}getGeometryID(){return 0}tock(){return!0}getRank(){return 1}generateCuts(){switch(this.m_cuttee.getGeometryType()){case d.enumPolyline:this.generatePolylineCuts();break;case d.enumPolygon:this.generatePolygonCuts()}}generatePolylineCuts(){const t=new F,e=new F,s=new F;this.m_cuts.length=0,this.m_cuts.push(t),this.m_cuts.push(e);const r=[];Si(this.m_bConsiderTouch,this.m_cuttee,this.m_cutter,this.m_tolerance,r,this.m_progressTracker);for(let i=0;i<r.length;i++){const o=r[i];o.m_side===1?t.add(o.m_geometry,!1):o.m_side===2||o.m_side===4?e.add(o.m_geometry,!1):o.m_side===3?this.m_cuts.push(o.m_geometry):o.m_side===0?s.add(o.m_geometry,!1):ht("")}s.isEmpty()||t.isEmpty()&&e.isEmpty()&&!(this.m_cuts.length>=3)||this.m_cuts.push(s),t.isEmpty()&&e.isEmpty()&&this.m_cuts.length<3&&(this.m_cuts.length=0)}generatePolygonCuts(){const t=new V,e=new V,s=new V;this.m_cuts.length=0,this.m_cuts.push(t),this.m_cuts.push(e);const r=[];Ti(this.m_bConsiderTouch,this.m_cuttee,this.m_cutter,this.m_tolerance,r,this.m_progressTracker);for(let i=0;i<r.length;i++){const o=r[i];o.m_side===1?t.add(o.m_geometry,!1):o.m_side===2?e.add(o.m_geometry,!1):o.m_side===3?this.m_cuts.push(o.m_geometry):o.m_side===0?s.add(o.m_geometry,!1):ht("")}ut(s.isEmpty()||r.length===1),t.isEmpty()&&e.isEmpty()&&this.m_cuts.length<3&&(this.m_cuts.length=0)}};const ss=new Ei;function Ni(n,t,e){const s=ss.execute(!0,n,t,e,null);return Array.from(s)}function Gi(){return ss.supportsCurves()}function qi(n,t){const e=w(n);return Ni(b(n),De(t),S(e)).map(s=>R(s,e)).filter(xt)}const Ai=Gi(),gu=Object.freeze(Object.defineProperty({__proto__:null,execute:qi,supportsCurves:Ai},Symbol.toStringTag,{value:"Module"})),Ve=new gn;function Ri(n,t,e,s){return Ve.execute(n,t,e,s,null)}function Vi(n,t,e,s){const r=Ve.executeMany(new U(n),t,e,s,null);return Array.from(r)}function ki(){return Ve.supportsCurves()}function Yi(n,t,e={}){let{maxAngleInDegrees:s=0,maxDeviation:r=0,unit:i}=e;const o=w(n);return i&&(t=st(t,i,o),r&&(r=st(r,i,o))),R(Ri(b(n),t,r,Ce(s)),o)}function Xi(n,t,e={}){let{maxAngleInDegrees:s=0,maxDeviation:r=0,unit:i}=e;const o=n.map(b),a=w(n);return i&&(t=st(t,i,a),r&&(r=st(r,i,a))),Vi(o,t,r,Ce(s)).map(u=>R(u,a)).filter(xt)}const Oi=ki(),pu=Object.freeze(Object.defineProperty({__proto__:null,execute:Yi,executeMany:Xi,supportsCurves:Oi},Symbol.toStringTag,{value:"Module"})),ke=new qs;function ji(n,t,e){return ke.execute(n,t,e,null)}function Bi(n,t,e){const s=ke.executeMany(new U(n),new U([t]),e,null);return Array.from(s)}function zi(){return ke.supportsCurves()}function Li(n,t){const e=w(n);return R(ji(b(n),b(t),S(e)),e)}function Fi(n,t){const e=n.map(b),s=w(n);return Bi(e,b(t),S(s)).map(r=>R(r,s))}const Ui=zi(),du=Object.freeze(Object.defineProperty({__proto__:null,execute:Li,executeMany:Fi,supportsCurves:Ui},Symbol.toStringTag,{value:"Module"})),Ye=new As;function Zi(n){const t=w(n);return Ye.accelerateGeometry(b(n),S(t),1)}function Ji(n,t){return Ye.execute(b(n),b(t),S(n.spatialReference))}const Wi=Ye.supportsCurves(),yu=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Zi,execute:Ji,supportsCurves:Wi},Symbol.toStringTag,{value:"Module"}));function de(){return{outPoint:new p,index:-1,t:Number.NaN}}function jt(n,t,e){return{outPoint:n.clone(),index:t,t:e}}function B(n,t,e,s){n.outPoint.assign(t),n.index=e,n.t=s}function bt(n,t){n.outPoint.assign(t.outPoint),n.index=t.index,n.t=t.t}function un(n,t,e,s){n.index=e,n.t=s,t.queryCoord2D(n.t,n.outPoint)}function Bt(n,t){const e=de();bt(e,n),bt(n,t),bt(t,e)}function Ki(n,t,e,s,r,i){if(n.getGeometryType()===d.enumPolygon){for(;s.nextPath();)if(s.hasNextSegment()){const o=s.nextSegment();if(vt(n,o.getEndXY(),0)!==0)return B(r,o.getEndXY(),-1,Number.NaN),B(i,o.getEndXY(),-1,Number.NaN),!0}s.resetToFirstPath()}if(t.getGeometryType()===d.enumPolygon){for(;e.nextPath();)if(e.hasNextSegment()){const o=e.nextSegment();if(vt(t,o.getEndXY(),0)!==0)return B(r,o.getEndXY(),-1,Number.NaN),B(i,o.getEndXY(),-1,Number.NaN),!0}e.resetToFirstPath()}return!1}function Hi(n){const t=n.getPathCount(),e=new Array(n.getSegmentCount());let s=0;for(let r=0;r<t;++r){const i=s+n.getSegmentCountPath(r);for(let o=s,a=n.getPathStart(r);o<i;++o,++a)e[o]=a;s=i}return Vs(n.getPointCount(),e),e}function mn(n,t){return!!Number.isNaN(t)||n<=t}function zt(n){const t=new V;return t.addEnvelope(n,!1),t}let Qi=class{constructor(t,e){if(this.m_env2DgeometryA=null,this.m_env2DgeometryB=null,this.m_progressCounter=0,this.m_progressTracker=e,this.m_maxSqrDistance=t*t,this.m_maxDistance=t,this.m_bIsNearCalc=!1,Number.isNaN(this.m_maxDistance)?this.m_maxDistance=Number.POSITIVE_INFINITY:this.m_maxDistance=t,this.m_maxSqrDistance=this.m_maxDistance*this.m_maxDistance,Number.isFinite(this.m_maxSqrDistance)){let s=Math.sqrt(this.m_maxSqrDistance);for(;s<this.m_maxDistance;)this.m_maxSqrDistance*=1+Number.EPSILON,s=Math.sqrt(this.m_maxSqrDistance)}}calculate(t,e,s,r){if((t.getGeometryType()!==X.type||e.getGeometryType()!==X.type)&&(this.m_env2DgeometryA=new G,this.m_env2DgeometryB=new G,t.queryEnvelope(this.m_env2DgeometryA),e.queryEnvelope(this.m_env2DgeometryB),!mn(this.m_env2DgeometryA.distanceFromEnvelope(this.m_env2DgeometryB),this.m_maxDistance)))return Number.POSITIVE_INFINITY;const i=jt(new p,Vt(),Number.NaN),o=jt(new p,Vt(),Number.NaN),a=this._ExecuteBruteForce(t,e,i,o);return mn(a,this.m_maxDistance)?(s!==null&&bt(s,i),r!==null&&bt(r,o),a):Number.POSITIVE_INFINITY}isNear(t,e){if(this.m_bIsNearCalc=!0,t.isEmpty()||e.isEmpty())return!1;if(t===e)return!0;let s=!0;if(t.getGeometryType()!==X.type&&t.getGeometryType()!==wt.type||e.getGeometryType()!==X.type&&e.getGeometryType()!==wt.type||(s=!1),s){if(this.m_env2DgeometryA=new G,this.m_env2DgeometryB=new G,t.queryEnvelope(this.m_env2DgeometryA),e.queryEnvelope(this.m_env2DgeometryB),!(this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)>this.m_maxSqrDistance))return!0;if(this.m_env2DgeometryA.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>this.m_maxSqrDistance)return!1}const r=jt(new p,Vt(),Number.NaN),i=jt(new p,Vt(),Number.NaN);return this._ExecuteBruteForce(t,e,r,i)<=this.m_maxDistance}progress_(t=!1){}_ExecuteBruteForce(t,e,s,r){switch(t.getGeometryType()){case d.enumPoint:return this.distancePointGeometry(t,e,s,r);case d.enumMultiPoint:return this.distanceMultipointGeometry(t,e,s,r);case d.enumEnvelope:return this.distanceEnvelopeGeometry(t,e,s,r);case d.enumPolyline:case d.enumPolygon:return this.distanceMultipathGeometry(t,e,s,r);default:return Number.NaN}}distancePointGeometry(t,e,s,r){switch(e.getGeometryType()){case d.enumPoint:return this.distancePointPoint(t,e,s,r);case d.enumMultiPoint:return this.distancePointMultipoint(t,e,s,r);case d.enumPolyline:case d.enumPolygon:return this.distancePointMultipath(t,e,s,r);case d.enumEnvelope:return this.distancePointEnvelope(t,e,s,r);default:return Number.NaN}}distancePointPoint(t,e,s,r){const i=t.getXY(),o=e.getXY();return B(s,i,0,0),B(r,o,0,0),Math.sqrt(p.sqrDistance(i,o))}distancePointMultipoint(t,e,s,r){const i=t.getXY();let o=this.m_maxSqrDistance,a=o,u=!1;const m=e.getPointCount(),l=new p;for(let c=0;c<m;++c)if(e.queryXY(c,l),a=p.sqrDistance(i,l),this.m_bIsNearCalc){if(a<=o)return 0}else if(!(a>o)&&(!u&&a===o||a<o)&&(o=a,B(s,i,0,0),B(r,l,c,0),u=!0,o===0))return 0;return u?Math.sqrt(o):Number.POSITIVE_INFINITY}distancePointMultipath(t,e,s,r){const i=!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB),o=t.getXY();if(!i&&e.getGeometryType()===d.enumPolygon&&vt(e,o,0)!==0)return B(s,o,0,0),B(r,o,-1,Number.NaN),0;e.getImpl().getAccelerators();let a=this.m_maxSqrDistance,u=a,m=-1;const l=new G,c=e.querySegmentIterator();let f=!1;for(;c.nextPath();)for(;c.hasNextSegment();){const h=c.nextSegment();h.queryEnvelope(l);const _=l.sqrDistance(o);if(_>a||!this.m_bIsNearCalc&&f&&_===a)continue;m=h.getClosestCoordinate(o,!1);const g=h.getCoord2D(m);if(u=p.sqrDistance(o,g),this.m_bIsNearCalc){if(u<=a)return 0}else if(!(u>a)&&(!f||u<a)&&(a=u,B(s,o,0,0),B(r,g,c.getStartPointIndex(),m),f=!0,a===0))return 0}return f?Math.sqrt(a):Number.POSITIVE_INFINITY}distancePointEnvelope(t,e,s,r){const i=t.getXY();B(s,i,0,0),B(r,i,-1,Number.NaN);const o=e.asEnvelope2D();return o.contains(i)?0:Math.sqrt(o.sqrDistance(i,r.outPoint))}distanceMultipointGeometry(t,e,s,r){switch(e.getGeometryType()){case d.enumPoint:{this.m_env2DgeometryB=Q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const i=this.distancePointMultipoint(e,t,r,s);return this.m_env2DgeometryB=Q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),i}case d.enumMultiPoint:return this.distanceMultipointMultipoint(t,e,s,r,1,1);case d.enumPolyline:case d.enumPolygon:return this.distanceMultipointMultipath(t,e,s,r);case d.enumEnvelope:return this.distanceMultipointMultipath(t,zt(e),s,r);default:return Number.NaN}}distanceMultipointMultipoint(t,e,s,r,i,o){const a={stack:[],error:void 0,hasError:!1};try{if(this.m_bIsNearCalc&&i===1&&o===1){const v=Math.trunc(Rt(Math.sqrt(t.getPointCount())+1,1,St())),D=Math.trunc(Rt(Math.sqrt(e.getPointCount())+1,1,St()));if((v>=4||D>=4)&&this.distanceMultipointMultipoint(t,e,s,r,v,D)<=this.m_maxSqrDistance)return 0}let u=this.m_maxSqrDistance;const m=[t],l=[e],c=this.swapGeometriesIfBGtA(m,l);c&&(this.m_env2DgeometryB=Q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),o=Q(i,i=o),Bt(s,r)),Jt(a,Ht(()=>{Bt(s,r),this.m_env2DgeometryB=Q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)},!c),!1);const f=m[0].getImpl(),h=l[0].getImpl(),_=f.getPointCount(),g=h.getPointCount(),x=g>1;let y=!1;const P=new p,C=new p;for(let v=0;v<_;v+=i){if(f.queryXY(v,P),x){const D=this.m_env2DgeometryB.sqrDistance(P);if(this.m_bIsNearCalc){if(D>u)continue;if(this.m_env2DgeometryB.sqrMaxMinDistance(P)<=u)return 0}else if(D>=u)continue}for(let D=0;D<g;D+=o){h.queryXY(D,C);const $=p.sqrDistance(P,C);if(this.m_bIsNearCalc){if($<=u)return 0}else if(!($>u||y&&$===u)&&(!y||$<u)&&(B(s,P,v,0),B(r,C,D,0),y=!0,u=$,u===0))return y?Math.sqrt(u):Number.POSITIVE_INFINITY}}return y?Math.sqrt(u):Number.POSITIVE_INFINITY}catch(u){a.error=u,a.hasError=!0}finally{Wt(a)}}distanceMultipointMultipath(t,e,s,r){let i=!!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)&&e.getGeometryType()===d.enumPolygon;const o=e.querySegmentIterator();o.stripAttributes();const a=new G,u=new p;let m=this.m_maxSqrDistance;const l=t.getImpl(),c=l.getPointCount(),f=c>1;let h=!1;for(;o.nextPath();)for(;o.hasNextSegment();){const _=o.nextSegment();if(_.queryLooseEnvelope(a),f){const g=a.sqrDistanceEnvelope(this.m_env2DgeometryA,null,null);if(this.m_bIsNearCalc){if(g>m)continue}else if(g>m||h&&g===m)continue}for(let g=0;g<c;g++){if(l.queryXY(g,u),i&&vt(e,u,0)!==0)return B(s,u,-1,Number.NaN),B(r,u,g,0),0;{const C=a.sqrDistance(u);if(this.m_bIsNearCalc){if(C>m)continue}else if(C>m)continue}const x=_.getClosestCoordinate(u,!1),y=_.getCoord2D(x);u.subThis(y);const P=u.sqrLength();if(this.m_bIsNearCalc){if(P<=m)return 0}else if(!(P>m)&&(!h||P<m)&&(m=P,B(s,l.getXY(g),g,0),B(r,y,o.getStartPointIndex(),x),h=!0,m===0))return 0}i=!1}return h?Math.sqrt(m):Number.POSITIVE_INFINITY}distanceEnvelopeGeometry(t,e,s,r){switch(e.getGeometryType()){case d.enumPoint:return this.distancePointEnvelope(e,t,r,s);case d.enumMultiPoint:{this.m_env2DgeometryB=Q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const i=this.distanceMultipointMultipath(e,zt(t),r,s);return this.m_env2DgeometryB=Q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),i}case d.enumPolyline:case d.enumPolygon:return this.distanceMultipathMultipath(zt(t),e,s,r);case d.enumEnvelope:return this.distanceEnvelopeEnvelope(t,e,s,r);default:return Number.NaN}}distanceEnvelopeEnvelope(t,e,s,r){s.t=Number.NaN,s.index=-1,r.t=Number.NaN,r.index=-1;const i=t.asEnvelope2D(),o=e.asEnvelope2D();return Math.sqrt(i.sqrDistanceEnvelope(o,s.outPoint,r.outPoint))}distanceMultipathGeometry(t,e,s,r){switch(e.getGeometryType()){case d.enumPoint:{this.m_env2DgeometryB=Q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const i=this.distancePointMultipath(e,t,r,s);return this.m_env2DgeometryB=Q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),i}case d.enumMultiPoint:{this.m_env2DgeometryB=Q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const i=this.distanceMultipointMultipath(e,t,r,s);return this.m_env2DgeometryB=Q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),i}case d.enumPolyline:case d.enumPolygon:return this.distanceMultipathMultipath(t,e,s,r);case d.enumEnvelope:return this.distanceMultipathMultipath(t,zt(e),s,r);default:return Number.NaN}}distanceMultipathMultipath(t,e,s,r){const i={stack:[],error:void 0,hasError:!1};try{const o=[t],a=[e],u=this.swapGeometriesIfAGtB(o,a);u&&(this.m_env2DgeometryB=Q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),Bt(s,r)),Jt(i,Ht(()=>{Bt(s,r),this.m_env2DgeometryB=Q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)},!u),!1);const m=o[0],l=a[0],c=m.querySegmentIterator();c.stripAttributes();const f=l.querySegmentIterator();if(f.stripAttributes(),this.m_bIsNearCalc&&this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)<=this.m_maxSqrDistance)return 0;if(this.m_bIsNearCalc){const $=Math.trunc(Rt(Math.sqrt(m.getPointCount())+1,1,St())),E=Math.trunc(Rt(Math.sqrt(m.getPointCount())+1,1,St()));if(this.distanceMultipointMultipoint(m,l,s,r,$,E)<=this.m_maxSqrDistance)return 0}if(this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)){const $=de(),E=de();if(Ki(m,l,c,f,$,E))return bt(s,$),bt(r,E),0}const h=Hi(m),_=[],g=new Rs,x=new G,y=new G,P=new G;let C=this.m_maxSqrDistance,v=!0,D=!1;for(let $=0,E=h.length;$<E;++$){m.querySegment(h[$],g,!0);const k=g.get();if(k.queryEnvelope(x),!(x.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>C)){if(this.m_bIsNearCalc&&x.sqrMaxDistanceEnvelope(this.m_env2DgeometryB)<=C)return 0;for(;f.nextPath();){if(this.progress_(),v)l.queryPathEnvelope(f.getPathIndex(),P),_[f.getPathIndex()]=P.clone();else if(x.sqrDistanceEnvelope(_[f.getPathIndex()],null,null)>C)continue;for(;f.hasNextSegment();){const Z=f.nextSegment();if(Z.queryEnvelope(y),x.sqrDistanceEnvelope(y,null,null)<=C){const J=!x.isIntersecting(y),T=[0],M=[0];let A=k.distance(Z,J,T,M);if(A*=A,this.m_bIsNearCalc&&A<=this.m_maxSqrDistance)return 0;if(A<C||A===C&&h[$]<s.index){if(D=!0,un(s,k,h[$],T[0]),un(r,Z,f.getStartPointIndex(),M[0]),A===0)return 0;C=A}}}}f.resetToFirstPath(),v=!1}}return D?Math.sqrt(C):Number.POSITIVE_INFINITY}catch(o){i.error=o,i.hasError=!0}finally{Wt(i)}}swapGeometriesIfAGtB(t,e){return tn(t[0])>tn(e[0])&&(e[0]=Q(t[0],t[0]=e[0]),!0)}swapGeometriesIfBGtA(t,e){return this.swapGeometriesIfAGtB(e,t)}},to=class{getOperatorType(){return 10100}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}execute(t,e,s){return this.executeEx(t,e,s,null,null,Number.NaN)}executeEx(t,e,s,r,i,o){if(t.isEmpty()||e.isEmpty())return Number.NaN;tt(t),tt(e);const a=t,u=e;Number.isNaN(o)&&(o=Number.POSITIVE_INFINITY);const m=new Qi(o,s).calculate(a,u,r,i);return Number.isFinite(m)?m:Number.NaN}};const rs=new to;function eo(n,t,e={}){const{unit:s}=e;let r=rs.execute(b(n),b(t),null);if(r&&s){const i=w(n);r=It(r,i,s)}return r}const no=rs.supportsCurves(),bu=Object.freeze(Object.defineProperty({__proto__:null,execute:eo,supportsCurves:no},Symbol.toStringTag,{value:"Module"}));let so=class extends ks{getOperatorType(){return 2}execute(t,e,s,r){return Ys(t,e,s,3,r)}};const Xe=new so;function ro(n){const t=w(n);return Xe.accelerateGeometry(b(n),S(t),1)}function io(n,t){return Xe.execute(b(n),b(t),S(n.spatialReference),null)}const oo=Xe.supportsCurves(),vu=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:ro,execute:io,supportsCurves:oo},Symbol.toStringTag,{value:"Module"})),Oe=new Wn;function ao(n,t,e){return Oe.execute(n,t,e,null)}function uo(n,t,e){const s=Oe.executeMany(new U(n),t,e,null);return Array.from(s)}function mo(){return Oe.supportsCurves()}function co(n,t,e={}){const{removeDegenerateParts:s=!1,unit:r}=e,i=w(n);return r&&(t=st(t,r,i)),R(ao(b(n),t,s),i)}function lo(n,t,e={}){const{removeDegenerateParts:s=!1,unit:r}=e,i=n.map(b),o=w(n);return r&&(t=st(t,r,o)),uo(i,t,s).map(a=>R(a,o)).filter(xt)}const ho=mo(),Du=Object.freeze(Object.defineProperty({__proto__:null,execute:co,executeMany:lo,supportsCurves:ho},Symbol.toStringTag,{value:"Module"})),me=new Xs;function fo(n,t){return me.accelerateGeometry(n,t,1)}function _o(n,t,e){return me.execute(n,t,e,null)}function go(n,t,e,s){const r=me.executeMany(new U(n),new U([t]),e,null,s);return Array.from(r)}function po(){return me.supportsCurves()}function yo(n){const t=w(n);return fo(b(n),S(t))}function xo(n,t){const e=w(n);return R(_o(b(n),b(t),S(e)),e)}function Po(n,t){const e=n.map(b),s=w(n);return go(e,b(t),S(s),7).map(r=>R(r,s)).filter(xt)}const bo=po(),wu=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:yo,execute:xo,executeMany:Po,supportsCurves:bo},Symbol.toStringTag,{value:"Module"})),je=new rr;function Co(n){const t=w(n);return je.accelerateGeometry(b(n),S(t),1)}function vo(n,t){return je.execute(b(n),b(t),S(n.spatialReference),null)}const Do=je.supportsCurves(),$u=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Co,execute:vo,supportsCurves:Do},Symbol.toStringTag,{value:"Module"}));function wo(n,t={}){const{unit:e}=t;let s=b(n).calculateLength2D();if(s&&e){const r=w(n);s=It(s,r,e)}return s}const $o=!0,Mu=Object.freeze(Object.defineProperty({__proto__:null,execute:wo,supportsCurves:$o},Symbol.toStringTag,{value:"Module"}));function Mo(n,t,e,s,r,i){if(n===null&&z(""),n.getDimension()<1&&z(""),r>0||z(""),tt(n),t===0||n.isEmpty())return n;const o=new N(i);return o.m_bUseZ=n.hasAttribute(1),o.m_bUseM=n.hasAttribute(2),o.m_inputGeometry=n,o.m_distance=t,o.m_tolerance=r,o.m_joins=e,o.m_miterLimit=s>1?s:1,o.m_progressCounter=0,o.constructOffset()}const _e=1.4142135623730951,Lt=.017453292519943295,_t=256,ge=512,gt=1024;let pt=class ye{static construct(t,e,s){const r=new ye;return r.x=t.x,r.y=t.y,r.m_next=-1,r.m_prev=-1,r.z=e,r.m=s,r.type=0,r}clone(){const t=new ye;return t.x=this.x,t.y=this.y,t.m_next=this.m_next,t.m_prev=this.m_prev,t.z=this.z,t.m=this.m,t.type=this.type,t}asPoint2D(){return new p(this.x,this.y)}};function So(){return{pt:new pt,bAtExistingPt:!1}}class N{constructor(t){this.m_distance=-1,this.m_tolerance=-1,this.m_miterLimit=10,this.m_joins=0,this.m_progressCounter=0,this.m_bUseZ=!1,this.m_bUseM=!1,this.m_srcPts=[],this.m_srcPtCount=0,this.m_offsetPts=[],this.m_offsetPtCount=0,this.m_a1=0,this.m_a2=0,this.m_progressTracker=t}constructOffset(){const t=this.m_inputGeometry.getGeometryType();if(t===d.enumLine)return this.offsetLine();if(t===d.enumEnvelope)return this.offsetEnvelope();if(Dt(t)){const e=new F;return e.addSegment(this.m_inputGeometry,!0),this.m_inputGeometry=e,this.constructOffset()}if(t===d.enumPolyline){const e=new F;return this.offsetMultiPath(e),e}if(t===d.enumPolygon){const e=new V;return this.offsetMultiPath(e),e}$t("")}offsetLine(){const t=this.m_inputGeometry,e=t.getStartXY(),s=t.getEndXY(),r=new p;r.setSub(s,e),r.normalize(),r.leftPerpendicularThis(),r.scale(this.m_distance),e.addThis(r),s.addThis(r);const i=t.clone();return i.setStartXY(e),i.setEndXY(s),i}offsetEnvelope(){const t=this.m_inputGeometry;if(this.m_distance>0&&this.m_joins!==2){const s=new V;return s.addEnvelope(t,!1),this.m_inputGeometry=s,this.constructOffset()}const e=t.clone();return e.inflateCoords(this.m_distance,this.m_distance),e}progress(){}static buildPoint(t,e,s,r){r.x=t.x+e*Math.cos(s),r.y=t.y+e*Math.sin(s),r.type=t.type,r.z=t.z,r.m=t.m,r.m_next=-1,r.m_prev=-1}addPoint(t){this.m_offsetPts.push(t.clone()),this.m_offsetPtCount++}addPointEx(t,e){if(this.m_offsetPtCount===0)return void this.addPoint(t);const s=this.m_srcPtCount,r=this.m_srcPts[e===0?s-1:e-1],i=this.m_srcPts[e],o=N.dotSign(r,i,this.m_offsetPts[this.m_offsetPtCount-1],t);if(o>0)this.addPoint(t);else if(o<0)if(N.dotSign(r,i,i,this.m_offsetPts[this.m_offsetPtCount-1])>0){const a=new pt;let u;u=e===0?s-2:e===1?s-1:e-2;const m=this.m_srcPts[u],l=Math.atan2(r.y-m.y,r.x-m.x);if(N.buildPoint(r,this.m_distance,l-H,a),this.m_offsetPts[this.m_offsetPtCount-1]=a,this.m_joins===1||this.m_joins===2){a.x=.5*(a.x+r.x),a.y=.5*(a.y+r.y),this.addPoint(a),N.buildPoint(r,this.m_distance,this.m_a1+H,a);const c=a.clone();c.x=.5*(c.x+r.x),c.y=.5*(c.y+r.y),c.type|=_t,this.addPoint(c),this.addPoint(a)}else N.buildPoint(r,this.m_distance,this.m_a1+H,a),a.type|=_t,this.addPoint(a);this.addPointEx(t,e)}else{const a=new pt;if(N.buildPoint(i,this.m_distance,this.m_a1+H,a),this.addPoint(a),this.m_joins===1||this.m_joins===2){a.x=.5*(a.x+i.x),a.y=.5*(a.y+i.y),this.addPoint(a),N.buildPoint(i,this.m_distance,this.m_a2-H,a);const u=a.clone();u.x=.5*(u.x+i.x),u.y=.5*(u.y+i.y),u.type|=_t,this.addPoint(u),this.addPoint(a)}else N.buildPoint(i,this.m_distance,this.m_a2-H,a),a.type|=_t,this.addPoint(a)}}buildOffset(){const t=new pt,e=this.m_srcPtCount;this.m_offsetPtCount=0;const s=.5*this.m_tolerance;let r=0,i=0;for(let o=0;o<e;o++){const a=this.m_srcPts[o],u=o===0?this.m_srcPts[e-1]:this.m_srcPts[o-1],m=o===e-1?this.m_srcPts[0]:this.m_srcPts[o+1];let l,c,f=0;{const _=u.x-a.x,g=u.y-a.y,x=m.x-a.x,y=m.y-a.y;l=Math.atan2(g,_),c=Math.atan2(y,x),this.m_a1=l,this.m_a2=c,o===0&&(r=l,i=c),f=p.orientationRobust(a.asPoint2D(),u.asPoint2D(),m.asPoint2D())}const h=c;if(c<l&&(c+=kt),f*this.m_distance>0)if(this.m_joins===1||this.m_joins===2){N.buildPoint(a,this.m_distance,l+H,t),this.addPoint(t);const _=.001;t.x=a.x+(t.x-a.x)*_,t.y=a.y+(t.y-a.y)*_,this.addPoint(t),N.buildPoint(a,this.m_distance,c-H,t);const g=t.clone();g.x=a.x+(g.x-a.x)*_,g.y=a.y+(g.y-a.y)*_,g.type|=_t,this.addPoint(g),this.addPoint(t)}else{const _=.5*(c-l),g=_===0?this.m_distance:this.m_distance/Math.abs(Math.sin(_));N.buildPoint(a,g,.5*(l+c),t),this.addPointEx(t,o)}else if(a.type&ge){const _=1-s/Math.abs(this.m_distance);let g=1,x=this.m_distance<0?-Math.PI:Math.PI;if(_>-1&&_<1){let C=2*Math.acos(_);C<Lt&&(C=Lt),g=Math.trunc(Math.PI/C+1.5),g>1&&(x/=g)}g<=1&&(g=2,x/=2);let y=l+H;N.buildPoint(a,this.m_distance,y,t),o===0&&(t.type|=gt),this.addPointEx(t,o);const P=this.m_distance/Math.cos(x/2);for(y+=x/2,N.buildPoint(a,P,y,t),t.type|=gt,this.addPoint(t);--g>0;)y+=x,N.buildPoint(a,P,y,t),t.type|=gt,this.addPoint(t);N.buildPoint(a,this.m_distance,c-H,t),t.type|=gt,this.addPoint(t)}else if(this.m_joins!==1)if(this.m_joins!==0)if(this.m_joins!==2){let _;if(c=h,this.m_distance>0?(c>l&&(c-=kt),_=l-c<H):(c<l&&(c+=kt),_=c-l<H),_){const g=this.m_distance*_e;let x;x=g<0?l+.25*Math.PI:l+3*Math.PI*.25,N.buildPoint(a,g,x,t),this.addPointEx(t,o),x=g<0?c-.25*Math.PI:c-3*Math.PI*.25,N.buildPoint(a,g,x,t),this.addPoint(t)}else{const g=.5*(c-l),x=this.m_distance/Math.abs(Math.sin(g));c<l&&(c+=kt),N.buildPoint(a,x,(l+c)/2,t),this.addPointEx(t,o)}}else{const _=u.x-a.x,g=u.y-a.y,x=m.x-a.x,y=m.y-a.y,P=(_*x+g*y)/Math.sqrt(_*_+g*g)/Math.sqrt(x*x+y*y);if(P>1-1e-8){N.buildPoint(a,_e*this.m_distance,c-.25*Math.PI,t),this.addPointEx(t,o),N.buildPoint(a,_e*this.m_distance,c+.25*Math.PI,t),this.addPoint(t);continue}const C=Math.abs(this.m_distance/Math.sin(.5*Math.acos(P))),v=Math.abs(this.m_miterLimit*this.m_distance);if(C>v){const E=.5*(c-l),k=this.m_distance/Math.abs(Math.sin(E));N.buildPoint(a,k,.5*(l+c),t);const Z=p.construct(t.x,t.y),J=p.construct(a.x,a.y),T=new p;T.setSub(Z,J);const M=new p;M.setScaleAdd(v/T.length(),T,J);const A=Math.sqrt(C*C-this.m_distance*this.m_distance),et=(C-v)*Math.abs(this.m_distance)/A;this.m_distance>0?T.leftPerpendicularThis():T.rightPerpendicularThis(),T.scale(et/T.length());const I=new p;I.setAdd(M,T);const Y=new p;Y.setSub(M,T),t.x=I.x,t.y=I.y,this.addPointEx(t,o),t.x=Y.x,t.y=Y.y,this.addPoint(t);continue}const D=.5*(c-l),$=this.m_distance/Math.abs(Math.sin(D));N.buildPoint(a,$,.5*(l+c),t),this.addPointEx(t,o)}else{const _=1-s/Math.abs(this.m_distance);let g=1,x=c-H-(l+H);if(_>-1&&_<1){let C=2*Math.acos(_);C<Lt&&(C=Lt),g=Math.trunc(Math.abs(x)/C+1.5),g>1&&(x/=g)}const y=this.m_distance/Math.cos(.5*x);let P=l+H+.5*x;for(N.buildPoint(a,y,P,t),this.addPointEx(t,o);--g>0;)P+=x,N.buildPoint(a,y,P,t),this.addPoint(t)}else N.buildPoint(a,this.m_distance,l+H,t),this.addPointEx(t,o),N.buildPoint(a,this.m_distance,c-H,t),this.addPoint(t)}return this.m_a1=r,this.m_a2=i,this.addPointEx(this.m_offsetPts[0],0),this.m_offsetPts[0]=this.m_offsetPts[this.m_offsetPtCount-1].clone(),this.removeBadSegsFast()}removeBadSegsFast(){let t=!1;for(let s=0;s<this.m_offsetPtCount;s++){const r=this.m_offsetPts[s];r.m_next=s+1,r.m_prev=s-1}this.m_offsetPts[0].m_prev=this.m_offsetPtCount-2,this.m_offsetPts[this.m_offsetPtCount-2].m_next=0;let e=0;for(let s=0;s<this.m_offsetPtCount;s++)if(this.m_offsetPts[e].type&_t){const r=this.deleteClosedSeg(e);if(r===-1){t=!0;break}e=r}else e=this.m_offsetPts[e].m_next;return!t&&(this.compressOffsetArray(e),!0)}deleteClosedSeg(t){const e=this.m_offsetPtCount-1;let s,r,i=t;for(let o=1;o<=e-2;o++){i=this.m_offsetPts[i].m_next,s=i,r=t;for(let a=1;a<=o;a++){if(r=this.m_offsetPts[r].m_prev,!(this.m_offsetPts[r].type&_t||this.m_offsetPts[s].type&_t)){const u=this.handleClosedIntersection(r,s);if(u!==-1)return u}s=this.m_offsetPts[s].m_prev}}return-1}handleClosedIntersection(t,e){const s=this.m_offsetPts[this.m_offsetPts[t].m_prev],r=this.m_offsetPts[t],i=this.m_offsetPts[this.m_offsetPts[e].m_prev],o=this.m_offsetPts[e];if(!this.sectGraphicRect(s,r,i,o))return-1;const a=So();if(((r.x-s.x)*(o.y-i.y)-(r.y-s.y)*(o.x-i.x))*this.m_distance<0&&this.findIntersection(s,r,i,o,a)&&!a.bAtExistingPt){const m=Math.sqrt((r.x-s.x)*(r.x-s.x)+(r.y-s.y)*(r.y-s.y)),l=(r.x-s.x)/m,c=(r.y-s.y)/m,f=Math.sqrt((o.x-i.x)*(o.x-i.x)+(o.y-i.y)*(o.y-i.y)),h=(o.x-i.x)/f,_=(o.y-i.y)/f;let g=!1;const x=a.pt.clone();x.x+=(l+h)*1e-8,x.y+=(c+_)*1e-8;let y=i,P=a.pt,C=this.m_offsetPts[t].m_prev;for(;P.y>x.y!=y.y>x.y&&x.x<(y.x-P.x)*(x.y-P.y)/(y.y-P.y)+P.x&&(g=!g),y=P,C=this.m_offsetPts[C].m_next,C!==e;)P=this.m_offsetPts[C];if(g)return-1;const v=this.m_offsetPts[t].m_prev;return a.pt.type=r.type,a.pt.m_next=e,a.pt.m_prev=v,this.m_offsetPts[t]=a.pt,this.m_offsetPts[e].m_prev=t,e}return-1}sectGraphicRect(t,e,s,r){return Math.max(t.x,e.x)>=Math.min(s.x,r.x)&&Math.max(s.x,r.x)>=Math.min(t.x,e.x)&&Math.max(t.y,e.y)>=Math.min(s.y,r.y)&&Math.max(s.y,r.y)>=Math.min(t.y,e.y)}findIntersection(t,e,s,r,i){let o,a,u,m;return i.bAtExistingPt=!1,o=(e.y-t.y)*(r.x-s.x)-(e.x-t.x)*(r.y-s.y),a=(s.y-t.y)*(e.x-t.x)-(s.x-t.x)*(e.y-t.y),u=o===0?2:a/o,u>=0&&u<=1&&(m=u,o=(r.y-s.y)*(e.x-t.x)-(r.x-s.x)*(e.y-t.y),a=(t.y-s.y)*(r.x-s.x)-(t.x-s.x)*(r.y-s.y),u=o===0?2:a/o,u>=0&&u<=1)&&(i.pt.x=t.x+u*(e.x-t.x),i.pt.y=t.y+u*(e.y-t.y),this.m_bUseZ&&(i.pt.z=s.z+m*(r.z-s.z)),this.m_bUseM&&(i.pt.m=s.m+m*(r.m-s.m)),m!==0&&m!==1||u!==0&&u!==1||(i.bAtExistingPt=!0),!((m===0||m===1)&&u>0&&u<1||(u===0||u===1)&&m>0&&m<1))}compressOffsetArray(t){for(;this.m_offsetPts[t].m_prev<t;)t=this.m_offsetPts[t].m_prev;let e=0,s=t;do{const r=this.m_offsetPts[s].clone();this.m_offsetPts[e]=r,s=r.m_next,e++}while(s!==t);this.m_offsetPts[e]=this.m_offsetPts[0].clone(),this.m_offsetPtCount=e+1}addPart(t,e){if(!(e<2))for(let s=0;s<e;s++){const r=this.m_offsetPts[t+s];if(s?this.m_bUseZ?this.m_resultPath.lineTo3DCoords(r.x,r.y,r.z):this.m_resultPath.lineToCoords(r.x,r.y):this.m_bUseZ?this.m_resultPath.startPath3DCoords(r.x,r.y,r.z):this.m_resultPath.startPathCoords(r.x,r.y),this.m_bUseM){const i=this.m_resultPath.getPointCount()-1;this.m_resultPath.setAttribute(2,i,0,r.m)}}}offsetMultiPath(t){const e=js(this.m_inputGeometry,0,this.m_tolerance,0,this.m_progressTracker,12e3),s=e.querySegmentIterator();s.resetToFirstPath();let r=-1;for(;s.nextPath();)r++,this.offsetPath(e,r,t)}offsetPath(t,e,s){let r=t.getPathStart(e),i=t.getPathEnd(e);if(this.m_resultPath=s,t.isClosedPath(e)){const o=t.getXY(r);for(;i>r&&t.getXY(i-1).equals(o);)i--;if(i-r>=2){this.m_srcPtCount=i-r,this.m_srcPts.length=this.m_srcPtCount;for(let a=r;a<i;a++)this.progress(),this.m_srcPts[a-r]=pt.construct(t.getXY(a),this.m_bUseZ?t.getAttributeAsDbl(1,a,0):0,this.m_bUseM?t.getAttributeAsDbl(2,a,0):0);this.buildOffset()&&this.addPart(0,this.m_offsetPtCount-1)}}else{const o=t.getXY(r);for(;r<i-1&&t.getXY(r+1).equals(o);)r++;const a=t.getXY(i-1);for(;r<i-1&&t.getXY(i-2).equals(a);)i--;if(i-r>=2){this.m_srcPtCount=2*(i-r)-2,this.m_srcPts.length=this.m_srcPtCount;let u=pt.construct(o,this.m_bUseZ?t.getAttributeAsDbl(1,r,0):0,this.m_bUseM?t.getAttributeAsDbl(2,r,0):0);u.type|=ge+gt,this.m_srcPts[0]=u;let m=1,l=this.m_srcPtCount-1;for(let c=r+1;c<i-1;c++,m++,l--)this.progress(),u=pt.construct(t.getXY(c),this.m_bUseZ?t.getAttributeAsDbl(1,c,0):0,this.m_bUseM?t.getAttributeAsDbl(2,c,0):0),this.m_srcPts[m]=u.clone(),u.type|=gt,this.m_srcPts[l]=u.clone();if(u=pt.construct(t.getXY(i-1),this.m_bUseZ?t.getAttributeAsDbl(1,i-1,0):0,this.m_bUseM?t.getAttributeAsDbl(2,i-1,0):0),u.type|=ge,this.m_srcPts[m]=u.clone(),this.buildOffset())if(this.m_offsetPts.length>=2){let c=-1,f=-1,h=!!(this.m_offsetPts[this.m_offsetPtCount-1].type&gt);h||(c=0);for(let _=1;_<this.m_offsetPtCount;_++){this.progress();const g=!!(this.m_offsetPts[_].type&gt);g?h||(f=_-1,f-c+1>1&&this.addPart(c,f-c+1)):h&&(c=_-1),h=g}h||(f=this.m_offsetPtCount-1,f-c+1>1&&this.addPart(c,f-c+1))}else{const f=this.m_offsetPtCount-1;f-0>=1&&this.addPart(0,f-0+1)}}}this.m_srcPts.length=0,this.m_srcPtCount=0,this.m_offsetPts.length=0,this.m_offsetPtCount=0}static dotSign(t,e,s,r){const i=e.x-t.x,o=e.y-t.y,a=r.x-s.x,u=r.y-s.y,m=Bs(i,o,a,u);return zs(m)}}class To{getOperatorType(){return 10108}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}executeMany(t,e,s,r,i,o,a){return new cn(t,e,s,r,i,o,a)}execute(t,e,s,r,i,o,a){return new cn(null,e,s,r,i,o,a).offset(t)}}class cn extends rt{constructor(t,e,s,r,i,o,a){super(),this.m_progressTracker=a,this.m_index=-1,this.m_inputGeoms=t,this.m_spatialReference=e,this.m_distance=s,this.m_joins=r,this.m_miterLimit=i,this.m_flattenError=o}tock(){return!0}getRank(){return 1}next(){if(!this.m_inputGeoms)return null;let t;for(;t=this.m_inputGeoms.next();)return this.m_index=this.m_inputGeoms.getGeometryID(),this.offset(t);return null}getGeometryID(){return this.m_index}offset(t){let e;return tt(t),e=this.m_flattenError<=0?Os(this.m_spatialReference,t,!0).total():this.m_flattenError,Mo(t,this.m_distance,this.m_joins,this.m_miterLimit,e,this.m_progressTracker)}}const Be=new To;function Eo(n,t,e,s,r,i){return Be.execute(n,t,e,s,r,i,null)}function Io(n,t,e,s,r,i){const o=Be.executeMany(new U(n),t,e,s,r,i,null);return Array.from(o)}function No(){return Be.supportsCurves()}const is={round:0,bevel:1,miter:2,square:3};function Go(n,t,e={}){const{miterLimit:s=10,flattenError:r=0,joins:i="round",unit:o}=e,a=w(n);return o&&(t=st(t,o,a)),R(Eo(b(n),S(a),t,is[i],s,r),a)}function qo(n,t,e={}){const{miterLimit:s=10,flattenError:r=0,joins:i="round",unit:o}=e,a=w(n);o&&(t=st(t,o,a));const u=n.map(b);return Io(u,S(a),t,is[i],s,r).map(m=>R(m,a)).filter(xt)}const Ao=No(),Su=Object.freeze(Object.defineProperty({__proto__:null,execute:Go,executeMany:qo,supportsCurves:Ao},Symbol.toStringTag,{value:"Module"})),ze=new ir;function Ro(n){const t=w(n);return ze.accelerateGeometry(b(n),S(t),1)}function Vo(n,t){return ze.execute(b(n),b(t),S(n.spatialReference),null)}const ko=ze.supportsCurves(),Tu=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Ro,execute:Vo,supportsCurves:ko},Symbol.toStringTag,{value:"Module"}));function ln(){return Pt(new p,-1,Number.NaN)}function Pt(n,t,e){return{m_coordinate:n.clone(),m_vertexIndex:t,m_geometryIndex:0,m_distance:e,m_bRightSide:!1,isEmpty:Yo}}function Yo(){return Number.isNaN(this.m_distance)}function te(n,t,e=-1,s=-1){if(n.isEmpty())return 3;const r=n.getGeometryType();if(Dt(r))return Xo(n,t,e,s);if(r===d.enumPolygon)return Oo(n,t,e,s);if(r===d.enumPolyline)return jo(n,t,e,s);if(r===d.enumEnvelope){const i=new G;return n.queryEnvelope(i),i.contains(t)?i.containsExclusive(t)?1:2:0}return 3}function Xo(n,t,e,s){if(e>=0||s>=0)return z("");if(n.isDegenerate(0))return n.getStartXY().equals(t)?2:3;if(!n.isCurve()){const u=p.orientationRobust(t,n.getStartXY(),n.getEndXY());return u<0?1:u>0?0:2}const r=n.getClosestCoordinate(t,!1),i=n.getTangent(r),o=n.getCoord2D(r),a=p.orientationRobust(t,o,o.add(i));return a<0?1:a>0?0:2}function Oo(n,t,e,s){(e>=0||s>=0)&&z("");const r=new G;n.queryEnvelope(r);const i=vt(n,t,0);return i===0?0:i===1?1:2}function jo(n,t,e,s){(e<0&&s>=0||e>=0&&s<0)&&z("");const r=n.querySegmentIterator();if(e<0){let o=Number.MAX_VALUE,a=0;for(;r.nextPath();)for(;r.hasNextSegment();){const u=r.nextSegment(),m=u.getClosestCoordinate(t,!1),l=u.getCoord2D(m),c=p.sqrDistance(l,t);c<o?(a=1,e=r.getStartPointIndex(),s=r.getPathIndex(),o=c):c===o&&a++}if(a===0)return 3;if(a===1)return r.resetToVertex(e,s),te(r.nextSegment(),t)}const i=Fo(t,r,e,s);if(i.i1!==-1&&i.i2===-1)return i.bRight1?1:0;if(i.i1!==-1&&i.i2!==-1){if(i.bRight1===i.bRight2)return i.bRight1?1:0;{r.resetToVertex(i.i1,-1);const o=r.nextSegment().getTangent(1);r.resetToVertex(i.i2,-1);const a=r.nextSegment().getTangent(0);return o.crossProduct(a)>=0?1:0}}return r.resetToVertex(e,s),te(r.nextSegment(),t)}function Bo(n,t,e){for(n.resetToVertex(t,e);n.hasNextSegment();)if(!n.nextSegment().isDegenerate(0))return n.getStartPointIndex();for(n.resetToVertex(t,e);n.hasPreviousSegment();)if(!n.previousSegment().isDegenerate(0))return n.getStartPointIndex();return-1}function zo(n,t){for(n.resetToVertex(t,-1),n.nextSegment();n.hasNextSegment();)if(!n.nextSegment().isDegenerate(0))return n.getStartPointIndex();return-1}function Lo(n,t){for(n.resetToVertex(t,-1);n.hasPreviousSegment();)if(!n.previousSegment().isDegenerate(0))return n.getStartPointIndex();return-1}function Fo(n,t,e,s){const r={i1:-1,i2:-1,bRight1:!1,bRight2:!1};if(r.i1=Bo(t,e,s),r.i1!==-1){t.resetToVertex(r.i1,-1);const i=t.nextSegment(),o=i.getClosestCoordinate(n,!1),a=i.getCoord2D(o),u=p.sqrDistance(a,n);{const m=a.clone();m.subThis(i.getStartXY());const l=n.clone();l.subThis(i.getStartXY()),r.bRight1=m.crossProduct(l)<0}if(r.i2=zo(t,r.i1),r.i2!==-1){t.resetToVertex(r.i2,-1);const m=t.nextSegment(),l=m.getClosestCoordinate(n,!1),c=m.getCoord2D(l);if(p.sqrDistance(c,n)>u)r.i2=-1;else{const f=c.clone();f.subThis(m.getStartXY());const h=n.clone();h.subThis(m.getStartXY()),r.bRight2=f.crossProduct(h)<0}}if(r.i2===-1&&(r.i2=Lo(t,r.i1),r.i2!==-1)){t.resetToVertex(r.i2,-1);const m=t.nextSegment(),l=m.getClosestCoordinate(n,!1),c=m.getCoord2D(l);if(p.sqrDistance(c,n)>u)r.i2=-1;else{const f=c.clone();f.subThis(m.getStartXY());const h=n.clone();h.subThis(m.getStartXY()),r.bRight2=f.crossProduct(h)<0;const _=r.i1;r.i1=r.i2,r.i2=_;const g=r.bRight1;r.bRight1=r.bRight2,r.bRight2=g}}}return r}let Uo=class{getOperatorType(){return 10500}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}getNearestCoordinate(t,e,s,r){if(e.isNAN()&&z("NAN xy coordinates are not allowed"),t.isEmpty())return ln();switch(t.getGeometryType()){case d.enumPoint:return this.pointGetNearestVertex(t,e);case d.enumMultiPoint:return this.multiVertexGetNearestVertex(t,e);case d.enumPolyline:case d.enumPolygon:return this.multiPathGetNearestCoordinate(t,e,s,r);default:$t("")}}getNearestVertex(t,e){if(e.isNAN()&&z("NAN xy coordinates are not allowed"),t.isEmpty())return ln();switch(t.getGeometryType()){case d.enumPoint:return this.pointGetNearestVertex(t,e);case d.enumMultiPoint:case d.enumPolyline:case d.enumPolygon:return this.multiVertexGetNearestVertex(t,e);default:$t("")}}getNearestVertices(t,e,s,r){if(r===0&&z(""),e.isNAN()&&z("NAN xy coordinates are not allowed"),t.isEmpty())return[];switch(t.getGeometryType()){case d.enumPoint:return this.pointGetNearestVertices(t,e,s,r);case d.enumMultiPoint:case d.enumPolyline:case d.enumPolygon:return this.multiVertexGetNearestVertices(t,e,s,r);default:$t("")}}multiPathGetNearestCoordinate(t,e,s,r){if(t.getGeometryType()===d.enumPolygon&&s){const f=new G;t.queryEnvelope(f);const h=Ls(null,f,!1);let _;if(_=vt(t,e,r?0:h),_!==0){const g=Pt(e,-1,0);return r&&(g.m_bRightSide=!0),g}}const i=t.querySegmentIterator(),o=new p;let a=-1,u=-1,m=Number.MAX_VALUE,l=0;for(;i.nextPath();)for(;i.hasNextSegment();){const f=i.nextSegment(),h=f.getClosestCoordinate(e,!1),_=f.getCoord2D(h),g=p.sqrDistance(_,e);g<m?(l=1,o.assign(_),a=i.getStartPointIndex(),u=i.getPathIndex(),m=g):g===m&&l++}a===-1&&z("");const c=Pt(o,a,Math.sqrt(m));if(r)if(t.getGeometryType()!==d.enumPolygon){let f=!1;if(l>1){const h=te(t,e,a,u);f=h!==0&&h!==3}else{i.resetToVertex(a,u);const h=i.nextSegment();f=te(h,e)!==0}c.m_bRightSide=f}else s||vt(t,e,0)!==0&&(c.m_bRightSide=!0);return c}pointGetNearestVertex(t,e){const s=t.getXY(),r=p.distance(s,e);return Pt(s,0,r)}multiVertexGetNearestVertex(t,e){const s=t.getAttributeStreamRef(0),r=t.getPointCount();let i=-1;const o=new p;let a=Number.MAX_VALUE;const u=new p;for(let m=0;m<r;m++){s.queryPoint2D(2*m,u);const l=p.sqrDistance(u,e);l<a&&(o.assign(u),i=m,a=l)}return Pt(o,i,Math.sqrt(a))}pointGetNearestVertices(t,e,s,r){const i=[];if(r!==0){const o=s*s,a=t.getXY(),u=p.sqrDistance(a,e);u<=o&&i.push(Pt(a,0,Math.sqrt(u)))}return i}multiVertexGetNearestVertices(t,e,s,r){const i=[];if(r!==0){const o=t.getAttributeStreamRef(0),a=t.getPointCount();i.length=r+1;const u=s*s;for(let m=0;m<a;m++){const l=o.read(2*m),c=o.read(2*m+1),f=e.x-l,h=e.y-c,_=f*f+h*h;_<=u&&i.push(Pt(p.construct(l,c),m,Math.sqrt(_)))}i.sort((m,l)=>m.m_distance-l.m_distance)}return i.slice(0,r)}};function Le(n,t,e=!1){const s=ne(n.m_coordinate,w(t)),r=n.m_distance,i=n.isEmpty(),o=n.m_bRightSide;return{coordinate:s,distance:r,isEmpty:i,...e&&{isRightSide:o},vertexIndex:n.m_vertexIndex}}const ce=new Uo;function Zo(n,t,e={}){const{calculateLeftRightSide:s=!1,testPolygonInterior:r=!0,unit:i}=e,o=ce.getNearestCoordinate(b(n),Gt(t).getXY(),r,s);if(i&&o.m_distance){const a=w(n);o.m_distance=It(o.m_distance,a,i)}return Le(o,n,s)}function Jo(n,t,e={}){const{unit:s}=e,r=ce.getNearestVertex(b(n),Gt(t).getXY());if(s&&r.m_distance){const i=w(n);r.m_distance=It(r.m_distance,i,s)}return Le(r,n)}function Wo(n,t,e,s,r={}){const{unit:i}=r,o=w(n);return i&&e&&(e=st(e,i,o)),ce.getNearestVertices(b(n),Gt(t).getXY(),e,s).map(a=>(i&&a.m_distance&&(a.m_distance=It(a.m_distance,o,i)),Le(a,n)))}const Ko=ce.supportsCurves(),Iu=Object.freeze(Object.defineProperty({__proto__:null,getNearestCoordinate:Zo,getNearestVertex:Jo,getNearestVertices:Wo,supportsCurves:Ko},Symbol.toStringTag,{value:"Module"}));let Ho=class{supportsCurves(){return!0}getOperatorType(){return 1}execute(t,e,s,r,i){return Fs(t,e,s,r,i)}isValidDE9IM(t){return Us(t)===0}accelerateGeometry(t,e,s){return Zs(t,e,s)}canAccelerateGeometry(t){return Js(t)}};const le=new Ho;function Qo(n){const t=w(n);return le.accelerateGeometry(b(n),S(t),1)}function ta(n,t,e){return le.execute(b(n),b(t),S(n.spatialReference),e,null)}function ea(n){return le.isValidDE9IM(n)}const na=le.supportsCurves(),Gu=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Qo,execute:ta,isValidDE9IM:ea,supportsCurves:na},Symbol.toStringTag,{value:"Module"})),he=new Tt;function sa(n,t,e){return he.execute(n,t,e,null)}function ra(n,t,e){const s=he.executeMany(new U(n),t,e,null);return Array.from(s)}function ia(n,t,e){return he.isSimpleAsFeature(n,t,e,null,null)}function oa(){return he.supportsCurves()}function aa(n){const t=w(n);return R(sa(b(n),S(t),!1),t)}function ua(n){const t=n.map(b),e=w(n);return ra(t,S(e),!1).map(s=>R(s,e))}function ma(n){return ia(b(n),S(w(n)),!1)}const ca=oa(),qu=Object.freeze(Object.defineProperty({__proto__:null,execute:aa,executeMany:ua,isSimple:ma,supportsCurves:ca},Symbol.toStringTag,{value:"Module"}));class la{getOperatorType(){return 10003}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s,r){return new _a(t,e,s,r)}execute(t,e,s,r){const i=new U([t]),o=new U([e]),a=this.executeMany(i,o,s,r).next();return a||ht("null output"),a}}function ha(n,t,e,s){const r=n.getDimension(),i=t.getDimension();if(r!==i)return r>i?n:t;if(n.isEmpty())return t;if(t.isEmpty())return n;const o=new G,a=new G,u=new G;n.queryEnvelope(o),t.queryEnvelope(a),u.setCoords({env2D:o}),u.mergeEnvelope2D(a);const m=Qt(e,u,!0),l=n.getGeometryType(),c=t.getGeometryType();return l===d.enumPoint&&c===d.enumPoint?fa(n,t,m):l===d.enumPoint&&c===d.enumMultiPoint?hn(t,n,m):l===d.enumMultiPoint&&c===d.enumPoint?hn(n,t,m):Ws(n,t,e,s)}function fa(n,t,e,s){const r=xn(e),i=r*r,o=n.getXY(),a=t.getXY(),u=new fn({vd:n.getDescription()});return p.sqrDistance(o,a)>i&&(u.add(n),u.add(t)),u}function hn(n,t,e,s){const r=n.getImpl().getAttributeStreamRef(0),i=n.getPointCount(),o=t.getXY(),a=n.createInstance(),u=xn(e),m=new G;if(n.queryEnvelope(m),m.inflateCoords(u,u),m.contains(o)){const l=u*u;let c=!1;const f=dn(i,!1);for(let h=0;h<i;h++){const _=r.read(2*h),g=r.read(2*h+1),x=_-o.x,y=g-o.y;x*x+y*y<=l&&(c=!0,f[h]=!0)}if(c)for(let h=0;h<i;h++)f[h]||a.addPoints(n,h,h+1);else a.addPoints(n,0,i),a.add(t)}else a.addPoints(n,0,i),a.add(t);return a}class _a extends rt{constructor(t,e,s,r){super(),this.m_progressTracker=r,this.m_index=-1,this.m_inputGeoms=t,this.m_spatialReference=s,this.m_rightGeom=e.next(),this.m_bEmpty=!this.m_rightGeom,tt(this.m_rightGeom)}tock(){return!0}getRank(){return 1}next(){if(this.m_bEmpty)return null;const t=this.m_inputGeoms.next();return t?(tt(t),this.m_index=this.m_inputGeoms.getGeometryID(),ha(t,this.m_rightGeom,this.m_spatialReference,this.m_progressTracker)):null}getGeometryID(){return this.m_index}}const Fe=new la;function ga(n,t,e){return Fe.execute(n,t,e,null)}function pa(n,t,e){const s=Fe.executeMany(new U(n),new U([t]),e,null);return Array.from(s)}function da(){return Fe.supportsCurves()}function ya(n,t){const e=w(n);return R(ga(b(n),b(t),S(e)),e)}function xa(n,t){const e=n.map(b),s=w(n);return pa(e,b(t),S(s)).map(r=>R(r,s)).filter(xt)}const Pa=da(),Au=Object.freeze(Object.defineProperty({__proto__:null,execute:ya,executeMany:xa,supportsCurves:Pa},Symbol.toStringTag,{value:"Module"})),Ue=new or;function ba(n){const t=w(n);return Ue.accelerateGeometry(b(n),S(t),1)}function Ca(n,t){return Ue.execute(b(n),b(t),S(n.spatialReference),null)}const va=Ue.supportsCurves(),Ru=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:ba,execute:Ca,supportsCurves:va},Symbol.toStringTag,{value:"Module"})),Ze=new Et;function Da(n,t,e){return Ze.execute(n,t,e,null)}function wa(n,t){return Ze.executeMany(new U(n),t,null).next()}function $a(){return Ze.supportsCurves()}function Ma(n,t){const e=w(n);return R(Da(b(n),b(t),S(e)),e)}function Sa(n){const t=n.map(b),e=w(n);return R(wa(t,S(e)),e)}const Ta=$a(),Vu=Object.freeze(Object.defineProperty({__proto__:null,execute:Ma,executeMany:Sa,supportsCurves:Ta},Symbol.toStringTag,{value:"Module"})),Je=new ar;function Ea(n){const t=w(n);return Je.accelerateGeometry(b(n),S(t),1)}function Ia(n,t){return Je.execute(b(n),b(t),S(n.spatialReference),null)}const Na=Je.supportsCurves(),ku=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Ea,execute:Ia,supportsCurves:Na},Symbol.toStringTag,{value:"Module"}));function Yu(n,t,e,s){const r=new Er().rotate(t,e,s);return hr(n,r)}async function Xu(){await Promise.all([Yn(),Gn(),Bn(),Jn()])}export{Ka as area,ru as buffer,ou as centroid,au as clip,uu as contains,lu as convexHull,hu as crosses,gu as cut,pu as densify,du as difference,yu as disjoint,bu as distance,vu as equals,Du as generalize,Fa as geodesicBuffer,Ua as geodeticArea,Za as geodeticDensify,Ja as geodeticLength,wu as intersection,$u as intersects,Mu as length,Xu as loadAll,Su as offset,Tu as overlaps,Iu as proximity,Gu as relate,Yu as rotate,qu as simplify,Au as symmetricDifference,Ru as touches,Vu as union,ku as within};
