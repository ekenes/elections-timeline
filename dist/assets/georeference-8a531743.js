import{i5 as wt,i6 as tt,i7 as bt,i8 as St,i9 as f,S as Nt,fB as Lt,ia as b,ib as Bt,hI as gt,ax as O,ic as jt,id as It,ie as qt,cl as zt,he as Vt,n as h,q as _,t as Wt,aB as Gt,ig as Ht,az as yt,ck as S,ih as Ut,ii as mt,h_ as nt,ij as kt,m as $t,eB as V,ik as rt,en as et,em as ot,il as Dt,c2 as Qt,im as Yt,bN as Kt,bO as Jt,hb as G,io as ht,ip as at,iq as Xt,cq as Zt,aQ as tn,ir as nn,is as rn,fH as en,it as on}from"./index-575386f8.js";import{e as At}from"./mat3f64-221ce671.js";import{e as v,o as q}from"./mat4f64-1413b4a7.js";import{c as w}from"./spatialReferenceEllipsoidUtils-b62d8001.js";import{m as an,p as sn,t as it,o as ln}from"./MeshLocalVertexSpace-6eac68f1.js";import{m as cn}from"./MeshGeoreferencedRelativeVertexSpace-8c232b65.js";import{v as D,y as un,x as fn}from"./quat-d9861b3f.js";import{e as J}from"./quatf64-3363c48e.js";import{n as M,s as Pt,r as d}from"./vec32-9dfc9f2f.js";import{i as F,T}from"./BufferView-9d570ec0.js";function Ft(t,n,r){const e=Math.sin(t),o=Math.cos(t),a=Math.sin(n),s=Math.cos(n),i=r;return i[0]=-e,i[4]=-a*o,i[8]=s*o,i[12]=0,i[1]=o,i[5]=-a*e,i[9]=s*e,i[13]=0,i[2]=0,i[6]=s,i[10]=a,i[14]=0,i[3]=0,i[7]=0,i[11]=0,i[15]=1,i}function pn(t,n,r){return Ft(t,n,r),wt(r,r),r}function W(t,n,r,e){if(t==null||e==null)return!1;const o=tt(t,bt),a=tt(e,St);if(o===a&&!st(a)&&(o!==f.UNKNOWN||Nt(t,e)))return Lt(r,n),!0;if(st(a)){const s=b[o][f.LON_LAT],i=b[f.LON_LAT][a];return s!=null&&i!=null&&(s(n,0,A,0),i(A,0,P,0),Ft(N*A[0],N*A[1],r),r[12]=P[0],r[13]=P[1],r[14]=P[2],!0)}if((a===f.WEB_MERCATOR||a===f.PLATE_CARREE)&&(o===f.WGS84||o===f.CGCS2000&&a===f.PLATE_CARREE||o===f.SPHERICAL_ECEF||o===f.WEB_MERCATOR)){const s=b[o][f.LON_LAT],i=b[f.LON_LAT][a];return s!=null&&i!=null&&(s(n,0,A,0),i(A,0,P,0),o===f.SPHERICAL_ECEF?pn(N*A[0],N*A[1],r):Bt(r),r[12]=P[0],r[13]=P[1],r[14]=P[2],!0)}return!1}function st(t){return t===f.SPHERICAL_ECEF||t===f.SPHERICAL_MARS_PCPF||t===f.SPHERICAL_MOON_PCPF}const N=gt(1),A=O(),P=O();function C(t=Tt){return[t[0],t[1],t[2],t[3]]}function z(t,n,r=C()){return zt(r,t),r[3]=n,r}function lt(t,n,r=C()){return D(L,t,Q(t)),D(ct,n,Q(n)),un(L,ct,L),yn(r,Vt(fn(r,L)))}function Qn(t,n,r,e=C()){return z(jt,t,B),z(It,n,ut),z(qt,r,ft),lt(B,ut,B),lt(B,ft,e),e}function Yn(t){return t}function gn(t){return t[3]}function Q(t){return gt(t[3])}function yn(t,n){return t[3]=n,t}const Tt=[0,0,1,0],L=J(),ct=J();C();const B=C(),ut=C(),ft=C();var Y;let m=Y=class extends Gt{constructor(t){super(t),this.translation=O(),this.rotationAxis=Ht(Tt),this.rotationAngle=0,this.scale=yt(1,1,1)}get rotation(){return z(this.rotationAxis,this.rotationAngle)}set rotation(t){this.rotationAxis=S(t),this.rotationAngle=gn(t)}get localMatrix(){const t=v();return D(pt,this.rotation,Q(this.rotation)),Ut(t,pt,this.translation,this.scale),t}get localMatrixInverse(){return mt(v(),this.localMatrix)}applyLocal(t,n){return nt(n,t,this.localMatrix)}applyLocalInverse(t,n){return nt(n,t,this.localMatrixInverse)}equals(t){return this===t||t!=null&&kt(this.localMatrix,t.localMatrix)}clone(){const t={translation:S(this.translation),rotationAxis:S(this.rotationAxis),rotationAngle:this.rotationAngle,scale:S(this.scale)};return new Y(t)}};h([_({type:[Number],nonNullable:!0,json:{write:!0}})],m.prototype,"translation",void 0),h([_({type:[Number],nonNullable:!0,json:{write:!0}})],m.prototype,"rotationAxis",void 0),h([_({type:Number,nonNullable:!0,json:{write:!0}})],m.prototype,"rotationAngle",void 0),h([_({type:[Number],nonNullable:!0,json:{write:!0}})],m.prototype,"scale",void 0),h([_()],m.prototype,"rotation",null),h([_()],m.prototype,"localMatrix",null),h([_()],m.prototype,"localMatrixInverse",null),m=Y=h([Wt("esri.geometry.support.MeshTransform")],m);const pt=J(),mn=m;function _t(t,n){return t.isGeographic||t.isWebMercator&&((n==null?void 0:n.geographic)??!0)}function Kn(t,n,r){const e=!t.isGeoreferenced;(r==null?void 0:r.geographic)!=null&&r.geographic!==e&&$t.getLogger(n).warnOnce(`Specifying the 'geographic' parameter (${r.geographic}) for a Mesh vertex space of type "${t.type}" is not supported. This parameter will be ignored.`)}const H=$t.getLogger("esri.geometry.support.meshUtils.normalProjection");function $n(t,n,r,e,o){return k(e)?(U($.TO_PCPF,F.fromTypedArray(t),T.fromTypedArray(n),T.fromTypedArray(r),e,F.fromTypedArray(o)),o):(H.error("Cannot convert spatial reference to PCPF"),o)}function hn(t,n,r,e,o){return k(e)?(U($.FROM_PCPF,F.fromTypedArray(t),T.fromTypedArray(n),T.fromTypedArray(r),e,F.fromTypedArray(o)),o):(H.error("Cannot convert to spatial reference from PCPF"),o)}function An(t,n,r){return V(t,n,0,r,w(n),0,t.length/3),r}function Pn(t,n,r){return V(t,w(r),0,n,r,0,t.length/3),n}function Fn(t,n,r){return G(u,r),M(n,t,u),ht(u)||Pt(n,n),n}function Tn(t,n,r){if(G(u,r),M(n,t,u,4),ht(u)||Pt(n,n,4),t!==n)for(let e=3;e<t.length;e+=4)n[e]=t[e];return n}function _n(t,n,r,e,o){if(!k(e))return H.error("Cannot convert spatial reference to PCPF"),o;U($.TO_PCPF,F.fromTypedArray(t,4*Float32Array.BYTES_PER_ELEMENT),T.fromTypedArray(n),T.fromTypedArray(r),e,F.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT));for(let a=3;a<t.length;a+=4)o[a]=t[a];return o}function Rn(t,n,r,e,o){if(!k(e))return H.error("Cannot convert to spatial reference from PCPF"),o;U($.FROM_PCPF,F.fromTypedArray(t,16),T.fromTypedArray(n),T.fromTypedArray(r),e,F.fromTypedArray(o,16));for(let a=3;a<t.length;a+=4)o[a]=t[a];return o}function U(t,n,r,e,o,a){if(!n)return;const s=r.count,i=w(o);if(Rt(o))for(let l=0;l<s;l++)e.getVec(l,j),n.getVec(l,y),W(i,j,I,i),rt(u,I),t===$.FROM_PCPF&&et(u,u),ot(y,y,u),a.setVec(l,y);else for(let l=0;l<s;l++){e.getVec(l,j),n.getVec(l,y),W(i,j,I,i),rt(u,I);const c=Dt(r.get(l,1));let p=Math.cos(c);t===$.TO_PCPF&&(p=1/p),u[0]*=p,u[1]*=p,u[2]*=p,u[3]*=p,u[4]*=p,u[5]*=p,t===$.FROM_PCPF&&et(u,u),ot(y,y,u),Qt(y,y),a.setVec(l,y)}return a}function k(t){return Rt(t)||Cn(t)}function Rt(t){return t.isWGS84||Yt(t)||Kt(t)||Jt(t)}function Cn(t){return t.isWebMercator}var $;(function(t){t[t.TO_PCPF=0]="TO_PCPF",t[t.FROM_PCPF=1]="FROM_PCPF"})($||($={}));const j=O(),y=O(),I=v(),u=At();function X(t,n,r){return _t(n.spatialReference,r)?dn(t,n,r):vn(t,n,r)}function Ct(t,n,r,e){const{position:o,normal:a,tangent:s}=t;if(!n.isRelative)return{position:o,normal:a,tangent:s};const i=(r==null?void 0:r.localMatrix)??q;return X({position:d(new Float64Array(o.length),o,i),normal:a!=null?Fn(a,new Float32Array(a.length),i):null,tangent:s!=null?Tn(s,new Float32Array(s.length),i):null},n.getOriginPoint(e),{geographic:!n.isGeoreferenced})}function Mn(t,n,r){if(r!=null&&r.useTransform){const{position:e,normal:o,tangent:a}=t,{x:s,y:i,z:l}=n,c=yt(s,i,l??0);return{vertexAttributes:{position:e,normal:o,tangent:a},vertexSpace:r.geographic??1?new an({origin:c}):new cn({origin:c}),transform:new mn}}return{vertexAttributes:X(t,n,r),vertexSpace:new sn,transform:null}}function K(t,n,r){return _t(n.spatialReference,r)?Sn(t,n,r):Mt(t,n,r)}function xn(t,n,r,e,o){if(!n.isRelative)return K(t,e,o);const{spatialReference:a}=e,s=Ct(t,n,r,a);return e.equals(n.getOriginPoint(a))?Mt(s,e,o):K(s,e,o)}function En({positions:t,transform:n,vertexSpace:r,inSpatialReference:e,outSpatialReference:o,outPositions:a,local:s}){const i=r.isRelative?r.origin:at,l=r.isRelative?(n==null?void 0:n.localMatrix)??q:q;if(r.isGeoreferenced){const g=a??it(t.length);if(Xt(l,q)?ln(g,t):d(g,t,l),!Zt(i,at)){const[vt,dt,Ot]=i;for(let E=0;E<g.length;E+=3)g[E]+=vt,g[E+1]+=dt,g[E+2]+=Ot}return V(g,e,0,g,o,0,g.length/3),g}const c=w(e),p=!s&&tn(e,c)?c:e;W(e,i,R,p),nn(R,R,l);const x=a??it(t.length);return d(x,t,R),V(x,p,0,x,o,0,x.length/3),x}function vn(t,n,r){const e=new Float64Array(t.position.length),o=t.position,a=n.x,s=n.y,i=n.z??0,l=Z(r?r.unit:null,n.spatialReference);for(let c=0;c<o.length;c+=3)e[c]=o[c]*l+a,e[c+1]=o[c+1]*l+s,e[c+2]=o[c+2]*l+i;return{position:e,normal:t.normal,tangent:t.tangent}}function dn(t,n,r){const e=n.spatialReference,o=xt(n,r,R),a=new Float64Array(t.position.length),s=On(t.position,o,e,a),i=G(Et,o);return{position:s,normal:wn(s,a,t.normal,i,e),tangent:bn(s,a,t.tangent,i,e)}}function On(t,n,r,e){d(e,t,n);const o=new Float64Array(t.length);return Pn(e,o,r)}function wn(t,n,r,e,o){if(r==null)return null;const a=new Float32Array(r.length);return M(a,r,e),hn(a,t,n,o,a),a}function bn(t,n,r,e,o){if(r==null)return null;const a=new Float32Array(r.length);M(a,r,e,4);for(let s=3;s<a.length;s+=4)a[s]=r[s];return Rn(a,t,n,o,a),a}function Mt(t,n,r){const e=new Float64Array(t.position.length),o=t.position,a=n.x,s=n.y,i=n.z??0,l=Z(r?r.unit:null,n.spatialReference);for(let c=0;c<o.length;c+=3)e[c]=(o[c]-a)/l,e[c+1]=(o[c+1]-s)/l,e[c+2]=(o[c+2]-i)/l;return{position:e,normal:t.normal,tangent:t.tangent}}function Sn(t,n,r){const e=n.spatialReference;xt(n,r,R);const o=mt(jn,R),a=new Float64Array(t.position.length),s=Nn(t.position,e,o,a),i=G(Et,o);return{position:s,normal:Ln(t.normal,t.position,a,e,i),tangent:Bn(t.tangent,t.position,a,e,i)}}function xt(t,n,r){W(t.spatialReference,[t.x,t.y,t.z??0],r,w(t.spatialReference));const e=Z(n?n.unit:null,t.spatialReference);return rn(r,r,[e,e,e]),r}function Nn(t,n,r,e){const o=An(t,n,e),a=new Float64Array(o.length);return d(a,o,r),a}function Ln(t,n,r,e,o){if(t==null)return null;const a=$n(t,n,r,e,new Float32Array(t.length));return M(a,a,o),a}function Bn(t,n,r,e,o){if(t==null)return null;const a=_n(t,n,r,e,new Float32Array(t.length));return M(a,a,o,4),a}function Z(t,n){if(t==null)return 1;const r=en(n);return 1/on(r,"meters",t)}const R=v(),jn=v(),Et=At(),Jn=Object.freeze(Object.defineProperty({__proto__:null,georeference:X,georeferenceApplyTransform:Ct,georeferenceByTransform:Mn,project:En,ungeoreference:K,ungeoreferenceByTransform:xn},Symbol.toStringTag,{value:"Module"}));export{K as B,xn as D,En as E,W as L,mn as N,Pn as O,_n as R,X as U,Ct as V,hn as _,C as a,lt as b,Jn as c,Qn as g,An as h,$n as j,Yn as l,Kn as o,Mn as q,_t as r,Rn as v,Q as w};
