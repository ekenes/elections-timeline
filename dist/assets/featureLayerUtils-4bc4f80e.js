import{g as K,B as Y,p as f,k as _,l as T,u as $,a as v,f as u,h as k,s as p,i as b}from"./index-9b3f7302.js";import{i as P}from"./originUtils-1469eeaf.js";import{I as z,c as E,y as L,b as G,d as j,w as V,s as N,u as q,p as I}from"./utils-4c1d31d5.js";import{r as C}from"./fetchService-59ada81e.js";import{o as g}from"./jsonContext-bb6bbd6d.js";import"./multiOriginJSONSupportUtils-c978f4c3.js";const m="Feature Service",h="feature-layer-utils",H=`${h}-save`,Q=`${h}-save-as`,y=`${h}-saveall`,d=`${h}-saveall-as`;function w(a){return{isValid:k(a)&&(a.type!=="feature"||!a.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function x(a){const e=[],r=[];for(const{layer:n,layerJSON:o}of a)n.isTable?r.push(o):e.push(o);return{layers:e,tables:r}}function O(a){return x([a])}async function J(a,e){return/\/\d+\/?$/.test(a.url)?O(e[0]):M(e,a)}async function M(a,e){if(!e)return x(a);const{layer:{url:r,customParameters:n,apiKey:o}}=a[0];let t=await e.fetchData("json");t&&t.layers!=null&&t.tables!=null||(t=await W(t,{url:r??"",customParameters:n,apiKey:o},a.map(s=>s.layer.layerId)));for(const s of a)R(s.layer,s.layerJSON,t);return t}async function W(a,e,r){a||(a={}),a.layers||(a.layers=[]),a.tables||(a.tables=[]);const{url:n,customParameters:o,apiKey:t}=e,{serviceJSON:s,layersJSON:l}=await C(n,{customParameters:o,apiKey:t}),i=S(a.layers,s.layers,r),c=S(a.tables,s.tables,r);a.layers=i.itemResources,a.tables=c.itemResources;const F=[...i.added,...c.added],B=l?[...l.layers,...l.tables]:[];return await X(a,F,n,B),a}function S(a,e,r){const n=K(a,e,(t,s)=>t.id===s.id);a=a.filter(t=>!n.removed.some(s=>s.id===t.id));const o=n.added.map(({id:t})=>({id:t}));return o.forEach(({id:t})=>{a.push({id:t})}),{itemResources:a,added:o.filter(({id:t})=>!r.includes(t))}}async function X(a,e,r,n){const o=e.map(({id:t})=>new Y({url:r,layerId:t,sourceJSON:n.find(({id:s})=>s===t)}));await Promise.allSettled(o.map(t=>t.load())),o.forEach(t=>{const{layerId:s,loaded:l,defaultPopupTemplate:i}=t;!l||i==null||R(t,{id:s,popupInfo:i.toJSON()},a)})}function R(a,e,r){a.isTable?A(r.tables,e):A(r.layers,e)}function A(a,e){const r=a.findIndex(({id:n})=>n===e.id);r===-1?a.push(e):a[r]=e}function D(a,e){if(!a.length)throw new p(`${e}:missing-parameters`,"'layers' array should contain at least one feature layer")}function Z(a,e){const r=a.map(n=>n.portalItem.id);if(new Set(r).size>1)throw new p(`${e}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function U(a,e){const r=a.map(n=>n.layerId);if(new Set(r).size!==r.length)throw new p(`${e}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function aa(a){D(a,y),await Promise.all(a.map(e=>e.load()));for(const e of a)N(e,y,w),q(e,y,m);Z(a,y),U(a,y)}async function ea(a,e){const{url:r,layerId:n,title:o,fullExtent:t,isTable:s}=a,l=f(r);e.url=(l==null?void 0:l.serverType)==="FeatureServer"?r:`${r}/${n}`,e.title||(e.title=o),e.extent=null,s||t==null||(e.extent=await T(t)),$(e,u.METADATA),$(e,u.MULTI_LAYER),b(e,u.SINGLE_LAYER),s&&b(e,u.TABLE)}function ta(a,e){for(const t of a){const s=t.parsedUrl.path,l=f(s);if(!(l==null?void 0:l.url.path))throw new p(`${e}:invalid-parameters`,I(t,`has unsupported url pattern: ${s}`),{layer:t});const c=l==null?void 0:l.serverType;if(c!=="FeatureServer"&&c!=="MapServer")throw new p(`${e}:invalid-parameters`,I(t,`has unsupported server type: ${c}`),{layer:t});if(c==="MapServer"&&a.length>1)throw new p(`${e}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const r=f(a[0].parsedUrl.path),n=r==null?void 0:r.url.path;if(!a.every(t=>{const s=f(t.parsedUrl.path);return(s==null?void 0:s.url.path)===n}))throw new p(`${e}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function ra(a){D(a,d),await Promise.all(a.map(e=>e.load()));for(const e of a)N(e,d,w);ta(a,d),U(a,d)}async function sa(a,e){let r=0,n=0;for(const{isTable:s}of e)s?n++:r++;const o=e[0].parsedUrl.path,t=f(o);if(a.url=(t==null?void 0:t.serverType)==="FeatureServer"?t.url.path:o,a.title||(a.title=t.title),a.extent=null,r>0){const s=e.map(l=>l.fullExtent).filter(_).reduce((l,i)=>l.clone().union(i));s&&(a.extent=await T(s))}$(a,u.METADATA),v(a,u.MULTI_LAYER,e.length>1),v(a,u.SINGLE_LAYER,e.length===1),v(a,u.TABLE,n>0&&r===0),L(a)}async function pa(a,e){return z({layer:a,itemType:m,validateLayer:w,createItemData:(r,n)=>J(n,[r]),errorNamePrefix:H},e)}async function ya(a,e){await aa(a);const r=a[0].portalItem,n=g(r),o=await Promise.all(a.map(s=>E(s,n,e))),t=await J(r,a.map((s,l)=>({layer:s,layerJSON:o[l]})));return L(r),await r.update({data:t}),await Promise.all(a.slice(1).map(s=>s.portalItem.reload())),P(n),r.clone()}async function da(a,e,r){return G({layer:a,itemType:m,validateLayer:w,createItemData:(n,o)=>Promise.resolve(O(n)),errorNamePrefix:Q,newItem:e,setItemProperties:ea},r)}async function fa(a,e,r){await ra(a);const n=j(e,d,m),o=g(n),t=await Promise.all(a.map(l=>E(l,o,r))),s=await M(a.map((l,i)=>({layer:l,layerJSON:t[i]})));await sa(n,a),await V(n,s,r);for(const l of a)l.portalItem=n.clone();return P(o),n}export{pa as save,ya as saveAll,fa as saveAllAs,da as saveAs};
