import{aP as v,eN as Z,a5 as Q,iY as x,aU as A,iZ as I,ae as f,Y as u,ab as l,f2 as X,b6 as ss,g as es,fx as ts,bA as os,fn as as,a8 as ns}from"./index-b8632133.js";import{h as rs,a as is,i as _,o as E,A as cs}from"./MeshTransform-a1db6c51.js";import{r as ls,n as ps,a as us,d as ms,c as U,l as fs,t as ds,u as gs,p as hs}from"./uploadAssetErrors-85b2c223.js";import{s as ws,u as k,i as ys}from"./infoFor3D-24efd44a.js";import{i as Ps,n as Ts}from"./meshFeatureAttributes-709fcee4.js";import"./mat4f64-9a8384aa.js";import"./quat-870db343.js";import"./mat3f64-e19cdcb8.js";import"./quatf64-81e039e4.js";const $={upload:{createFromFiles:.8,loadMesh:.2},uploadAssetBlobs:{prepareAssetItems:.9,uploadAssetItems:.1},uploadConvertibleSource:{uploadEditSource:.5,serviceAssetsToGlb:.5},uploadLocalMesh:{meshToAssetBlob:.5,uploadAssetBlobs:.5}};function w(e,t=o=>{},s){return new bs(e,t,s)}let bs=class{constructor(t,s=a=>{},o){if(this.onProgress=s,this.taskName=o,this._progressMap=new Map,this._startTime=void 0,this._timingsMap=new Map,typeof t=="number"){this._weights={};for(let a=0;a<t;a++){const n=a,r=1/t;this._weights[n]=r,this._progressMap.set(n,0)}}else this._weights=t;this.emitProgress()}emitProgress(){let t=0;for(const[s,o]of this._progressMap.entries())t+=o*this._weights[s];if(t===1&&v("enable-feature:esri-3dofl-upload-timings")){const s=Math.round(performance.now()-(this._startTime??0))/1e3;console.log(`${this.taskName} done in ${s} sec`);for(const[o,a]of this._timingsMap){const n=Math.round(a.end-a.start)/1e3,r=Math.round(n/s*100);console.log(this.taskName??"Task",{stepKey:o,stepTime:n,relativeTime:r})}}this.onProgress(t)}setProgress(t,s){if(this._progressMap.set(t,s),v("enable-feature:esri-3dofl-upload-timings")){const o=performance.now();this._startTime??(this._startTime=o);const a=Z(this._timingsMap,t,()=>({start:o,end:0}));s===1&&(a.end=o)}this.emitProgress()}simulate(t,s){return D(o=>this.setProgress(t,o),s)}makeOnProgress(t){return s=>this.setProgress(t,s)}};function D(e=s=>{},t=Ns){const s=performance.now();e(0);const o=setInterval(()=>{const a=performance.now()-s,n=1-Math.exp(-a/t);e(n)},js);return Q(()=>{clearInterval(o),e(1)})}function As(e,t=Ms){return x(I(e*O/t))}function $s(e,t=Fs){return x(I(e*O/t))}const Ms=10,Fs=10,O=8e-6,js=A(50),Ns=A(1e3),R=1e6,S=20*R,vs=2e9,Ss=3;async function xs({data:e,name:t,description:s},o,a){let n=null;try{const r=f(o,"uploads"),i=f(r,"info"),{data:c}=await u(i,{query:{f:"json"},responseType:"json"});l(a);const d=X(o),g=c.maxUploadFileSize*R,h=d?vs:g,m=d?Math.min(S,g):S;if(e.size>h)throw new Error("Data too large");const L=f(r,"register"),{data:M}=await u(L,{query:{f:"json",itemName:Is(t),description:s},responseType:"json",method:"post"});if(l(a),!M.success)throw new Error("Registration failed");const{itemID:H}=M.item;n=f(r,H);const G=f(n,"uploadPart"),F=Math.ceil(e.size/m),y=new Array;for(let p=0;p<F;++p)y.push(e.slice(p*m,Math.min((p+1)*m,e.size)));const P=y.slice().reverse(),j=new Array,J=w(F,a==null?void 0:a.onProgress,"uploadItem"),W=async()=>{for(;P.length!==0;){const p=y.length-P.length,T=P.pop(),b=new FormData,K=J.simulate(p,As(T.size));try{b.append("f","json"),b.append("file",T),b.append("partId",`${p}`);const{data:V}=await u(G,{timeout:0,body:b,responseType:"json",method:"post"});if(l(a),!V.success)throw new Error("Part upload failed")}finally{K.remove()}}};for(let p=0;p<Ss&&P.length!==0;++p)j.push(W());await Promise.all(j);const Y=f(n,"commit"),{data:N}=await u(Y,{query:{f:"json",parts:y.map((p,T)=>T).join(",")},responseType:"json",method:"post"});if(l(a),!N.success)throw new Error("Commit failed");return N.item}catch(r){if(n!=null){const i=f(n,"delete");await u(i,{query:{f:"json"},responseType:"json",method:"post"})}throw r}}function Is(e){return e.replaceAll("/","_").replaceAll("\\","_")}async function le(e,t,s){var n;const o=e.length;if(!o)return(n=s==null?void 0:s.onProgress)==null||n.call(s,1),[];const a=w(o,s==null?void 0:s.onProgress,"uploadAssets");return Promise.all(e.map((r,i)=>_s(r,t,{...s,onProgress:a.makeOnProgress(i)})))}async function _s(e,{layer:t,ongoingUploads:s},o){var r;const a=s.get(e);if(a)return a;if(!Vs(t))throw new ls;if(Es(e,t))return(r=o==null?void 0:o.onProgress)==null||r.call(o,1),e;const n=Us(e,t,o);s.set(e,n);try{await n}finally{s.delete(e)}return e}function Es(e,t){const{parsedUrl:s}=t;return s!=null&&e.metadata.externalSources.some(o=>rs(o,s))}async function Us(e,t,s){const{metadata:o}=e,{displaySource:a}=o,n=B(a==null?void 0:a.source,t),r=!!n,i=o.externalSources.length>0,c=r?ks(n,t,s):i?Ds(e,t,s):Os(e,t,s),d=await c;return l(s),e.addExternalSources([d]),e}async function ks(e,t,s){return{source:await C(e,t,s),original:!0}}async function Ds(e,t,s){const o=z(t),{externalSources:a}=e.metadata,n=Bs(a,t);if(!n)throw new ps;const r=w($.uploadConvertibleSource,s==null?void 0:s.onProgress,"uploadConvertibleSource"),i=await C(n,t,{onProgress:r.makeOnProgress("uploadEditSource")});e.addExternalSources([{source:i,original:!0}]);const c=n.reduce((g,{asset:h})=>h instanceof File?g+h.size:g,0),d=r.simulate("serviceAssetsToGlb",$s(c));try{const{source:g,transform:h,origin:m}=await Js(i,t,o);return h&&(e.transform=h),m&&(s!=null&&s.useAssetOrigin)&&(e.vertexSpace.origin=[m.x,m.y,m.z??0],e.spatialReference=m.spatialReference),{source:g}}finally{d.remove()}}async function Os(e,t,s){const o=w($.uploadLocalMesh,s==null?void 0:s.onProgress,"uploadLocalMesh"),a=Rs(e,t,{...s,onProgress:o.makeOnProgress("meshToAssetBlob")});return{source:await q([a],t,{...s,onProgress:o.makeOnProgress("uploadAssetBlobs")}),extent:e.extent.clone(),original:!0}}async function Rs(e,t,s){const o=z(t),a=await e.load(s),n=await a.toBinaryGLTF({origin:a.origin,signal:s==null?void 0:s.signal,ignoreLocalTransform:!0});return l(s),{blob:new Blob([n],{type:"model/gltf-binary"}),assetName:`${ss()}.glb`,assetType:o}}function Bs(e,t){for(const s of e){const o=B(s.source,t);if(o)return o}return null}function B(e,t){if(!e)return null;const{infoFor3D:{supportedFormats:s,editFormats:o}}=t,a=cs(e),n=new Array;let r=!1;for(let i=0;i<a.length;++i){const c=Cs(a[i],s);if(!c)return null;o.includes(c.assetType)&&(r=!0),n.push(c)}return r?n:null}function Cs(e,t){const s=is(e,t);return s?{asset:e,assetType:s}:null}async function C(e,t,s){return q(e.map(o=>qs(o,s)),t,s)}async function q(e,t,s){const o=w($.uploadAssetBlobs,s==null?void 0:s.onProgress,"uploadAssetBlobs"),a=await Ls(e,t,{...s,onProgress:o.makeOnProgress("prepareAssetItems")});l(s);const n=a.map(({item:i})=>i),{uploadResults:r}=await Hs(n,t,{...s,onProgress:o.makeOnProgress("uploadAssetItems")});return l(s),e.map((i,c)=>Gs(a[c],r[c],t))}async function qs(e,t){const{asset:s,assetType:o}=e;if(s instanceof File)return{blob:s,assetName:s.name,assetType:o};const a=await s.toBlob(t);return l(t),{blob:a,assetName:s.assetName,assetType:o}}async function zs(e,t,s){const{blob:o,assetType:a,assetName:n}=e;let r=null;try{const i=await xs({data:o,name:n},t.url,s);l(s),r={assetType:a,assetUploadId:i.itemID}}catch(i){os(i),Zs().warnOnce(`Service ${t.url} does not support the REST Uploads API.`)}if(!r){const i=await as(o);if(l(s),!i.isBase64)throw new gs;r={assetType:a,assetData:i.data}}if(!r)throw new hs;return{item:r,assetName:n}}function Ls(e,t,s){const o=w(e.length,s==null?void 0:s.onProgress,"prepareAssetItems");return Promise.all(e.map(async(a,n)=>{const r=zs(await a,t,{...s,onProgress:o.makeOnProgress(n)});return l(s),r}))}async function Hs(e,t,s){const o=D(s==null?void 0:s.onProgress);try{const a=await u(f(t.parsedUrl.path,"uploadAssets"),{timeout:0,query:{f:"json",assets:JSON.stringify(e)},method:"post",responseType:"json"});if(l(s),a.data.uploadResults.length!==e.length)throw new us(e.length,a.data.uploadResults.length);return a.data}finally{o.remove()}}function Gs(e,t,s){const{success:o}=t;if(!o){const{error:d}=t;throw new ms(e.assetName,d)}const{assetHash:a}=t,{assetName:n,item:{assetType:r}}=e,{infoFor3D:{supportedFormats:i}}=s,c=ws(r,i);if(!c)throw new U(r);return new _(n,c,[new E(`${s.parsedUrl.path}/assets/${a}`,a)])}async function Js(e,t,s){var n;const o=e.map(({assetName:r,parts:i})=>({assetName:r,assetHash:i[0].partHash}));let a;try{const r=f(t.parsedUrl.path,"convert3D"),i=(n=t.capabilities)==null?void 0:n.operations.supportsAsyncConvert3D;a=(await(i?Ks:Ys)(r,{query:{f:"json",assets:JSON.stringify(o),transportType:"esriTransportTypeUrl",targetFormat:s,async:i},responseType:"json",timeout:0})).data}catch{throw new fs}return Ws(a,t.infoFor3D)}function Ws(e,{supportedFormats:t}){const s={source:e.assets.map(o=>{const a=k(o.contentType,t);if(!a)throw new U(a);return new _(o.assetName,o.contentType,[new E(o.assetURL,o.assetHash)])})};if(e.transform&&(s.transform=Ps(e.transform),e.spatialReference)){const o=es.fromJSON(e.spatialReference);s.origin=Ts(e.transform,o)}return s}function Ys(e,t){return u(e,t)}async function Ks(e,t){const s=(await u(e,t)).data.statusUrl;for(;;){const o=(await u(s,{query:{f:"json"},responseType:"json"})).data;switch(o.status){case"Completed":return u(o.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new Error(o.status);case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new Error}await ts(Qs)}}function Vs(e){return!!e.infoFor3D&&!!e.url}function z(e){const{infoFor3D:t}=e,s=k("model/gltf-binary",t.supportedFormats)??ys("glb",t.supportedFormats);if(!s)throw new ds;return s}function Zs(){return ns.getLogger("esri.layers.graphics.sources.support.uploadAssets")}const Qs=A(1e3);export{le as uploadAssets};
