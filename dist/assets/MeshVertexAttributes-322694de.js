import{r as n,q as u,fq as p,w as v,S as A,$ as g,a8 as i}from"./index-02eff6e6.js";function m(t,o,r,a){const{loggerTag:s,stride:l}=o;return t.length%l!=0?(a.error(s,`Invalid array length, expected a multiple of ${l}`),new r([])):t}function c(t,o,r,a,s){if(!t)return t;if(t instanceof o)return m(t,a,o,s);for(const l of r)if(t instanceof l)return m(new o(t),a,o,s);if(Array.isArray(t))return m(new o(t),a,o,s);{const l=r.map(d=>`'${d.name}'`);return s.error(`Failed to set property, expected one of ${l}, but got ${t.constructor.name}`),new o([])}}function y(t,o,r){o[r]=f(t)}function f(t){const o=new Array(t.length);for(let r=0;r<t.length;r++)o[r]=t[r];return o}var h;let e=h=class extends A{constructor(t){super(t),this.color=null,this.position=new Float64Array(0),this.uv=null,this.normal=null,this.tangent=null}castColor(t){return c(t,Uint8Array,[Uint8ClampedArray],{loggerTag:".color=",stride:4},g.getLogger(this))}castPosition(t){return t&&t instanceof Float32Array&&g.getLogger(this).warn(".position=","Setting position attribute from a Float32Array may cause precision problems. Consider storing data in a Float64Array or a regular number array"),c(t,Float64Array,[Float32Array],{loggerTag:".position=",stride:3},g.getLogger(this))}castUv(t){return c(t,Float32Array,[Float64Array],{loggerTag:".uv=",stride:2},g.getLogger(this))}castNormal(t){return c(t,Float32Array,[Float64Array],{loggerTag:".normal=",stride:3},g.getLogger(this))}castTangent(t){return c(t,Float32Array,[Float64Array],{loggerTag:".tangent=",stride:4},g.getLogger(this))}clone(){const t={position:i(this.position),uv:i(this.uv),normal:i(this.normal),tangent:i(this.tangent),color:i(this.color)};return new h(t)}clonePositional(){const t={position:i(this.position),normal:i(this.normal),tangent:i(this.tangent),uv:this.uv,color:this.color};return new h(t)}get usedMemory(){var t,o,r,a;return this.position.byteLength+(((t=this.uv)==null?void 0:t.byteLength)??0)+(((o=this.normal)==null?void 0:o.byteLength)??0)+(((r=this.tangent)==null?void 0:r.byteLength)??0)+(((a=this.color)==null?void 0:a.byteLength)??0)}};n([u({json:{write:y}})],e.prototype,"color",void 0),n([p("color")],e.prototype,"castColor",null),n([u({nonNullable:!0,json:{write:y}})],e.prototype,"position",void 0),n([p("position")],e.prototype,"castPosition",null),n([u({json:{write:y}})],e.prototype,"uv",void 0),n([p("uv")],e.prototype,"castUv",null),n([u({json:{write:y}})],e.prototype,"normal",void 0),n([p("normal")],e.prototype,"castNormal",null),n([u({json:{write:y}})],e.prototype,"tangent",void 0),n([p("tangent")],e.prototype,"castTangent",null),e=h=n([v("esri.geometry.support.MeshVertexAttributes")],e);export{c as n,e as p,y as r};
