import{r as R,q as I,eJ as ge,w as re,S as Je,kp as Pe,c0 as K,kq as Re,$ as ee,y as be,Y as E,B as V,s as G,U as Ie,fn as He,C as we,ij as Ce,cx as De,_ as $e,bF as Be,ff as ze,aW as Ne,z as Me,bK as Oe}from"./index-c2b82012.js";import{a as Ee,c as We,N as ae,l as Ae,d as Le,b as qe,g as Ge,e as oe,W as le,z as je,L as Ve,U as Ue,E as Qe,q as ce,t as Ke}from"./ImageHistogramParameters-c824bf14.js";import{h as Se,w as Xe,a as Ye,i as Ze,p as ve,d as ue,o as et,f as he,g as tt}from"./rasterFieldUtils-de2f9fda.js";import{j as it,n as nt,m as rt,_ as st}from"./RasterSymbolizer-4caa33d2.js";import{i as de,m as me,x as fe,h as at,s as ot}from"./RawBlockCache-b0ad0cc5.js";import{U as Y,D as _e,R as lt,u as ct,l as ut,a as ht,f as dt,s as mt}from"./dataUtils-30595099.js";import{t as U,C as te,B as pe,m as ye,u as ft,o as Z,V as Q,a as pt,r as yt,z as xt,Z as ie}from"./rasterProjectionHelper-3b406a77.js";import{h as ne,l as gt,T as Rt}from"./rasterFunctionHelper-5c2eca28.js";const xe=8,bt=256;let It=0,_=class extends Je{constructor(){super(...arguments),this._tileFetchQueue=new Pe({concurrency:32,process:(t,i)=>this._fetchRawTile(t.pyramidLevel,t.row,t.col,{...t.options,signal:i})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(t){return t!=null&&t.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:K.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,i=U(t.spatialReference);return i!=null&&t.extent.width>=i/2}get _hasNoneOrGCSShiftTransform(){const{transform:t}=this.rasterInfo;return t==null||t.type==="gcs-shift"}set rasterJobHandler(t){var i,a;this._set("rasterJobHandler",t),this.datasetFormat==="Function"&&((a=(i=this.primaryRasters)==null?void 0:i.rasters)==null||a.forEach(e=>e.rasterJobHandler=t))}get rasterId(){return this.url||"rasterId-"+It++}set url(t){this._set("url",Re(t,ee.getLogger(this)))}async open(t){return this._openPromise??(this._openPromise=te().then(()=>this._open(t))),this._openPromise}async fetchTile(t,i,a,e={}){const n=e.tileInfo||this.rasterInfo.storageInfo.tileInfo,r=this.getTileExtentFromTileInfo(t,i,a,n);return e={noClip:!0,...e},this.fetchPixels(r,n.size[0],n.size[1],e)}async identify(t,i={}){var A;t=be(E,t).clone().normalize();const{multidimensionalDefinition:a,timeExtent:e}=i,{rasterInfo:n}=this,{hasMultidimensionalTranspose:r,multidimensionalInfo:s}=n;let{transposedVariableName:o}=i;const c=s!=null&&r&&(e!=null||Se(a));c&&!o&&(o=a!=null&&a.length>0?a[0].variableName??void 0:s.variables[0].name,i={...i,transposedVariableName:o}),i=this._getRequestOptionsWithSliceId(i);const{spatialReference:l,extent:u}=n,{datumTransformation:m}=i;let d=pe(t,l,m);if(!u.intersects(d))return{location:d,value:null};if(n.transform!=null){const B=n.transform.inverseTransform(d);if(!n.nativeExtent.intersects(B))return{location:B,value:null};d=B}let y=0;const x=o!=null&&s!=null&&n.hasMultidimensionalTranspose;if(this.datasetFormat==="Function"){const B=this.primaryRasters.rasters[0];if(x)return B.identify(d,i);const{pixelSize:L}=n,v=3,T=L.x*v/2,z=L.y*v/2,N=new V({xmin:d.x-T,xmax:d.x+T,ymin:d.y-z,ymax:d.y+z,spatialReference:l}),W={interpolation:"nearest",multidimensionalDefinition:a,sliceId:i.sliceId},{pixelBlock:F}=await B.fetchPixels(N,v,v,W),{pixelBlock:k}=await this.fetchPixels(N,v,v,W);if(F==null)return{location:d,value:null};const P=Math.floor(v*v*.5),j=!F.mask||F.mask[P]?F.pixels.map(J=>J[P]):null;let M;return k!=null&&(M=!k.mask||k.mask[P]?k.pixels.map(J=>J[P]):void 0),{location:d,value:j,processedValue:M,pyramidLevel:0}}if(!x){if(i.srcResolution)y=ye(i.srcResolution,n,this.ioConfig.sampling).pyramidLevel;else if(y=await this.computeBestPyramidLevelForLocation(t,i),y==null)return{location:d,value:null}}const f=this.identifyPixelLocation(d,y,null,x);if(f===null)return{location:d,value:null};const{row:p,col:h,rowOffset:g,colOffset:b,blockWidth:w}=f,S=o??i.sliceId,H=de(this.rasterId,S),C=`${y}/${p}/${h}`;let D=me(H,null,C);D==null&&(D=this.fetchRawTile(y,p,h,i),fe(H,null,C,D));const $=await D;if(!((A=$==null?void 0:$.pixels)!=null&&A.length))return{location:d,value:null};const O=g*w+b;return this._processIdentifyResult($,{srcLocation:d,position:O,pyramidLevel:y,useTransposedTile:!!x,requestSomeSlices:c,identifyOptions:i})}async fetchPixels(t,i,a,e={}){t=ft(t),e=this._getRequestOptionsWithSliceId(e);const{_hasNoneOrGCSShiftTransform:n}=this;if(e.requestRawData&&n)return this._fetchPixels(t,i,a,e);const r=U(t.spatialReference),s=Z(t);if(r==null||s===0||s===1&&this._isGlobalWrappableSource&&n)return this._fetchPixels(t,i,a,e);if(s>=3)return{extent:t,pixelBlock:null};const o=[],{xmin:c,xmax:l}=t,u=Math.round(r/(l-c)*i),m=u-Math.round((r/2-c)/(l-c)*i);let d=0;const y=[];for(let h=0;h<=s;h++){const g=new V({xmin:h===0?c:-r/2,xmax:h===s?l-r*h:r/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),b=h===0?u-m:h===s?i-d:u;d+=b,y.push(b);const w=e.disableWrapAround&&h>0?null:this._fetchPixels(g,b,a,e);o.push(w)}const x=(await Promise.all(o)).map(h=>h==null?void 0:h.pixelBlock);let f=null;const p={width:i,height:a};return this.rasterJobHandler?f=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:x,srcMosaicSize:p,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:y},e)).pixelBlock:f=Y(x,p,{blockWidths:y}),{extent:t,srcExtent:Q(t,this.rasterInfo.spatialReference,e.datumTransformation),pixelBlock:f}}async fetchRawPixels(t,i,a,e={}){i={x:Math.floor(i.x),y:Math.floor(i.y)};const n=await this._fetchRawTiles(t,i,a,e),{nativeExtent:r,nativePixelSize:s,storageInfo:o}=this.rasterInfo,c=2**t,l=s.x*c,u=s.y*c,m=new V({xmin:r.xmin+l*i.x,xmax:r.xmin+l*(i.x+a.width-1),ymin:r.ymax-u*(i.y+a.height-1),ymax:r.ymax-u*i.y,spatialReference:r.spatialReference});if(!n)return{extent:m,srcExtent:m,pixelBlock:null};const{pixelBlocks:d,mosaicSize:y}=n;if(d.length===1&&d[0]!=null&&d[0].width===a.width&&d[0].height===a.height)return{extent:m,srcExtent:m,pixelBlock:n.pixelBlocks[0]};const x=t>0?o.pyramidBlockWidth:o.blockWidth,f=t>0?o.pyramidBlockHeight:o.blockHeight,p={x:i.x%x,y:i.y%f};let h;return this.rasterJobHandler?h=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:d,srcMosaicSize:y,destDimension:a,clipOffset:p,clipSize:a,coefs:null,sampleSpacing:null,interpolation:e.interpolation,alignmentInfo:null,blockWidths:null},e)).pixelBlock:h=Y(d,y,{clipOffset:p,clipSize:a}),{extent:m,srcExtent:m,pixelBlock:h}}fetchRawTile(t,i,a,e){throw new G("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return Q(this.rasterInfo.extent,t)}decodePixelBlock(t,i){return!this.rasterJobHandler||i.useCanvas?it(t,i):this.rasterJobHandler.decode({data:t,options:i})}async request(t,i,a=0){const{customFetchParameters:e}=this.ioConfig,{range:n,query:r,headers:s}=i;a=a??i.retryCount??this.ioConfig.retryCount;const o=n?{Range:`bytes=${n.from}-${n.to}`}:null;try{return await Ie(t,{...i,query:{...r,...e},headers:{...s,...o}})}catch(c){if(a>0)return a--,this.request(t,i,a);throw c}}getSliceIndex(t){const{multidimensionalInfo:i}=this.rasterInfo;return i==null||t==null||t.length===0?null:Xe(t,i)}getTileExtentFromTileInfo(t,i,a,e){const n=e.lodAt(t);return this.getTileExtent({x:n.resolution,y:n.resolution},i,a,e.origin,e.spatialReference,e.size)}updateTileInfo(){const{storageInfo:t,spatialReference:i,extent:a,pixelSize:e}=this.rasterInfo,{pyramidResolutions:n}=t;if(!t.tileInfo){const r=[],s=t.maximumPyramidLevel||0;let o=(e.x+e.y)/2,c=1/.0254*96*o;for(let u=0;u<=s&&(r.unshift(new He({level:s-u,resolution:o,scale:c})),u!==s);u++)if(n){const m=(n[u].x+n[u].y)/2;c*=m/o,o=m}else o*=2,c*=2;const l=new E({x:a.xmin,y:a.ymax,spatialReference:i});t.tileInfo=new K({origin:l,size:[t.blockWidth,t.blockHeight],spatialReference:i,lods:r}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,i=512,a=512,e){const{width:n,height:r,nativeExtent:s,pixelSize:o,spatialReference:c}=t,l=new E({x:s.xmin,y:s.ymax,spatialReference:c});e==null&&(e=Math.max(0,Math.round(Math.log(Math.max(n,r))/Math.LN2-8)));const u=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[o],e);t.storageInfo=new nt({blockWidth:i,blockHeight:a,pyramidBlockWidth:i,pyramidBlockHeight:a,origin:l,firstPyramidLevel:1,maximumPyramidLevel:e,blockBoundary:u})}async computeBestPyramidLevelForLocation(t,i={}){return 0}computeBlockBoundary(t,i,a,e,n,r=0,s=2){if(n.length===1&&r>0){n=[...n];let{x:u,y:m}=n[0];for(let d=0;d<r;d++)u*=s,m*=s,n.push({x:u,y:m})}const o=[],{x:c,y:l}=e;for(let u=0;u<n.length;u++){const{x:m,y:d}=n[u];o.push({minCol:Math.floor((t.xmin-c+.1*m)/i/m),maxCol:Math.floor((t.xmax-c-.1*m)/i/m),minRow:Math.floor((l-t.ymax+.1*d)/a/d),maxRow:Math.floor((l-t.ymin-.1*d)/a/d)})}return o}getPyramidPixelSize(t){const{nativePixelSize:i}=this.rasterInfo,{pyramidResolutions:a,pyramidScalingFactor:e}=this.rasterInfo.storageInfo;if(t===0)return i;if(a!=null&&a.length)return a[t-1];const n=e**t;return{x:i.x*n,y:i.y*n}}identifyPixelLocation(t,i,a,e){const{spatialReference:n,nativeExtent:r,storageInfo:s}=this.rasterInfo,{maximumPyramidLevel:o,origin:c,transposeInfo:l}=s,u=e&&l!=null?l.tileSize[0]:s.blockWidth,m=e&&l!=null?l.tileSize[1]:s.blockHeight,d=pe(t,n,a);if(!r.intersects(d)||i<0||i>o)return null;const y=this.getPyramidPixelSize(i),{x,y:f}=y,p=(c.y-d.y)/f/m,h=(d.x-c.x)/x/u,g=Math.min(m-1,Math.floor((p-Math.floor(p))*m)),b=Math.min(u-1,Math.floor((h-Math.floor(h))*u));return{pyramidLevel:i,row:Math.floor(p),col:Math.floor(h),rowOffset:g,colOffset:b,blockWidth:u,srcLocation:d}}getTileExtent(t,i,a,e,n,r){const[s,o]=r,c=e.x+a*s*t.x,l=c+s*t.x,u=e.y-i*o*t.y,m=u-o*t.y;return new V({xmin:c,xmax:l,ymin:m,ymax:u,spatialReference:n})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,i,a){const e=this.rasterInfo.storageInfo.blockBoundary[t];return!e||e.maxRow<i||e.maxCol<a||e.minRow>i||e.minCol>a}updateImageSpaceRasterInfo(t){const{pixelSize:i}=t,{width:a,height:e}=t,n=we.WebMercator;t.spatialReference=n,t.extent=t.nativeExtent=new V({xmin:-.5,ymax:.5,xmax:a-.5,ymin:.5-e,spatialReference:n}),t.isPseudoSpatialReference=!0,t.transform=null,t.pixelSize=new E({x:1,y:1,spatialReference:n});const{extent:r,storageInfo:s}=t;if(s){s.origin=new E({x:r.xmin,y:r.ymax,spatialReference:n});const{pyramidResolutions:o,tileInfo:c}=s;if(o&&o.forEach(l=>{l.x/=i.x,l.y/=i.y}),c){c.origin=s.origin;const l=(t.nativePixelSize.x+t.nativePixelSize.y)/2;c.lods.forEach((u,m)=>{u.resolution=l*2**m,u.scale=96*u.resolution/.0254})}}}async _fetchPixels(t,i,a,e={}){let n=Z(t);if(n>=2)return{extent:t,pixelBlock:null};const r=this._getSourceDataInfo(t,i,a,e),{pyramidLevel:s,srcResolution:o,srcExtent:c,srcWidth:l,srcHeight:u,ul:m}=r;if(l===0||u===0)return{extent:t,srcExtent:c,pixelBlock:null};const{rasterInfo:d}=this,y=d.transform,x=(y==null?void 0:y.type)==="gcs-shift",f=U(t.spatialReference)!=null;!x&&f||(n=Z(r.srcExtent,x));const p=await this._fetchRawTiles(s,m,{width:l,height:u,wrapCount:n},e);if(!p)return{extent:t,srcExtent:c,pixelBlock:null};const h=d.storageInfo,g=s>0?h.pyramidBlockWidth:h.blockWidth,b=s>0?h.pyramidBlockHeight:h.blockHeight;let{x:w,y:S}=d.pixelSize;if(s>0){const{pyramidResolutions:J,pyramidScalingFactor:ke}=h;if(J!=null&&J[s-1])({x:w,y:S}=J[s-1]);else{const se=ke**s;w*=se,S*=se}}const H=d.spatialReference,C=new E({x:w,y:S,spatialReference:H}),D=g===l&&b===u&&m.x%g==0&&m.y%b==0,$=new E({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/a,spatialReference:t.spatialReference}),O=!t.spatialReference.equals(H),A=H.isGeographic?1e-9:1e-4,{datumTransformation:B}=e;if(!O&&D&&p.pixelBlocks.length===1&&g===i&&b===a&&wt(o,$,A))return{extent:t,srcExtent:c,srcTilePixelSize:C,pixelBlock:p.pixelBlocks[0]};const L=f&&U(c.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,v=e.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");v&&!this.rasterJobHandler&&await te();const T=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:p.extent,pixelSize:$.toJSON(),datumTransformation:B,rasterTransform:y,hasWrapAround:n>0||L,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:v},e):pt({projectedExtent:t,srcBufferExtent:p.extent,pixelSize:$,datumTransformation:B,rasterTransform:y,hasWrapAround:n>0||L,isAdaptive:!1,includeGCSGrid:v});let z;const N=!e.requestRawData,W={rows:T.spacing[0],cols:T.spacing[1]},F=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(s,p.extent.xmin):void 0,{pixelBlocks:k,mosaicSize:P,isPartiallyFilled:j}=p;let M=null;if(this.rasterJobHandler)({pixelBlock:z,localNorthDirections:M}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:k,srcMosaicSize:P,destDimension:N?{width:i,height:a}:null,coefs:N?T.coefficients:null,sampleSpacing:N?W:null,projectDirections:v,gcsGrid:v?T.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:e.interpolation,alignmentInfo:F,blockWidths:null},e));else{const J=Y(k,P,{alignmentInfo:F});z=N?_e(J,{width:i,height:a},T.coefficients,W,e.interpolation):J,v&&T.gcsGrid&&(M=lt({width:i,height:a},T.gcsGrid),z=ct(z,this.rasterInfo.dataType,M))}return e.requestRawData||v?{extent:t,srcExtent:c,srcTilePixelSize:C,pixelBlock:z,transformGrid:T,localNorthDirections:M,isPartiallyFilled:j}:{extent:t,srcExtent:c,srcTilePixelSize:C,pixelBlock:z}}async _fetchRawTiles(t,i,a,e){const{origin:n,blockBoundary:r}=this.rasterInfo.storageInfo,{blockWidth:s,blockHeight:o}=this.getBlockWidthHeight(t);let{x:c,y:l}=i,{width:u,height:m,wrapCount:d}=a;const y=this._getRasterTileAlignmentInfo(t,0);e.buffer&&(c-=e.buffer.cols,l-=e.buffer.rows,u+=2*e.buffer.cols,m+=2*e.buffer.rows);let x=0,f=0,p=0;d&&y!=null&&({worldColumnCountFromOrigin:f,originColumnOffset:p,rightPadding:x}=y,f*y.blockWidth-x>=c+u&&(x=0));const h=Math.floor(c/s),g=Math.floor(l/o),b=Math.floor((c+u+x-1)/s),w=Math.floor((l+m+x-1)/o),S=r[t];if(!S)return null;const{minRow:H,minCol:C,maxCol:D,maxRow:$}=S;if(d===0&&(w<H||b<C||g>$||h>D))return null;const O=new Array;let A=!1;const B=this.ioConfig.allowPartialFill==null?e.allowPartialFill:this.ioConfig.allowPartialFill;for(let F=g;F<=w;F++)for(let k=h;k<=b;k++){let P=k;if(!e.disableWrapAround&&d&&y!=null&&f<=k&&(P=k-f-p),F>=H&&P>=C&&$>=F&&D>=P){const j=this._tileFetchQueue.push({pyramidLevel:t,row:F,col:P,options:e},{signal:e.signal});B?O.push(new Promise(M=>{j.then(J=>M(J)).catch(()=>{A=!0,M(null)})})):O.push(j)}else O.push(Promise.resolve(null))}if(O.length===0)return null;const L=await Promise.all(O),v={height:(w-g+1)*o,width:(b-h+1)*s},{spatialReference:T}=this.rasterInfo,z=this.getPyramidPixelSize(t),{x:N,y:W}=z;return{extent:new V({xmin:n.x+h*s*N,xmax:n.x+(b+1)*s*N,ymin:n.y-(w+1)*o*W,ymax:n.y-g*o*W,spatialReference:T}),pixelBlocks:L,mosaicSize:v,isPartiallyFilled:A}}_fetchRawTile(t,i,a,e){const n=this.rasterInfo.storageInfo.blockBoundary[t];if(!n)return Promise.resolve(null);const{minRow:r,minCol:s,maxCol:o,maxRow:c}=n;if(i<r||a<s||i>c||a>o)return Promise.resolve(null);const l=de(this.rasterId,e.sliceId),u=`${t}/${i}/${a}`;let m=me(l,e.registryId,u);if(m==null){const d=new AbortController;m=this.fetchRawTile(t,i,a,{...e,signal:d.signal}),fe(l,e.registryId,u,m,d),m.catch(()=>at(l,e.registryId,u))}return e.signal&&Ce(e,()=>{ot(l,e.registryId,u)}),m}_computeMagDirValues(t){var c;const{bandCount:i,dataType:a}=this.rasterInfo;if(!(i===2&&a==="vector-magdir"||a==="vector-uv")||(t==null?void 0:t.length)!==2||!((c=t[0])!=null&&c.length))return null;const e=t[0].length;if(a==="vector-magdir"){const l=t[1].map(u=>(u+360)%360);return[t[0],l]}const[n,r]=t,s=[],o=[];for(let l=0;l<e;l++){const[u,m]=ut([n[l],r[l]]);s.push(u),o.push(m)}return[s,o]}_getRasterTileAlignmentInfo(t,i){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=yt(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:i,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,i,a,e={}){const n={datumTransformation:e.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};e.srcResolution&&(n.srcResolution=e.srcResolution,this._updateSourceDataInfo(t,n));const r=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:s,srcHeight:o,pyramidLevel:c}=n,l=s/i,u=o/a,m=c<r&&l*u>=16,d=c===r&&this._requireTooManySrcTiles(s,o,i,a);if(m||d||s===0||o===0){const y=new E({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/a,spatialReference:t.spatialReference});let x=xt(y,this.rasterInfo.spatialReference,t,n.datumTransformation);const f=!x||e.srcResolution&&x.x+x.y<e.srcResolution.x+e.srcResolution.y;if(m&&e.srcResolution&&f){const p=Math.round(Math.log(Math.max(l,u))/Math.LN2)-1;if(r-c+3>=p){const h=2**p;x={x:e.srcResolution.x*h,y:e.srcResolution.y*h}}}x&&(n.srcResolution=x,this._updateSourceDataInfo(t,n))}return this._requireTooManySrcTiles(n.srcWidth,n.srcHeight,i,a)&&(n.srcWidth=0,n.srcHeight=0),n}_requireTooManySrcTiles(t,i,a,e){const{tileInfo:n}=this.rasterInfo.storageInfo,r=Math.ceil(t/n.size[0])*Math.ceil(i/n.size[1]),s=t/a,o=i/e,c=Math.max(1,(a+e)/1024);return r>=bt*c||s>xe||o>xe}_updateSourceDataInfo(t,i){i.srcWidth=0,i.srcHeight=0;const{rasterInfo:a}=this,e=a.spatialReference,{srcResolution:n,datumTransformation:r}=i,{pyramidLevel:s,pyramidResolution:o,excessiveReading:c}=ye(n,a,this.ioConfig.sampling);if(c)return;let l=i.srcExtent||Q(t,e,r);if(l==null)return;const u=a.transform;u&&(l=u.inverseTransform(l)),i.srcExtent=l;const{x:m,y:d}=a.storageInfo.origin,y=Math.floor((l.xmin-m)/o.x+.1),x=Math.floor((d-l.ymax)/o.y+.1),f=Math.floor((l.xmax-m)/o.x-.1),p=Math.floor((d-l.ymin)/o.y-.1),h=l.width<.1*o.x?0:f-y+1,g=l.height<.1*o.y?0:p-x+1;i.pyramidLevel=s,i.pyramidResolution=o,i.srcWidth=h,i.srcHeight=g,i.ul={x:y,y:x}}_getRequestOptionsWithSliceId(t){return this.rasterInfo.multidimensionalInfo!=null&&t.sliceId==null&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,i){const{srcLocation:a,position:e,pyramidLevel:n,useTransposedTile:r}=i,s=t.pixels[0].length/t.width/t.height;if(!(!t.mask||t.mask[e]))return{location:a,value:null};const{multidimensionalInfo:o}=this.rasterInfo;if(o==null||!r){const p=t.pixels.map(b=>b[e]),h={location:a,value:p,pyramidLevel:n},g=this._computeMagDirValues(p.map(b=>[b]));return g!=null&&g.length&&(h.magdirValue=g.map(b=>b[0])),h}let c=t.pixels.map(p=>p.slice(e*s,e*s+s)),l=this._computeMagDirValues(c);const{requestSomeSlices:u,identifyOptions:m}=i;let d=Ye(o,m.transposedVariableName);if(u){const p=Ze(d,m.multidimensionalDefinition,m.timeExtent);c=c.map(h=>p.map(g=>h[g])),l=l==null?void 0:l.map(h=>p.map(g=>h[g])),d=p.map(h=>d[h])}const y=t.noDataValues||this.rasterInfo.noDataValue,x={pixels:c,pixelType:t.pixelType};let f;return y!=null&&(ht(x,y),f=x.mask),{location:a,value:null,dataSeries:d.map((p,h)=>{const g={value:(f==null?void 0:f[h])===0?null:c.map(b=>b[h]),multidimensionalDefinition:p.multidimensionalDefinition.map(b=>new ve({...b,isSlice:!0}))};return l!=null&&l.length&&(g.magdirValue=[l[0][h],l[1][h]]),g}),pyramidLevel:n}}};function wt(t,i,a){return Math.abs(t.x-i.x)<a&&Math.abs(t.y-i.y)<a}R([I()],_.prototype,"_rasterTileAlignmentInfo",void 0),R([I()],_.prototype,"_tileFetchQueue",void 0),R([I({readOnly:!0})],_.prototype,"_isGlobalWrappableSource",null),R([I({readOnly:!0})],_.prototype,"_hasNoneOrGCSShiftTransform",null),R([I()],_.prototype,"_openPromise",void 0),R([I()],_.prototype,"rasterJobHandler",null),R([I({readOnly:!0})],_.prototype,"rasterId",null),R([I(ge)],_.prototype,"url",null),R([I({type:String,json:{write:!0}})],_.prototype,"datasetName",void 0),R([I({type:String,json:{write:!0}})],_.prototype,"datasetFormat",void 0),R([I()],_.prototype,"hasUniqueSourceStorageInfo",void 0),R([I()],_.prototype,"rasterInfo",void 0),R([I()],_.prototype,"ioConfig",void 0),R([I()],_.prototype,"sourceJSON",void 0),_=R([re("esri.layers.support.rasterDatasets.BaseRaster")],_);const St=_,vt=40;let q=class extends St{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(t,i,a,e={}){var b,w;const{rasters:n,rasterIds:r}=this.primaryRasters;let s=!1;const{interpolation:o}=e,c=(b=this.rasterFunction.flatWebGLFunctionChain)==null?void 0:b.hasFocalFunction;!e.requestRawData&&c&&(s=n.length===1&&!e.skipRasterFunction,e={...e,interpolation:"bilinear",requestRawData:s});const l=n.map(S=>S.fetchPixels(t,i,a,e)),u=await Promise.all(l),m=u.map(S=>S.pixelBlock),d=s||e.requestRawData?u.map(S=>S.srcTilePixelSize):null;if(e.skipRasterFunction||m.every(S=>S==null))return u[0];const y=((w=u.find(S=>S.pixelBlock!=null))==null?void 0:w.extent)??t;let x=this.rasterJobHandler?await this.rasterJobHandler.process({extent:y,primaryPixelBlocks:m,primaryPixelSizes:d,primaryRasterIds:r}):this.rasterFunction.process({extent:y,primaryPixelBlocks:m,primaryPixelSizes:d,primaryRasterIds:r});const{transformGrid:f}=u[0];if(!s||x==null||f==null){const S=e.noClip?null:this.getClippingGeometry(y.spatialReference);return e.noClip||e.requestRawData||x==null||!S||(x=await ne(x,y,S)),{...u[0],pixelBlock:x}}const p={rows:f.spacing[0],cols:f.spacing[1]};let h;this.rasterJobHandler?h=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[x],srcMosaicSize:{width:x.width,height:x.height},destDimension:{width:i,height:a},coefs:f.coefficients,sampleSpacing:p,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:o,alignmentInfo:void 0,blockWidths:null},e)).pixelBlock:h=_e(x,{width:i,height:a},f.coefficients,p,o);const g=e.noClip?null:this.getClippingGeometry(t.spatialReference);return e.noClip||e.requestRawData||h==null||g==null||(h=await ne(h,t,g)),{extent:t,srcExtent:u[0].srcExtent,pixelBlock:h}}getClippingGeometry(t){const i=this._clippingGeometry.get("0");if(!t||!i)return i;const a=Ft(t);let e=this._clippingGeometry.get(a);return e!=null||(e=t.equals(i.spatialReference)?i:ie(i,t),this._clippingGeometry.set(a,e)),e}async _open(t){var l,u,m,d;const{rasterFunction:i}=this;(u=(l=this.primaryRasters)==null?void 0:l.rasters)!=null&&u.length?i.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=i.getPrimaryRasters(),this.rasterJobHandler&&((m=this.primaryRasters.rasters)==null||m.forEach(y=>y.rasterJobHandler=this.rasterJobHandler)));const{rasters:a,rasterIds:e}=this.primaryRasters,n=a.map(y=>y.rasterInfo?void 0:y.open(t));await Promise.all(n);const r=a.map(({rasterInfo:y})=>y),s=i.bind({rasterInfos:r,rasterIds:e});if(i.rawSourceRasterInfos=r,!s.success||r.length===0)throw new G("raster-function:open",`cannot bind the function: ${s.error??""}`);const o=i.functionName==="Table"?i:(d=i.functionArguments)==null?void 0:d.raster;(o==null?void 0:o.functionName)==="Table"&&(i.rasterInfo.attributeTable=De.fromJSON(o.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const c=r[0];this.hasUniqueSourceStorageInfo=r.length===1||r.slice(1).every(y=>Tt(y,c)),this.set("sourceJSON",a[0].sourceJSON),this.set("rasterInfo",i.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){var t;return(t=this.rasterJobHandler)==null?void 0:t.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const t=this.rasterFunction.getClippingGeometries()[0];let i=t==null?void 0:t.clippingGeometry;if(i&&t.clippingType==="inside"){const{extent:a}=this.rasterInfo,{difference:e,densify:n}=await $e(()=>import("./geometryEngine-6ac27f5e.js"),["assets/geometryEngine-6ac27f5e.js","assets/index-c2b82012.js","assets/index-c76e6b87.css","assets/geometryEngineBase-58446043.js","assets/_commonjsHelpers-2f3e7994.js","assets/hydrated-353ef6c6.js"]);let r=n(Be.fromExtent(a),2*(a.width+a.height)/vt);r=ie(r,i.spatialReference),i=e(r,i)}this._clippingGeometry.clear(),i&&this._clippingGeometry.set("0",i)}};R([I({type:String,json:{write:!0}})],q.prototype,"datasetFormat",void 0),R([I()],q.prototype,"tileType",void 0),R([I()],q.prototype,"rasterFunction",void 0),R([I()],q.prototype,"primaryRasters",void 0),q=R([re("esri.layers.support.rasterDatasets.FunctionRaster")],q);const _t=q;function Tt(t,i){const{storageInfo:a,pixelSize:e,spatialReference:n,extent:r}=t,{storageInfo:s,pixelSize:o,spatialReference:c,extent:l}=i;return e.x===o.x&&e.y===o.y&&n.equals(c)&&r.equals(l)&&a.blockHeight===s.blockHeight&&a.blockWidth===s.blockWidth&&a.maximumPyramidLevel===s.maximumPyramidLevel}function Ft(t){return String(t.wkid??t.wkt??t.wkt2)}const Nt=t=>{let i=class extends t{constructor(...e){var n,r;super(...e),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=((r=(n=e[0])==null?void 0:n.raster)==null?void 0:r.datasetFormat)==="Function"}get fullExtent(){var e;return(e=this.serviceRasterInfo)==null?void 0:e.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){var n;((n=e==null?void 0:e.functionName)==null?void 0:n.toLowerCase())==="none"&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",Re(e,ee.getLogger(this)))}get renderer(){if(this.type!=="imagery-tile")return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:n}=this;if(e){const r=n==null?void 0:n.find(({name:s})=>s===e);return r==null?void 0:r.renderer.clone()}return this.internalRenderer}set renderer(e){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,n,r){var o,c;const s=(c=(o=n==null?void 0:n.layerDefinition)==null?void 0:o.drawingInfo)==null?void 0:c.renderer;return qe(s,r)||void 0}async convertVectorFieldData(e,n){const{serviceRasterInfo:r}=this;if(e==null||!r)return null;const s=this._rasterJobHandler.instance,o=r.dataType;return s?s.convertVectorFieldData({pixelBlock:e,dataType:o},n):dt(e,o)}async computeStatisticsHistograms(e,n){await this.load(n),e=be(Ge,e).clone();const{serviceRasterInfo:r}=this;if(r==null)throw new G("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:s}=e;if(s==null)throw new G("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let o=s;const{spatialReference:c}=r;s.spatialReference.equals(c)||(await te(),o=s.type==="extent"?Q(s,c):ie(s,c));const l=e.pixelSize??new E({x:r.pixelSize.x,y:r.pixelSize.y,spatialReference:c}),{extent:u,width:m,height:d}=gt(r,o,l),y=await this.fetchPixels(u,m,d,{...n,interpolation:"nearest"});if(y.pixelBlock==null)throw new G("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const x=await ne(y.pixelBlock,u,o),f=this._rasterJobHandler.instance;return f?f.computeStatisticsHistograms({pixelBlock:x},n):rt(x)}async createFlowMesh(e,n){const r=this._rasterJobHandler.instance;return r?r.createFlowMesh(e,n):mt(e.meshType,e.simulationSettings,e.flowData,n.signal!=null?n.signal:new AbortController().signal)}normalizeRasterFetchOptions(e){var o,c;const{multidimensionalInfo:n}=this.serviceRasterInfo??{};if(n==null)return e;let r=e.multidimensionalDefinition||this.multidimensionalDefinition;r!=null&&r.length||(r=ue(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset}));const s=e.timeExtent||this.timeExtent;if(r!=null&&s!=null&&(s.start!=null||s.end!=null)){r=r.map(h=>h.clone());const l=(c=(o=n.variables.find(({name:h})=>h===r[0].variableName))==null?void 0:o.dimensions)==null?void 0:c.find(({name:h})=>h==="StdTime"),u=r.find(({dimensionName:h})=>h==="StdTime");if(!l||!u)return{...e,multidimensionalDefinition:null};const{start:m,end:d}=s,y=m==null?null:m.getTime(),x=d==null?null:d.getTime(),f=y??x,p=x??y;if(l.values!=null){const h=l.values.filter(g=>{if(Array.isArray(g)){if(f===p)return g[0]<=f&&g[1]>=f;const b=g[0]<=f&&g[1]>f||g[0]<p&&g[1]>=p,w=g[0]>=f&&g[1]<=p||g[0]<f&&g[1]>p;return b||w}return f===p?g===f:g>=f&&g<=p});if(h.length){const g=h.sort((b,w)=>{const S=Array.isArray(b)?b[0]:b,H=Array.isArray(b)?b[1]:b,C=Array.isArray(w)?w[0]:w,D=Array.isArray(w)?w[1]:w;return f===p?S-C:Math.abs(H-p)-Math.abs(D-p)})[0];u.values=[g]}else r=null}else if(l.hasRegularIntervals&&l.extent){const[h,g]=l.extent;f>g||p<h?r=null:u.values=f===p?[f]:[Math.max(h,f),Math.min(g,p)]}}return r!=null&&et(r,this.multidimensionalSubset)?{...e,multidimensionalDefinition:null}:{...e,multidimensionalDefinition:r}}async updateRasterFunction(){var u,m,d;if(!this.loaded||this.type!=="imagery-tile"||!this.rasterFunction&&!this._cachedRasterFunctionJson||JSON.stringify(this.rasterFunction)===JSON.stringify(this._cachedRasterFunctionJson))return;if(this._isConstructedFromFunctionRaster&&this.raster.datasetFormat==="Function"){const y=this.raster.rasterFunction.toJSON();return!this.rasterFunction&&y&&this._set("rasterFunction",ae.fromJSON(y)),void(this._cachedRasterFunctionJson=(u=this.rasterFunction)==null?void 0:u.toJSON())}let e,n=this.raster,r=!1;n.datasetFormat==="Function"?(e=n.primaryRasters.rasters,n=e[0],r=!0):e=[n];const{rasterFunction:s}=this;if(s){const y={raster:n};e.length>1&&e.forEach(p=>y[p.url]=p);const x=Rt(((m=s.functionDefinition)==null?void 0:m.toJSON())??s.toJSON(),y),f=new _t({rasterFunction:x});f.rasterJobHandler=this._rasterJobHandler.instance,await f.open(),this._cachedRasterFunctionJson=(d=this.rasterFunction)==null?void 0:d.toJSON(),this.raster=f}else this.raster=n,this._cachedRasterFunctionJson=null,await n.open();if(this._cachedRendererJson=null,!r&&!s)return;const{bandIds:o}=this,{bandCount:c}=this.raster.rasterInfo,l=o!=null&&o.length?o.some(y=>y>=c):c>=3;o&&(l||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}async updateRenderer(){const{loaded:e,symbolizer:n}=this;if(!e||!n||!this.renderer)return;const{rasterInfo:r}=this.raster,s=he(r,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),o=s==null?void 0:s.name,c=oe({...this.renderer.toJSON(),variableName:o});if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(c))return;const l=this._rasterJobHandler.instance;l&&(n.rasterInfo=le(r,o),n.rendererJSON=c,n.bind(),await l.updateSymbolizer(n),this._cachedRendererJson=c)}async applyRenderer(e,n){const r=e==null?void 0:e.pixelBlock;if(!(r!=null&&r.pixels&&r.pixels.length>0))return null;let s;await this.updateRenderer();const o=this._rasterJobHandler.instance,c=this.bandIds??[];return s=o?await o.symbolize({...e,simpleStretchParams:n,bandIds:c}):this.symbolizer.symbolize({...e,simpleStretchParams:n,bandIds:c}),s}getTileUrl(e,n,r){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${e}/${n}/${r}`:""}getCompatibleTileInfo(e,n,r=!1){if(!this.loaded||n==null)return null;if(r&&e.equals(this.spatialReference))return this.tileInfo;const s=Oe(e);return K.create({size:256,spatialReference:e,origin:s?{x:s.origin[0],y:s.origin[1]}:{x:n.xmin,y:n.ymax}})}getCompatibleFullExtent(e){var n;return this.loaded?((n=this._compatibleFullExtent)!=null&&n.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,n,r,s={}){var c;if(a(this),s.requestAsImageElement){const l=this.getTileUrl(e,n,r);return Ie(l,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:s.signal}).then(u=>u.data)}const{serviceRasterInfo:o}=this;if(o.multidimensionalInfo!=null&&(s=this.normalizeRasterFetchOptions(s)).multidimensionalDefinition==null){const l=s.tileInfo||o.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,n,r,l),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),((c=this.renderer)==null?void 0:c.type)==="raster-shaded-relief"&&(s={...s,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,n,r,s)}async fetchPixels(e,n,r,s={}){return this.serviceRasterInfo.multidimensionalInfo!=null&&(s=this.normalizeRasterFetchOptions(s)).multidimensionalDefinition==null?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),n=Math.round(n),r=Math.round(r),this.raster.fetchPixels(e,n,r,s))}async identify(e,n={}){var c;await this.load();const{raster:r,serviceRasterInfo:s}=this;if((s==null?void 0:s.multidimensionalInfo)!=null&&!(s.hasMultidimensionalTranspose&&(Se(n.multidimensionalDefinition)||n.transposedVariableName||n.timeExtent))&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null)return{location:e,value:null};const o=(c=this.multidimensionalSubset)==null?void 0:c.areaOfInterest;if(o&&!o.contains(e))throw new G("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return r.identify(e,n)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){var s,o,c;const e=(s=this.serviceRasterInfo)==null?void 0:s.multidimensionalInfo;if(e==null||((o=this.serviceRasterInfo)==null?void 0:o.dataType)!=="standard-time")return!1;const n=this.multidimensionalDefinition,r=(c=n==null?void 0:n[0])==null?void 0:c.variableName;return e.variables.some(l=>l.name===r&&(!(n!=null&&n[0].dimensionName)||l.dimensions.some(u=>u.name==="StdTime")))}getStandardTimeValue(e){return new Date(24*(e-25569)*3600*1e3).toString()}getMultidimensionalSubsetVariables(e){var r;const n=e??((r=this.serviceRasterInfo)==null?void 0:r.multidimensionalInfo);return tt(this.multidimensionalSubset,n)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=ue(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&this.raster.datasetFormat==="Function"&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}_initJobHandler(){if(this._rasterJobHandler.connectionPromise!=null)return this._rasterJobHandler.connectionPromise;const e=new Ke;return this._rasterJobHandler.connectionPromise=e.initialize().then(async()=>{a(this),this._rasterJobHandler.instance=e,this.raster.rasterJobHandler=e,this.raster.datasetFormat==="Function"&&this.raster.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{}),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){var e;if(this.interpolation==null){a(this);const{raster:n}=this,r=je(n.rasterInfo,n.tileType,(e=this.sourceJSON)==null?void 0:e.defaultResamplingMethod);this._set("interpolation",r)}}_configDefaultRenderer(e="no"){var m,d,y;a(this);const{rasterInfo:n}=this.raster,r=he(n,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),s=r==null?void 0:r.name,o=Ve({variableName:s,rasterFunctionName:(m=this.rasterFunction)==null?void 0:m.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&n.bandCount>1&&(this.bandIds=(o==null?void 0:o.bandIds)??Ue(n)),!this.renderer||e==="override"){const x=Qe(this.raster),f=(o==null?void 0:o.renderer)??ce(n,{bandIds:this.bandIds,variableName:s,rasterFunctionColorRamp:x}),p=n.statistics,h=p&&p.length>0?p[0]:null,g=(h==null?void 0:h.max)??0,b=(h==null?void 0:h.min)??0;this.raster.datasetFormat==="WCSServer"&&f.type==="raster-stretch"&&(g>1e24||b<-1e24)&&(f.dynamicRangeAdjustment=!0,f.customStatistics=null,f.stretchType==="none"&&(f.stretchType="min-max")),this.renderer=f}const c=oe({...this.renderer.toJSON(),variableName:s}),l=le(n,s);this.symbolizer?(this.symbolizer.rendererJSON=c,this.symbolizer.rasterInfo=l):this.symbolizer=new st({rendererJSON:c,rasterInfo:l});const u=this.symbolizer.bind();if(u.success){if(e==="auto"){const{colormap:x}=this.raster.rasterInfo,f=this.renderer;if(x!=null&&f.type==="raster-colormap"){const p=ce(this.raster.rasterInfo);JSON.stringify(p)!==JSON.stringify(f)&&this._configDefaultRenderer("override")}else if(f.type==="raster-stretch"){const p=(d=this.bandIds)==null?void 0:d.length,h=(y=f.customStatistics)==null?void 0:y.length;!f.dynamicRangeAdjustment&&h&&p&&h!==p&&this._configDefaultRenderer("override")}}}else ee.getLogger(this).warn("imagery-tile-mixin",u.error||"The given renderer is not supported by the layer."),e==="auto"&&this._configDefaultRenderer("override")}};function a(e){if(!e.raster||!e.serviceRasterInfo)throw new G("imagery-tile","no raster")}return R([I({clonable:!1})],i.prototype,"_cachedRendererJson",void 0),R([I({clonable:!1})],i.prototype,"_cachedRasterFunctionJson",void 0),R([I({clonable:!1})],i.prototype,"_compatibleFullExtent",void 0),R([I({clonable:!1})],i.prototype,"_isConstructedFromFunctionRaster",void 0),R([I({clonable:!1})],i.prototype,"_rasterJobHandler",void 0),R([I({type:[ze],json:{write:{overridePolicy(){var e;return{enabled:!this.loaded||this.raster.tileType==="Raster"||((e=this.bandIds)==null?void 0:e.join(","))!=="0,1,2"}}}}})],i.prototype,"bandIds",void 0),R([I({json:{origins:{service:{read:{source:"copyrightText"}}}}})],i.prototype,"copyright",void 0),R([I({json:{read:!1}})],i.prototype,"fullExtent",null),R([I({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),Ne(Ee)],i.prototype,"interpolation",void 0),R([I()],i.prototype,"ioConfig",void 0),R([I({type:[ve],json:{write:!0}})],i.prototype,"multidimensionalDefinition",null),R([I({type:We,json:{write:!0}})],i.prototype,"multidimensionalSubset",void 0),R([I()],i.prototype,"raster",void 0),R([I({type:ae})],i.prototype,"rasterFunction",null),R([I()],i.prototype,"serviceRasterInfo",void 0),R([I()],i.prototype,"sourceJSON",void 0),R([I({readOnly:!0,type:we,json:{read:!1}})],i.prototype,"spatialReference",void 0),R([I({type:K})],i.prototype,"tileInfo",void 0),R([I(ge)],i.prototype,"url",null),R([I()],i.prototype,"renderer",null),R([I({types:Ae,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){var n;const e=((n=this.renderer)==null?void 0:n.type)==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!e}}},origins:{"web-scene":{types:Le,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&e.type!=="vector-field"&&e.type!=="flow"})}}}}})],i.prototype,"internalRenderer",null),R([Me("internalRenderer")],i.prototype,"readRenderer",null),R([I({clonable:!1})],i.prototype,"symbolizer",void 0),i=R([re("esri.layers.mixins.ImageryTileMixin")],i),i};function X(t,i){if(!t||!i)return[];let a=i;i.includes("/")?(a=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const e=[];if(i){const r=X(t,a);for(let s=0;s<r.length;s++)X(r[s],i).forEach(o=>e.push(o));return e}const n=t.getElementsByTagNameNS("*",a);if(!n||n.length===0)return[];for(let r=0;r<n.length;r++)e.push(n[r]||n.item(r));return e}function Te(t,i){if(!t||!i)return null;let a=i;i.includes("/")?(a=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const e=X(t,a);return e.length>0?i?Te(e[0],i):e[0]:null}function Fe(t,i=null){const a=i?Te(t,i):t;let e;return a?(e=a.textContent||a.nodeValue,e?e.trim():null):null}function kt(t,i){const a=X(t,i),e=[];let n;for(let r=0;r<a.length;r++)n=a[r].textContent||a[r].nodeValue,n&&(n=n.trim(),n!==""&&e.push(n));return e}function Mt(t,i=null){const a=Fe(t,i);return(a==null?void 0:a.split(" ").map(e=>Number(e)))??[]}function Ot(t,i){return kt(t,i).map(a=>Number(a))}function Et(t,i){const a=Fe(t,i);return Number(a)}function Wt(t,i){var n;const a=(n=t==null?void 0:t.nodeName)==null?void 0:n.toLowerCase(),e=i.toLowerCase();return a.slice(a.lastIndexOf(":")+1)===e}function At(t){return t.nodeName.slice(t.nodeName.lastIndexOf(":")+1)}export{Nt as W,St as X,_t as a,At as c,Te as e,Wt as i,kt as l,X as n,Et as o,Mt as r,Fe as t,Ot as u};
