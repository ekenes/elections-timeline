import{K as D,fS as X,e as Q,cs as S,g$ as Y,h0 as Z,bg as y,X as f,cr as c,dk as ee,s as m,fJ as se,h1 as te,aq as x,fG as oe,ar as re,ct as ae,m as ne,fI as ie}from"./index-3baa78aa.js";import{h as le,N as pe,i as M,o as U,A as ce}from"./FeatureLayerSource-380466af.js";import"./mat4f64-1413b4a7.js";import"./MeshGeoreferencedRelativeVertexSpace-3358dc32.js";import"./vec32-46f91535.js";import"./editingSupport-b2326384.js";import"./normalizeUtils-8a086cf9.js";import"./normalizeUtilsCommon-e63846e2.js";import"./utils-28423b24.js";import"./clientSideDefaults-ed6d7093.js";import"./QueryEngineCapabilities-85c4f1d0.js";import"./QueryTask-8330feeb.js";import"./executeForIds-a4922006.js";import"./query-2e7181a2.js";import"./pbfQueryUtils-d4547e98.js";import"./pbf-47a020e1.js";import"./OptimizedGeometry-33b2eb0d.js";import"./OptimizedFeatureSet-1d1ac4b9.js";import"./executeQueryJSON-584dbeaf.js";import"./executeQueryPBF-d8bb521f.js";import"./featureConversionUtils-548226c1.js";const A={upload:{createFromFiles:.9,loadMesh:.1},uploadConvertibleSource:{uploadEditSource:.5,serviceAssetsToGlb:.5},uploadLocalMesh:{meshToAssetBlob:.5,uploadAssetBlobs:.5},uploadAssetBlobs:{prepareAssetItems:.8,uploadAssetItems:.2}};function h(t,s=o=>{},e){return new ue(t,s,e)}class ue{constructor(s,e=r=>{},o){if(this.onProgress=e,this.taskName=o,this._progressMap=new Map,this._startTime=void 0,this._timingsMap=new Map,typeof s=="number"){this._weights={};for(let r=0;r<s;r++){const a=r,n=1/s;this._weights[a]=n,this._progressMap.set(a,0)}}else this._weights=s;this.emitProgress()}emitProgress(){let s=0;for(const[e,o]of this._progressMap.entries())s+=o*this._weights[e];if(s===1&&D("enable-feature:esri-3dofl-upload-timings")){const e=performance.now()-(this._startTime??0);console.log(`${this.taskName} done in ${e}ms`);for(const[o,r]of this._timingsMap){const a=r.end-r.start;console.log(this.taskName??"Task",{stepKey:o,stepTime:a,relativeTime:a/e})}}this.onProgress(s)}setProgress(s,e){if(this._progressMap.set(s,e),D("enable-feature:esri-3dofl-upload-timings")){const o=performance.now();this._startTime??(this._startTime=o);const r=X(this._timingsMap,s,()=>({start:o,end:0}));e===1&&(r.end=o)}this.emitProgress()}simulate(s,e){return _(o=>this.setProgress(s,o),e)}makeOnProgress(s){return e=>this.setProgress(s,e)}}function _(t=e=>{},s=he){const e=performance.now();t(0);const o=setInterval(()=>{const r=performance.now()-e,a=1-Math.exp(-r/s);t(a)},ge);return Q(()=>{clearInterval(o),t(1)})}function me(t){const s=t*ye,e=de();return Y(Z(s/e))}function de(){try{const t=fe[navigator.connection.effectiveType];return isFinite(t)?t:I}catch{return I}}const I=1,fe={"slow-2g":.1,"2g":.5,"3g":5,"4g":100},ye=8e-6,ge=S(50),he=S(1e3),k=1e6,N=20*k,we=2e9,Pe=3;async function Te({data:t,name:s,description:e},o,r){let a=null;try{const n=y(o,"uploads"),i=y(n,"info"),{data:l}=await f(i,{query:{f:"json"},responseType:"json"});c(r);const p=ee(o),d=l.maxUploadFileSize*k,g=p?we:d,$=p?Math.min(N,d):N;if(t.size>g)throw new Error("Data too large");const L=y(n,"register"),{data:v}=await f(L,{query:{f:"json",itemName:be(s),description:e},responseType:"json",method:"post"});if(c(r),!v.success)throw new Error("Registration failed");const{itemID:R}=v.item;a=y(n,R);const z=y(a,"uploadPart"),E=Math.ceil(t.size/$),w=new Array;for(let u=0;u<E;++u)w.push(t.slice(u*$,Math.min((u+1)*$,t.size)));const P=w.slice().reverse(),F=new Array,G=h(E,r==null?void 0:r.onProgress,"uploadItem"),H=async()=>{for(;P.length!==0;){const u=w.length-P.length,T=P.pop(),b=new FormData,K=G.simulate(u,me(T.size));try{const W=T;b.append("f","json"),b.append("file",W),b.append("partId",`${u}`);const{data:V}=await f(z,{timeout:0,body:b,responseType:"json",method:"post"});if(c(r),!V.success)throw new Error("Part upload failed")}finally{K.remove()}}};for(let u=0;u<Pe&&P.length!==0;++u)F.push(H());await Promise.all(F);const J=y(a,"commit"),{data:j}=await f(J,{query:{f:"json",parts:w.map((u,T)=>T).join(",")},responseType:"json",method:"post"});if(c(r),!j.success)throw new Error("Commit failed");return j.item}catch(n){if(a!=null){const i=y(a,"delete");await f(i,{query:{f:"json"},responseType:"json",method:"post"})}throw n}}function be(t){return t.replaceAll("/","_").replaceAll("\\","_")}async function is(t,s,e){var a;const o=t.length;if(!o)return(a=e==null?void 0:e.onProgress)==null||a.call(e,1),[];const r=h(o,e==null?void 0:e.onProgress,"uploadAssets");return Promise.all(t.map((n,i)=>$e(n,s,{...e,onProgress:r.makeOnProgress(i)})))}async function $e(t,{layer:s,ongoingUploads:e},o){var n;const r=e.get(t);if(r)return r;if(!qe(s))throw new m(`${s.type}-layer:upload-failure`,"Layer does not support asset uploads.",new Error);if(Ae(t,s))return(n=o==null?void 0:o.onProgress)==null||n.call(o,1),t;const a=ve(t,s,o);e.set(t,a);try{await a}finally{e.delete(t)}return t}function Ae(t,s){const{parsedUrl:e}=s;return e!=null&&t.metadata.externalSources.some(o=>le(o,e))}async function ve(t,s,e){const{metadata:o}=t,{displaySource:r}=o,a=B(r==null?void 0:r.source,s),n=!!a,i=o.externalSources.length>0,l=n?Ee(a,s,e):i?Fe(t,s,e):je(t,s,e),p=await l;return c(e),t.addExternalSources([p]),t}async function Ee(t,s,e){return{source:await q(t,s,e),original:!0}}async function Fe(t,s,e){const o=O(s),{externalSources:r}=t.metadata,a=Ie(r,s);if(!a)throw new m(`${s.type}-layer:upload-failure`,"Could not find an external source that is supported by the service.",new Error);const n=h(A.uploadConvertibleSource,e==null?void 0:e.onProgress,"uploadConvertibleSource"),i=await q(a,s,{onProgress:n.makeOnProgress("uploadEditSource")});t.addExternalSources([{source:i,original:!0}]);const l=n.simulate("serviceAssetsToGlb");try{return{source:await ke(i,s,o)}}finally{l.remove()}}async function je(t,s,e){const o=h(A.uploadLocalMesh,e==null?void 0:e.onProgress,"uploadLocalMesh"),r=De(t,s,{...e,onProgress:o.makeOnProgress("meshToAssetBlob")});return{source:await C([r],s,{...e,onProgress:o.makeOnProgress("uploadAssetBlobs")}),extent:t.extent.clone(),original:!0}}async function De(t,s,e){const o=O(s),r=await t.load(e),a=await r.toBinaryGLTF({ignoreLocalTransform:!0});c(e);const n=await a.buffer();return c(e),{blob:new Blob([n.data],{type:n.type}),assetName:`${se()}.glb`,assetType:o}}function Ie(t,s){for(const e of t){const o=B(e.source,s);if(o)return o}return null}function B(t,s){if(!t)return null;const{infoFor3D:{supportedFormats:e,editFormats:o}}=s,r=ce(t),a=new Array;let n=!1;for(let i=0;i<r.length;++i){const l=Ne(r[i],e);if(!l)return null;o.includes(l.assetType)&&(n=!0),a.push(l)}return n?a:null}function Ne(t,s){const e=pe(t,s);return e?{asset:t,assetType:e}:null}async function q(t,s,e){return C(t.map(o=>Se(o,e)),s,e)}async function C(t,s,e){const o=h(A.uploadAssetBlobs,e==null?void 0:e.onProgress,"uploadAssetBlobs"),r=await Me(t,s,{...e,onProgress:o.makeOnProgress("prepareAssetItems")});c(e);const a=r.map(({item:i})=>i),{uploadResults:n}=await Ue(a,s,{...e,onProgress:o.makeOnProgress("uploadAssetItems")});return c(e),t.map((i,l)=>_e(r[l],n[l],s))}async function Se(t,s){const{asset:e,assetType:o}=t;if(e instanceof File)return{blob:e,assetName:e.name,assetType:o};const r=await e.toBlob(s);return c(s),{blob:r,assetName:e.assetName,assetType:o}}async function xe(t,s,e){const{blob:o,assetType:r,assetName:a}=t;let n=null;try{const i=await Te({data:o,name:a},s.url,e);c(e),n={assetType:r,assetUploadId:i.itemID}}catch(i){ae(i),ne.getLogger("esri.layers.graphics.sources.support.uploadAssets").warnOnce(`Service ${s.url} does not support the REST Uploads API.`)}if(!n){const i=await ie(o);if(c(e),!i.isBase64)throw new m(`${s.type}-layer:uploadAssets-failure`,"Expected gltf data in base64 format after conversion.",new Error);n={assetType:r,assetData:i.data}}if(!n)throw new m(`${s.type}-layer:uploadAssets-failure`,"Unable to prepare uploadAsset request options.",new Error);return{item:n,assetName:a}}function Me(t,s,e){const o=h(t.length,e==null?void 0:e.onProgress,"prepareAssetItems");return Promise.all(t.map(async(r,a)=>{const n=xe(await r,s,{...e,onProgress:o.makeOnProgress(a)});return c(e),n}))}async function Ue(t,s,e){const o=_(e==null?void 0:e.onProgress);try{const r=await f(y(s.parsedUrl.path,"uploadAssets"),{timeout:0,query:{f:"json",assets:JSON.stringify(t)},method:"post",responseType:"json"});if(c(e),r.data.uploadResults.length!==t.length)throw new m(`${s.type}-layer:uploadAssets-failure`,`Bad response. Uploaded ${t.length} items and received ${r.data.uploadResults.length} results.`,new Error);return r.data}finally{o.remove()}}function _e(t,s,e){const{success:o}=s;if(!o){const{error:p}=s;throw new m(`${e.type}-layer:upload-failure`,`Failed to upload mesh file ${t.assetName}. Error code: ${(p==null?void 0:p.code)??"-1"}. Error message: ${(p==null?void 0:p.messages)??"unknown"}`,new Error)}const{assetHash:r}=s,{assetName:a,item:{assetType:n}}=t,{infoFor3D:{supportedFormats:i}}=e,l=te(n,i);if(!l)throw new m(`${e.type}-layer:upload-failure`,`The service allowed us to upload an asset of FormatID ${n}, but it does not list it in its supported formats.`,new Error);return new M(a,l,[new U(`${e.parsedUrl.path}/assets/${r}`,r)])}async function ke(t,s,e){var p;const o=t.map(({assetName:d,parts:g})=>({assetName:d,assetHash:g[0].partHash})),r=(p=s.capabilities)==null?void 0:p.operations.supportsAsyncConvert3D,a={query:{f:"json",assets:JSON.stringify(o),transportType:"esriTransportTypeUrl",targetFormat:e,async:r},responseType:"json",timeout:0},n=y(s.parsedUrl.path,"convert3D"),i=(r?await Be(n,a):await f(n,a)).data,{infoFor3D:{supportedFormats:l}}=s;return i.assets.map(d=>{const g=x(d.contentType,l);if(!g)throw new m(`${s.type}-layer:upload-failure`,`The service allowed us to upload an asset of FormatID ${g}, but it does not list it in its supported formats.`,new Error);return new M(d.assetName,d.contentType,[new U(d.assetURL,d.assetHash)])})}async function Be(t,s){const e=(await f(t,s)).data.statusUrl;for(;;){const o=(await f(e,{query:{f:"json"},responseType:"json"})).data;switch(o.status){case"Completed":return f(o.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new m("async-convert3D-failed","asynchronous convert3D call failed.");case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new m("async-convert3D-failed","asynchronous convert3D call failed (undefined response status)")}await oe(Ce)}}function qe(t){return!!t.infoFor3D&&!!t.url}function O(t){const{infoFor3D:s}=t,e=x("model/gltf-binary",s.supportedFormats)??re("glb",s.supportedFormats);if(!e)throw new m(`${t.type}-layer:upload-failure`,"Layer does not support glb.",new Error);return e}const Ce=1e3;export{is as uploadAssets};
