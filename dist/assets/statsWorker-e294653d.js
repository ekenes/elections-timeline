import{ev as N,Y as S,aJ as G,ew as O,ex as A,b6 as B,e9 as L,ey as R,ez as Y}from"./index-10102046.js";import{L as j}from"./quantizationUtils-64099a94.js";import{c as E,z as q,m as _,f as k,d as J,g as U,x as Z,F as H,D as K,S as Q,M as W}from"./utils-ac2051b8.js";import"./generateRendererUtils-5add6e8e.js";let z=null;function X(e,a,o){return e.x<0?e.x+=a:e.x>o&&(e.x-=a),e}function aa(e,a,o,l){const n=N(o)?S(o):null,s=n?Math.round((n.valid[1]-n.valid[0])/a.scale[0]):null;return e.map(t=>{const i=new G(t.geometry);return j(a,i,i,i.hasZ,i.hasM),t.geometry=n?X(i,s??0,l[0]):i,t})}function ea(e,a=18,o,l,n,s){const t=new Float64Array(n*s);a=Math.round(L(a));let i=Number.POSITIVE_INFINITY,m=Number.NEGATIVE_INFINITY,r=0,u=0,p=0,d=0;const I=R(l,o);for(const{geometry:F,attributes:$}of e){const{x,y:T}=F,c=Math.max(0,x-a),y=Math.max(0,T-a),f=Math.min(s,T+a),w=Math.min(n,x+a),M=+I($);for(let h=y;h<f;h++)for(let V=c;V<w;V++){const b=h*n+V,P=Y(V-x,h-T,a),C=t[b];r=t[b]+=P*M;const D=r-C;u+=D,p+=D*D,r<i&&(i=r),r>m&&(m=r),d++}}if(!d)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const v=(m-i)/2;return{mean:u/d,stdDev:Math.sqrt((p-u*u/d)/d),min:i,max:m,mid:v,count:d}}async function g(e,a){if(!a)return[];const{field:o,field2:l,field3:n,fieldDelimiter:s,fieldInfos:t}=e,i=o&&(t==null?void 0:t.find(c=>c.name.toLowerCase()===o.toLowerCase())),m=!!i&&O(i),r=e.valueExpression,u=e.normalizationType,p=e.normalizationField,d=e.normalizationTotal,I=[],v=e.viewInfoParams;let F=null,$=null;if(r){if(!z){const{arcadeUtils:c}=await A();z=c}z.hasGeometryOperations(r)&&await z.enableGeometryOperations(),F=z.createFunction(r),$=v&&z.getViewInfo({viewingMode:v.viewingMode,scale:v.scale,spatialReference:new B(v.spatialReference)})}const x=e.fieldInfos,T=!(a[0]&&"declaredClass"in a[0]&&a[0].declaredClass==="esri.Graphic")&&x?{fields:x}:null;return a.forEach(c=>{const y=c.attributes;let f;if(r){const w=T?{...c,layer:T}:c,M=z.createExecContext(w,$);f=z.executeFunction(F,M)}else y&&(f=y[o],l?(f=`${E(f)}${s}${E(y[l])}`,n&&(f=`${f}${s}${E(y[n])}`)):m&&typeof f=="string"&&(f=f?new Date(f).getTime():null));if(u&&typeof f=="number"&&isFinite(f)){const w=y&&parseFloat(y[p]);f=q(f,u,w,d)}I.push(f)}),I}async function la(e){const{attribute:a,features:o}=e,{normalizationType:l,normalizationField:n,minValue:s,maxValue:t,fieldType:i}=a,m=await g({field:a.field,valueExpression:a.valueExpression,normalizationType:l,normalizationField:n,normalizationTotal:a.normalizationTotal,viewInfoParams:a.viewInfoParams,fieldInfos:a.fieldInfos},o),r=_({normalizationType:l,normalizationField:n,minValue:s,maxValue:t}),u={value:.5,fieldType:i},p=i==="esriFieldTypeString"?k({values:m,supportsNullCount:r,percentileParams:u}):J({values:m,minValue:s,maxValue:t,useSampleStdDev:!l,supportsNullCount:r,percentileParams:u});return U(p,i==="esriFieldTypeDate")}async function sa(e){const{attribute:a,features:o}=e,l=await g({field:a.field,field2:a.field2,field3:a.field3,fieldDelimiter:a.fieldDelimiter,valueExpression:a.valueExpression,viewInfoParams:a.viewInfoParams,fieldInfos:a.fieldInfos},o),n=Z(l);return H(n,a.domains,a.returnAllCodedValues,a.fieldDelimiter)}async function ra(e){const{attribute:a,features:o}=e,{field:l,normalizationType:n,normalizationField:s,normalizationTotal:t,classificationMethod:i}=a,m=await g({field:l,valueExpression:a.valueExpression,normalizationType:n,normalizationField:s,normalizationTotal:t,viewInfoParams:a.viewInfoParams,fieldInfos:a.fieldInfos},o),r=K(m,{field:l,normalizationType:n,normalizationField:s,normalizationTotal:t,classificationMethod:i,standardDeviationInterval:a.standardDeviationInterval,numClasses:a.numClasses,minValue:a.minValue,maxValue:a.maxValue});return Q(r,i)}async function ma(e){const{attribute:a,features:o}=e,{field:l,normalizationType:n,normalizationField:s,normalizationTotal:t,classificationMethod:i}=a,m=await g({field:l,valueExpression:a.valueExpression,normalizationType:n,normalizationField:s,normalizationTotal:t,viewInfoParams:a.viewInfoParams,fieldInfos:a.fieldInfos},o);return W(m,{field:l,normalizationType:n,normalizationField:s,normalizationTotal:t,classificationMethod:i,standardDeviationInterval:a.standardDeviationInterval,numBins:a.numBins,minValue:a.minValue,maxValue:a.maxValue})}async function fa(e){const{attribute:a,features:o}=e,{field:l,radius:n,fieldOffset:s,transform:t,spatialReference:i}=a,m=a.size??[0,0],r=aa(o??[],t,i,m),{count:u,min:p,max:d,mean:I,stdDev:v}=ea(r,n??void 0,s,l,m[0],m[1]);return{count:u,min:p,max:d,avg:I,stddev:v}}export{ra as classBreaks,fa as heatmapStatistics,ma as histogram,la as summaryStatistics,sa as uniqueValues};
