import{eT as B,X as L,aB as Y,eU as C,eV as j,eW as A,bf as _,ey as Z,eX as R,eY as X}from"./index-7df220b7.js";import{L as Q}from"./quantizationUtils-6260a1a7.js";import{Z as W}from"./utils-a1f7a94c.js";import{a as H,d as J}from"./generateRendererUtils-0936b13c.js";const K="<Null>",ee="equal-interval",te=1,ne=5,le=10,ae=/\s*(\+|-)?((\d+(\.\d+)?)|(\.\d+))\s*/gi,ie=new Set(["esriFieldTypeDate","esriFieldTypeInteger","esriFieldTypeSmallInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeOID","esriFieldTypeBigInteger"]),oe=new Set(["esriFieldTypeTimeOnly","esriFieldTypeDateOnly"]),re=["min","max","avg","stddev","count","sum","variance","nullcount","median"];function V(e){return e==null||typeof e=="string"&&!e?K:e}function se(e){const t=e.normalizationField!=null||e.normalizationType!=null,n=e.minValue!=null||e.maxValue!=null,l=!!e.sqlExpression&&e.supportsSQLExpression;return!t&&!n&&!l}function Ee(e){const t=e.returnDistinct?[...new Set(e.values)]:e.values,n=t.filter(i=>i!=null).sort(),l=n.length,a={count:l,min:n[0],max:n[l-1]};return e.supportsNullCount&&(a.nullcount=t.length-l),e.percentileParams&&(a.median=P(t,e.percentileParams)),a}function ue(e){const{values:t,useSampleStdDev:n,supportsNullCount:l}=e;let a=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY,o=null,r=null,s=null,f=null,c=0;const d=e.minValue==null?-1/0:e.minValue,m=e.maxValue==null?1/0:e.maxValue;for(const u of t)Number.isFinite(u)?u>=d&&u<=m&&(o=o===null?u:o+u,a=Math.min(a,u),i=Math.max(i,u),c++):typeof u=="string"&&c++;if(c&&o!=null){r=o/c;let u=0;for(const v of t)Number.isFinite(v)&&v>=d&&v<=m&&(u+=(v-r)**2);f=n?c>1?u/(c-1):0:c>0?u/c:0,s=Math.sqrt(f)}else a=null,i=null;const h={avg:r,count:c,max:i,min:a,stddev:s,sum:o,variance:f};return l&&(h.nullcount=t.length-c),e.percentileParams&&(h.median=P(t,e.percentileParams)),h}function P(e,t){const{fieldType:n,value:l,orderBy:a,isDiscrete:i}=t,o=me(n,a==="desc");if((e=[...e].filter(h=>h!=null).sort((h,u)=>o(h,u))).length===0)return null;if(l<=0)return e[0];if(l>=1)return e[e.length-1];const r=(e.length-1)*l,s=Math.floor(r),f=s+1,c=r%1,d=e[s],m=e[f];return f>=e.length||i||typeof d=="string"||typeof m=="string"?d:d*(1-c)+m*c}function me(e,t){if(e){if(ie.has(e))return O(t);if(oe.has(e))return E(t,!1);if(e==="esriFieldTypeTimestampOffset")return pe(t);const i=E(t,!0);if(e==="esriFieldTypeString")return i;if(e==="esriFieldTypeGUID"||e==="esriFieldTypeGlobalID")return(o,r)=>i(G(o),G(r))}const n=t?1:-1,l=O(t),a=E(t,!0);return(i,o)=>typeof i=="number"&&typeof o=="number"?l(i,o):typeof i=="string"&&typeof o=="string"?a(i,o):n}const M=(e,t)=>e==null?t==null?0:1:t==null?-1:null,w=(e,t)=>e==null?t==null?0:-1:t==null?1:null;function ce(e){return e?M:w}const fe=(e,t)=>w(e,t)??(e===t?0:new Date(e).getTime()-new Date(t).getTime()),de=(e,t)=>M(e,t)??(e===t?0:new Date(t).getTime()-new Date(e).getTime());function pe(e){return e?de:fe}const he=(e,t)=>w(e,t)??(e===t?0:e<t?-1:1),ve=(e,t)=>M(e,t)??(e===t?0:e<t?1:-1);function E(e,t){if(!t)return e?ve:he;const n=ce(e);return e?(l,a)=>{const i=n(l,a);return i??((l=l.toUpperCase())>(a=a.toUpperCase())?-1:l<a?1:0)}:(l,a)=>{const i=n(l,a);return i??((l=l.toUpperCase())<(a=a.toUpperCase())?-1:l>a?1:0)}}const ye=(e,t)=>M(e,t)??t-e,Te=(e,t)=>w(e,t)??e-t;function O(e){return e?ye:Te}function G(e){return e.substr(24,12)+e.substr(19,4)+e.substr(16,2)+e.substr(14,2)+e.substr(11,2)+e.substr(9,2)+e.substr(6,2)+e.substr(4,2)+e.substr(2,2)+e.substr(0,2)}function ke(e,t){let n;for(n in e)re.includes(n)&&(Number.isFinite(e[n])||(e[n]=null));return t&&["avg","stddev","variance"].forEach(l=>{e[l]!=null&&(e[l]=Math.ceil(e[l]??0))}),e}function Oe(e){const t={};for(let n of e)(n==null||typeof n=="string"&&n.trim()==="")&&(n=null),t[n]==null?t[n]={count:1,data:n}:t[n].count++;return{count:t}}function k(e){return(e==null?void 0:e.type)!=="coded-value"?[]:e.codedValues.map(t=>t.code)}function Ge(e,t,n,l){const a=e.count,i=[];if(n&&t){const o=[],r=k(t[0]);for(const s of r)if(t[1]){const f=k(t[1]);for(const c of f)if(t[2]){const d=k(t[2]);for(const m of d)o.push(`${V(s)}${l}${V(c)}${l}${V(m)}`)}else o.push(`${V(s)}${l}${V(c)}`)}else o.push(s);for(const s of o)a.hasOwnProperty(s)||(a[s]={data:s,count:0})}for(const o in a){const r=a[o];i.push({value:r.data,count:r.count,label:r.label})}return{uniqueValueInfos:i}}function be(e,t,n,l){let a=null;switch(t){case"log":e!==0&&(a=Math.log(e)*Math.LOG10E);break;case"percent-of-total":Number.isFinite(l)&&l!==0&&(a=e/l*100);break;case"field":Number.isFinite(n)&&n!==0&&(a=e/n);break;case"natural-log":e>0&&(a=Math.log(e));break;case"square-root":e>0&&(a=e**.5)}return a}function ge(e,t){const n=Ve({field:t.field,normalizationType:t.normalizationType,normalizationField:t.normalizationField,classificationMethod:t.classificationMethod,standardDeviationInterval:t.standardDeviationInterval,breakCount:t.numClasses||ne});return e=xe(e,t.minValue,t.maxValue),H({definition:n,values:e,normalizationTotal:t.normalizationTotal})}function xe(e,t,n){const l=t??-1/0,a=n??1/0;return e.filter(i=>Number.isFinite(i)&&i>=l&&i<=a)}function Ve(e){const{breakCount:t,field:n,normalizationField:l,normalizationType:a}=e,i=e.classificationMethod||ee,o=i==="standard-deviation"?e.standardDeviationInterval||te:void 0;return new J({breakCount:t,classificationField:n,classificationMethod:i,normalizationField:a==="field"?l:void 0,normalizationType:a,standardDeviationInterval:o})}function Pe(e,t){var s,f;let n=e.classBreaks;const l=n.length,a=(s=n[0])==null?void 0:s.minValue,i=(f=n[l-1])==null?void 0:f.maxValue,o=t==="standard-deviation",r=ae;return n=n.map(c=>{const d=c.label,m={minValue:c.minValue,maxValue:c.maxValue,label:d};if(o&&d){const h=d.match(r),u=(h==null?void 0:h.map(v=>+v.trim()))??[];u.length===2?(m.minStdDev=u[0],m.maxStdDev=u[1],u[0]<0&&u[1]>0&&(m.hasAvg=!0)):u.length===1&&(d.includes("<")?(m.minStdDev=null,m.maxStdDev=u[0]):d.includes(">")&&(m.minStdDev=u[0],m.maxStdDev=null))}return m}),{minValue:a,maxValue:i,classBreakInfos:n,normalizationTotal:e.normalizationTotal}}function Ue(e,t){const n=Fe(e,t);if(n.min==null&&n.max==null)return{bins:[],minValue:n.min,maxValue:n.max,normalizationTotal:t.normalizationTotal};const l=n.intervals,a=n.min??0,i=n.max??0,o=l.map((r,s)=>({minValue:l[s][0],maxValue:l[s][1],count:0}));for(const r of e)if(r!=null&&r>=a&&r<=i){const s=$e(l,r);s>-1&&o[s].count++}return{bins:o,minValue:a,maxValue:i,normalizationTotal:t.normalizationTotal}}function Fe(e,t){const{field:n,classificationMethod:l,standardDeviationInterval:a,normalizationType:i,normalizationField:o,normalizationTotal:r,minValue:s,maxValue:f}=t,c=t.numBins||le;let d=null,m=null,h=null;if((!l||l==="equal-interval")&&!i){if(s!=null&&f!=null)d=s,m=f;else{const u=ue({values:e,minValue:s,maxValue:f,useSampleStdDev:!i,supportsNullCount:se({normalizationType:i,normalizationField:o,minValue:s,maxValue:f})});d=u.min??null,m=u.max??null}h=Ie(d??0,m??0,c)}else{const{classBreaks:u}=ge(e,{field:n,normalizationType:i,normalizationField:o,normalizationTotal:r,classificationMethod:l,standardDeviationInterval:a,minValue:s,maxValue:f,numClasses:c});d=u[0].minValue,m=u[u.length-1].maxValue,h=u.map(v=>[v.minValue,v.maxValue])}return{min:d,max:m,intervals:h}}function $e(e,t){let n=-1;for(let l=e.length-1;l>=0;l--)if(t>=e[l][0]){n=l;break}return n}function Ie(e,t,n){const l=(t-e)/n,a=[];let i,o=e;for(let r=1;r<=n;r++)i=o+l,i=Number(i.toFixed(16)),a.push([o,r===n?t:i]),o=i;return a}let x=null;const Ne=/^(?<hh>([0-1][0-9])|([2][0-3])):(?<mm>[0-5][0-9])(:(?<ss>[0-5][0-9]))?([.](?<ms>\d+))?$/;function ze(e,t,n){return e.x<0?e.x+=t:e.x>n&&(e.x-=t),e}function qe(e,t,n,l){const a=B(n)?L(n):null,i=a?Math.round((a.valid[1]-a.valid[0])/t.scale[0]):null;return e.map(o=>{const r=new Y(o.geometry);return Q(t,r,r,r.hasZ,r.hasM),o.geometry=a?ze(r,i??0,l[0]):r,o})}function Be(e,t=18,n,l,a,i){const o=new Float64Array(a*i);t=Math.round(Z(t));let r=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,f=0,c=0,d=0,m=0;const h=R(l,n);for(const{geometry:v,attributes:$}of e){const{x:T,y:F}=v,I=Math.max(0,T-t),N=Math.max(0,F-t),z=Math.min(i,F+t),y=Math.min(a,T+t),b=+h($);for(let p=N;p<z;p++)for(let g=I;g<y;g++){const D=p*a+g,U=X(g-T,p-F,t),q=o[D];f=o[D]+=U*b;const S=f-q;c+=S,d+=S*S,f<r&&(r=f),f>s&&(s=f),m++}}if(!m)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const u=(s-r)/2;return{mean:c/m,stdDev:Math.sqrt((d-c*c/m)/m),min:r,max:s,mid:u,count:m}}function De(e){const t=Ne.exec(e);if(!t)return null;const{hh:n,mm:l,ss:a,ms:i}=t.groups;return Number(n)*C.hours+Number(l)*C.minutes+Number(a)*C.seconds+Number(i||0)}async function Le(e,t,n=!0){if(!t)return[];const{field:l,field2:a,field3:i,fieldDelimiter:o,fieldInfos:r,timeZone:s}=e,f=l&&(r==null?void 0:r.find(y=>y.name.toLowerCase()===l.toLowerCase())),c=!!f&&j(f),d=!!f&&W(f),m=e.valueExpression,h=e.normalizationType,u=e.normalizationField,v=e.normalizationTotal,$=[],T=e.viewInfoParams;let F=null,I=null;if(m){if(!x){const{arcadeUtils:y}=await A();x=y}x.hasGeometryOperations(m)&&await x.enableGeometryOperations(),F=x.createFunction(m),I=T?x.getViewInfo({viewingMode:T.viewingMode,scale:T.scale,spatialReference:new _(T.spatialReference)}):null}const N=e.fieldInfos,z=!(t[0]&&"declaredClass"in t[0]&&t[0].declaredClass==="esri.Graphic")&&N?{fields:N}:null;return t.forEach(y=>{const b=y.attributes;let p;if(m){const g=z?{...y,layer:z}:y,D=x.createExecContext(g,I,s);p=x.executeFunction(F,D)}else b&&(p=b[l],a?(p=`${V(p)}${o}${V(b[a])}`,i&&(p=`${p}${o}${V(b[i])}`)):typeof p=="string"&&n&&(d?p=p?new Date(p).getTime():null:c&&(p=p?De(p):null)));if(h&&typeof p=="number"&&isFinite(p)){const g=b&&parseFloat(b[u]);p=be(p,h,g,v)}$.push(p)}),$}export{Ge as $,be as B,ke as C,ge as E,Pe as P,me as T,Ue as U,Le as b,V as c,Ee as d,se as f,qe as j,Oe as k,ue as p,P as v,De as w,Be as x};
